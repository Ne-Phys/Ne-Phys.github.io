{"categories":[{"title":"文","uri":"https://cs-fil.github.io/categories/%E6%96%87/"},{"title":"知识点","uri":"https://cs-fil.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"题解","uri":"https://cs-fil.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"posts":[{"content":"链接 摘要  在 $n$$×$$m$ 的矩阵中, 有 $t$ 个关键点\n问是否可以通过上下左右移动关键点, 使得每行每列的关键点数相等 特别的, 第一列和第 $n$ 列相邻, 行亦然\n解  可以发现: 左右移动不会影响行关键点数, 上下不影响列\n于是拆分为两个部分: 左右移动使得列关键点数相等, 上下使行等\n于是问题变成了一维: 环形均分纸牌问题\n普通的均分纸牌问题, 先考虑第一个人索取或给予, 后将一二人视为一个整体考虑索取或给予\n若先预处理每一个人的手牌数减去均值, 则目标即是 $0$\n答案即是前缀和绝对值之和\n而考虑环形, 非环形的情况就是在第一个人和第 $n$ 个人之间断开 考虑朴素算法, 我们只需枚举断开的位置即可\n假设位置是 $k$, $a[k+1]$ 对应的前缀和即是 $s[k+1]-s[k]$\n多列几个关键点式子, 发现前缀和绝对值之和, 就是在之前的基础上, 每一项减去 $s[k]$\n该问题巧妙地指向了货仓选址问题, 即只需排序找到中位数便可得出答案\ndebug  $ceil$ 函数内外都是 double\n答案要考虑是否 $long long$\n技巧  省 $ceil$ k=(n+(n\u0026amp;1))\u0026gt;\u0026gt;1\n最终求和还可以优化省去 $abs$\nfor(int i=1;i\u0026lt;=n;++i)s1[i]+=s1[i-1];\rrnum=s1[n]-s1[i]-(n-i)*(s1[i]-s1[i-1])+i*(s1[i]-s1[i-1])-s1[i];\r 代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int N=1e5+5;\rint n,m,t;\rll a[N],b[N],aa[N],ba[N],as[N],bs[N];\rbool flg1=false,flg2=false;\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;t);\rint x,y;\rifor(i,1,t)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;x,\u0026amp;y);\ra[x]++,b[y]++;\r}\rll a1=t/n,b1=t/m;\rll ans=0;\rif(t%n==0)\r{\rifor(i,1,n)\raa[i]=a[i]-a1,as[i]=as[i-1]+aa[i];\rstd::sort(as+1,as+n+1);\rll k=as[(int)ceil((double)n/2)];\rifor(i,1,n)\rans+=abs(as[i]-k);\rflg1=true;\r}\rif(t%m==0)\r{\rifor(i,1,m)\rba[i]=b[i]-b1,bs[i]=bs[i-1]+ba[i];\rstd::sort(bs+1,bs+m+1);\rll k=bs[(int)ceil((double)m/2)];\rifor(i,1,m)\rans+=abs(bs[i]-k);\rflg2=true;\r}\rif(flg1\u0026amp;\u0026amp;flg2)\rprintf(\u0026quot;both %lld\u0026quot;,ans);\relse if(flg1)\rprintf(\u0026quot;row %lld\u0026quot;,ans);\relse if(flg2)\rprintf(\u0026quot;column %lld\u0026quot;,ans);\relse printf(\u0026quot;impossible\u0026quot;);\rsystem(\u0026quot;pause\u0026quot;);\r}\r  省 $abs$\n","id":0,"section":"posts","summary":"","tags":["数学"],"title":"CH 0502 七夕祭","uri":"https://cs-fil.github.io/2020/12/ch-0502/","year":"2020"},{"content":"链接 摘要  $n$ 个人各自会一门语言, 语言用 $int$ 范围内的整数表示\n$m$ 部电影, 各自有配音和字幕\n求一部电影, 其配音的语言其次字幕的语言会的人最多\n解  语言表示在 $int$ 范围内, 故需要离散化 一是用 $map$ 直接用作数组 二是手写离散化, 时空复杂度小\n代码  $map$\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;map\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=2e5+5;\rint n,m;\rstd::map\u0026lt;int,int\u0026gt; map;\rstruct node\r{\rint p,a,b;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return (a\u0026gt;x.a)||(a==x.a\u0026amp;\u0026amp;b\u0026gt;x.b);}\r}mv[N];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint x;\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x),map[x]++;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;m);\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rmv[i].p=i;\rif(map.count(x))\rmv[i].a=map[x];\r}\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rif(map.count(x))\rmv[i].b=map[x];\r}\rstd::sort(mv+1,mv+m+1);\rprintf(\u0026quot;%d\u0026quot;,mv[1].p);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r  手写离散化\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=2e5+5;\rint n,m;\rint l[N],t[N],ttl[N],c;\rstruct node\r{\rint p,a,b;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return (a\u0026gt;x.a)||((a==x.a)\u0026amp;\u0026amp;(b\u0026gt;x.b));}\r}mv[N];\rinline void discrete()\r{\rstd::sort(l+1,l+n+1);\rifor(i,1,n)\r{\rif(i==1||l[i]!=l[i-1])\rt[++c]=l[i];//t数组用于查位置\rttl[c]++;\r}\r}\rinline int query(int x)\r{\rreturn std::lower_bound(t+1,t+c+1,x)-t;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;l[i]);\rdiscrete();\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;m);\rint x;\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rmv[i].p=i;\rif(t[query(x)]==x)\rmv[i].a=ttl[query(x)];\r}\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rif(t[query(x)]==x)\rmv[i].b=ttl[query(x)];\r}\rstd::sort(mv+1,mv+m+1);\rprintf(\u0026quot;%d\u0026quot;,mv[1].p);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":1,"section":"posts","summary":"","tags":["离散化"],"title":"Codeforces 670C Cinema","uri":"https://cs-fil.github.io/2020/12/cf-670c/","year":"2020"},{"content":"inline void discrete()\r{\rstd::sort(l+1,l+n+1);\rifor(i,1,n)\r{\rif(i==1||l[i]!=l[i-1])\rt[++c]=l[i];//t数组用于查位置\r//ttl[c]++; 相关数据维护\r}\r}\rinline int query(int x)\r{\rreturn std::lower_bound(t+1,t+c+1,x)-t;\r}\r","id":2,"section":"posts","summary":"","tags":["离散化"],"title":"离散化","uri":"https://cs-fil.github.io/2020/12/discrete/","year":"2020"},{"content":"链接 摘要  $\u0026quot;\u0026lt;=\u0026quot;$ 且涉及无解判断的二分\n解  二分有两个模板\n$\u0026quot;\u0026lt;=\u0026quot;$ 用以下这个二分模板\n于是无解判断只需左边范围多开一位\n若最终 $l$ 在多开的那一位, 则无解\ndebug  (不知为何)输入时 (double)*100 转 (int) 需要 $ceil$ 函数 否则会有误差, 如 $8.19$ $=\u0026gt;$ $820$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e4+5;\rint n,m;\rdouble t;\rint a[N];\rchar tmp[100];\rinline bool judge(int x)\r{\rint res=0;\rifor(i,1,n)\rres+=a[i]/x;\rif(res\u0026gt;=m) return true;\relse return false;\r}\rint main()\r{\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\r//freopen(\u0026quot;out1.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\r//ifor(i,1,3) scanf(\u0026quot;%s\u0026quot;,tmp);\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rint r=0;\rifor(i,1,n)\rscanf(\u0026quot;%lf\u0026quot;,\u0026amp;t),a[i]=ceil(t*100),r=r\u0026gt;a[i]?r:a[i];\r//ifor(i,1,n)\r// printf(\u0026quot;%d\\n\u0026quot;,a[i]);\rint l=0;\rwhile(l\u0026lt;r)\r{\rint mid=(l+r+1)\u0026gt;\u0026gt;1;\r//printf(\u0026quot;%d %d %d\\n\u0026quot;,l,r,mid);\rif(judge(mid))\rl=mid;\relse r=mid-1;\r}\rif(l==0) printf(\u0026quot;0.00\u0026quot;);\relse printf(\u0026quot;%.2lf\u0026quot;,(double)l/100);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":3,"section":"posts","summary":"","tags":["二分"],"title":"POJ 1064 Cable master","uri":"https://cs-fil.github.io/2020/11/poj-1064/","year":"2020"},{"content":"链接 摘要  序列 $n$ 中长度 ∈[S,T] 的子序列的最大平均值\n解  答案具有单调性, 用二分转化为判定性问题\n考虑二分平均值\n简化取平均的操作, 预处理减去平均值的数列, 则只需判断是否有子段和大于零即可\n而求子段和最大值引入单调队列, 队列内维护子段首数前一个数的前缀和, 队列内单调递增\n技巧  实数范围内的二分需设置精度 $eps$ 即 while(l+eps\u0026lt;r)\n若保留 $k$ 位小数, 则取 $eps$$=$$10^{-(k+2)}$\nl=mid 或 r=mid\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5;\rint n,s,t,hd,tl,q[N];\rdouble a[N],tmp[N],sum[N];\rinline bool judge(double p)\r{\rifor(i,1,n)\rtmp[i]=a[i]-p;\rifor(i,1,n)\rsum[i]=sum[i-1]+tmp[i];\rhd=1,tl=0;\rifor(i,1,n)\r{\rif(i\u0026gt;=s)\r{\rwhile(hd\u0026lt;=tl\u0026amp;\u0026amp;sum[i-s]\u0026lt;sum[q[tl]]) tl--;\rq[++tl]=i-s;\r}\rif(hd\u0026lt;=tl\u0026amp;\u0026amp;q[hd]\u0026lt;i-t) hd++;\rif(hd\u0026lt;=tl\u0026amp;\u0026amp;sum[i]-sum[q[hd]]\u0026gt;=0) return true;\r}\rreturn false;\r}\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;s,\u0026amp;t);\rdouble l=-10000,r=10000;\rifor(i,1,n)\rscanf(\u0026quot;%lf\u0026quot;,\u0026amp;a[i]);\rdouble ans;\rwhile(r-l\u0026gt;1e-5)\r{\rdouble mid=(l+r)/2;\rif(judge(mid))\rl=ans=mid;\relse r=mid;\r}\rprintf(\u0026quot;%.3lf\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":4,"section":"posts","summary":"","tags":["单调队列","二分"],"title":"Luogu P1419 寻找段落","uri":"https://cs-fil.github.io/2020/11/luogu-p1419/","year":"2020"},{"content":"链接 解  树上差分:\n结点 $+$ $+$, 结点 $LCA$ $-$ $-$, 结点 $LCA$ 父亲 $-$ $-$\n处理完后 $dfs$ 祖先加上所有子结点\n值得注意的是端点会重复记录, 需最后减去\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=3e5+5;\rint n,a[N];\rint hd[N],ver[N\u0026lt;\u0026lt;1],nxt[N\u0026lt;\u0026lt;1],dpth[N],f[N][20],val[N],cnt;\rdouble lg2[N];\rinline void add(int u,int v)\r{\rver[++cnt]=v,nxt[cnt]=hd[u],hd[u]=cnt;\rver[++cnt]=u,nxt[cnt]=hd[v],hd[v]=cnt;\r}\rinline void build(int x,int p)\r{\rdpth[x]=dpth[p]+1;\rf[x][0]=p;\rfor(int i=1;(1\u0026lt;\u0026lt;i)\u0026lt;=dpth[x];++i)\rf[x][i]=f[f[x][i-1]][i-1];\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\rbuild(ver[i],x);\r}\rinline int lca(int x,int y)\r{\rif(dpth[x]\u0026lt;dpth[y])\rstd::swap(x,y);\rwhile(dpth[x]\u0026gt;dpth[y])\rx=f[x][(int)lg2[dpth[x]-dpth[y]]];\rif(x==y) return x;\rfor(int i=lg2[dpth[x]];i\u0026gt;=0;i--)\rif(f[x][i]!=f[y][i])\rx=f[x][i],y=f[y][i];\rreturn f[x][0];\r}\rinline void dfs(int x,int p)\r{\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\r{\rdfs(ver[i],x);\rval[x]+=val[ver[i]];\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\rint x,y;\rifor(i,1,n-1)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;x,\u0026amp;y),add(x,y);\rifor(i,1,n)\r{double k=log(i)/log(2);lg2[i]=k;}\rbuild(1,0);\rifor(i,1,n-1)\r{\rval[a[i]]++,val[a[i+1]]++,val[lca(a[i],a[i+1])]--;\rval[f[lca(a[i],a[i+1])][0]]--;\r}\rdfs(1,0);\rifor(i,2,n)\rval[a[i]]--;\rifor(i,1,n)\rprintf(\u0026quot;%d\\n\u0026quot;,val[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":5,"section":"posts","summary":"","tags":["差分","LCA"],"title":"Luogu P3258 [JLOI]松鼠的新家","uri":"https://cs-fil.github.io/2020/11/luogu-p3258/","year":"2020"},{"content":"链接 摘要  求序列 $n$ 中, 长度不超过 $m$ 的子序列的和的最大值 $n≤500000$\n解  $i$~$j$ 的序列和即为 $sum[j]-sum[i-1]$\n所以枚举过程中, 只需维护 $m$ 个数内 $sum[i]$ 的最小值\n考虑引入单调队列, 满足队列内 编号.$sum$ 都单调递增\n维护 $head.tail$, 于是便于弹出编号超出范围的, 便于弹出尾部加入新增的 $sum$ 值后不满足单调递增的\n只需 $O(n)$ 枚举, 时刻更新队列, 用 $sum[i]-sum[q[head]]$ 更新答案即可\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=5e5+5;\rint n,m,h=1,t;\rint q[N],sum[N];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rint x;\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x),sum[i]=sum[i-1]+x;\rint ans=-0x3f3f3f3f;\rifor(i,1,n)\r{\rif(h\u0026lt;=t\u0026amp;\u0026amp;q[h]\u0026lt;i-m) h++;\rans=std::max(ans,sum[i]-sum[q[h]]);\rwhile(h\u0026lt;=t\u0026amp;\u0026amp;sum[i]\u0026lt;=sum[q[t]]) t--;\rq[++t]=i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rreturn 0;\r}\r","id":6,"section":"posts","summary":"","tags":["单调队列"],"title":"Luogu P1714 切蛋糕","uri":"https://cs-fil.github.io/2020/11/luogu-p1714/","year":"2020"},{"content":" 1.建树 (同时预处理深度, 子父关系) 2.找祖先: 先到达同一深度, 后同时上跳直至公共祖先的下一层, 输出此时的父亲 预处理 $log_2$ 便于计算\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=5e5+5;\rint n,m,s;\rint hd[N],ver[N\u0026lt;\u0026lt;1],nxt[N\u0026lt;\u0026lt;1],dpth[N],f[N][20],cnt;\rdouble lg2[N];\rinline void add(int u,int v)\r{\rver[++cnt]=v,nxt[cnt]=hd[u],hd[u]=cnt;\rver[++cnt]=u,nxt[cnt]=hd[v],hd[v]=cnt;\r}\rinline void build(int x,int p)\r{\rdpth[x]=dpth[p]+1;\rf[x][0]=p;\rfor(int i=1;(1\u0026lt;\u0026lt;i)\u0026lt;=dpth[x];++i)\rf[x][i]=f[f[x][i-1]][i-1];\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\rdfs(ver[i],x);\r}\rinline int lca(int x,int y)\r{\rif(dpth[x]\u0026lt;dpth[y])\rstd::swap(x,y);\rwhile(dpth[x]\u0026gt;dpth[y])\rx=f[x][(int)lg2[dpth[x]-dpth[y]]];\rif(x==y) return x;\rfor(int i=lg2[dpth[x]];i\u0026gt;=0;i--)\rif(f[x][i]!=f[y][i])\rx=f[x][i],y=f[y][i];\rreturn f[x][0];\r}\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;s);\rint a,b;\rifor(i,1,n-1)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a,\u0026amp;b),add(a,b);\rifor(i,1,n)\r{double k=log(i)/log(2);lg2[i]=k;}\rbuild(s,0);\rifor(i,1,m)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a,\u0026amp;b),printf(\u0026quot;%d\\n\u0026quot;,lca(a,b));\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":7,"section":"posts","summary":"","tags":["LCA"],"title":"最近公共祖先(LCA)","uri":"https://cs-fil.github.io/2020/11/least-common-ancestors/","year":"2020"},{"content":"链接 摘要  给定 $n$ 个元素, 每个元素有 $number$, $color$, $value$ 三个数据 定义三元组$:$ $(x,y,z)$ 满足两个条件\n1. $xyz$ 是整数, $x＜y＜z$, $y$$-$$x$$=$$z$$-$$y$\n2. $color_x$ $=$ $color_z$\n其分数为 $(x$$+$$z)$$×$$($$value_x$$+$$value_y$$)$\n求所有满足条件的三元组的分数的和 $mod$ $10007$\n解  值得学习的思想过程:\n考虑枚举 $x,y,z$, 复杂度 $O($$n^3$$)$超时\n由三元组条件得 $2y$$=$$x$$+$$z$, 枚举复杂度 $O($$n^2$$)$超时\n但是我们得到若 $x,z$ 奇偶性相同且颜色一致, 那么此三元组一定满足条件 于是按照颜色和奇偶性分为 $2*m$ 个组, 答案就是所有组的分数之和\n对于每一个组枚举列式计算化简得:\n$ans$ $=$ $x_1$ * $($$y_1$ * $(k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k$$)$$+$$x_2$ * $($$y_2$ * $($$k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k$$)$$+$$\u0026hellip;$$+$$x_k$ * $($$y_k$ * $($$k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k)$\n预处理 $k,sum$, $O(n)$ 计算 $ans$\n心得  寻找特征, 根据特征步步优化, 有时化成数学问题得到式子\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5,mod=1e4+7;\rint m,n;\rint v[N],c[N],cnt[N][2],sum[N][2];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;v[i]);\rifor(i,1,n)\r{ scanf(\u0026quot;%d\u0026quot;,\u0026amp;c[i]);\rcnt[c[i]][i%2]++,sum[c[i]][i%2]=(sum[c[i]][i%2]+v[i])%mod; }\rint ans=0;\rifor(i,1,n)\rans=(ans+i*(sum[c[i]][i%2]+v[i]*(cnt[c[i]][i%2]-2)%mod)%mod)%mod;\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":8,"section":"posts","summary":"","tags":["数学"],"title":"Luogu P2671 求和","uri":"https://cs-fil.github.io/2020/11/luogu-p2671/","year":"2020"},{"content":"链接 摘要  数轴上 $n$ 个不等高的建筑, 从左看到 $A$ 个, 右看 $B$ 个\n两种方案不同, 即高度排列不同, 求方案数\n 1≤n≤50000, 1≤A,B≤100\n解  对每一个可见的建筑及其挡住的建筑建组\n求方案数即枚举分组方式, 后固定下每组最高建筑, 组内其余全排列\n这恰好是第一类斯特林数\n简单阐述正确性:\n斯特林数包括全部分组方式, 对于不同的分组方式, 其序列一定不同\n后在组中选取一个值固定\n定量分析\n在 $n-1$ 个数中分 $A+B-2$ 组, 由于 $A$ $B$ 等价,选取 $A-1$ 放左即是组合数问题\n最终答案 $s(n-1,A+B-2)$*$C^{A+B-2}_{A-1}$\n技巧  将斯特林数及组合数的递推式可视化为二维数组, 容易考虑初始赋值\ndebug  1.预处理的数组范围要与所求的数组范围一致\n2.递推越界问题(实际可用的范围比所开的数组范围少1, 慎用 $N$)\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int inf=5e4+5,mod=1e9+7;\rint T,n,a,b;\rll c[205][105],s[inf][205];\rinline void prework()\r{\rs[0][0]=s[1][1]=1;\rifor(i,2,inf)\rs[i][1]=s[i-1][1]*(i-1);\rifor(i,0,205) c[i][0]=1;\rifor(i,2,inf)\rfor(int j=2;j\u0026lt;=i\u0026amp;\u0026amp;j\u0026lt;=205;++j)\rs[i][j]=(s[i-1][j-1]+s[i-1][j]*(i-1))%mod;\rifor(i,1,205)\rfor(int j=1;j\u0026lt;=i\u0026amp;\u0026amp;j\u0026lt;=105;++j)\rc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rprework();\rwhile(T--)\r{ scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;a,\u0026amp;b);\rprintf(\u0026quot;%lld\\n\u0026quot;,s[n-1][a+b-2]*c[a+b-2][a-1]%mod); }\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":9,"section":"posts","summary":"","tags":["数学","线性递推"],"title":"Luogu P4609 [FJOI]建筑师","uri":"https://cs-fil.github.io/2020/11/luogu-p4609/","year":"2020"},{"content":"链接 摘要  根据递推式求 $F[n][m]$ $mod$ $1e9$$+$$7$\n数据范围见原题\n解  由递推式, 很容易想到构造使用矩阵乘法\n技巧 1.扩展欧拉定理  $a^b$ $≡$ $a^{b\\ mod\\ φ(n)}$ $(mod$ $n)$ $(a$与$n$互质$)$\n对指数、底数取模, 优化复杂度\n2.十进制快速幂  本题中, 为应对高精度指数(未使用扩展欧拉定理)\ninline node qkpw(node bs,char *p)\r{\rnode res;\rres.a[1][1]=res.a[2][2]=1;\rll l=strlen(p+1);\rfor(ll i=l;i\u0026gt;=1;i--)\r{\rnode t=bs;\rif(p[i]=='9')\r{ t=t*t,t=t*t,t=t*t,t=t*bs;\rres=res*t;}\relse if(p[i]=='8')\r{ t=t*t,t=t*t,t=t*t;\rres=res*t;}\relse\r{ ifor(j,1,p[i]-'0')\r{ res=res*bs;}}\rnode k=bs;\rbs=bs*bs,bs=bs*bs,bs=bs*bs,bs=bs*k,bs=bs*k;\r}\rreturn res;\r}\r 3.卡常 循环展开(未测试) struct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rres.a[1][1]=md(a[1][1]*x.a[1][1]%mod+a[1][2]*x.a[2][1]%mod);\rres.a[1][2]=md(a[1][1]*x.a[1][2]%mod+a[1][2]*x.a[2][2]%mod);\rres.a[2][1]=md(a[2][1]*x.a[1][1]%mod+a[2][2]*x.a[2][1]%mod);\rres.a[2][2]=md(a[2][1]*x.a[1][2]%mod+a[2][2]*x.a[2][2]%mod);\rreturn res;\r}\r}ans,bs1,bs2,bs3;\r 4.卡常 加法取模(未测试)  两个小于 $mod$ 的数相加\ninline ll md(ll x)\r{ return x\u0026gt;=mod?x-mod:x;}\r 5.特判  注意特判 $a$$=$$1$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst ll inf=1e6+5,mod=1e9+7;\rll n,m,a,b,c,d,e;\rchar ns[inf],ms[inf];\rinline ll md(ll x)\r{ return x\u0026gt;=mod?x-mod:x;}\rstruct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rres.a[1][1]=md(a[1][1]*x.a[1][1]%mod+a[1][2]*x.a[2][1]%mod);\rres.a[1][2]=md(a[1][1]*x.a[1][2]%mod+a[1][2]*x.a[2][2]%mod);\rres.a[2][1]=md(a[2][1]*x.a[1][1]%mod+a[2][2]*x.a[2][1]%mod);\rres.a[2][2]=md(a[2][1]*x.a[1][2]%mod+a[2][2]*x.a[2][2]%mod);\rreturn res;\r}\r}ans,bs1,bs2,bs3;\rinline node qkpw(node bs,ll p)\r{\rnode res;\rres.a[1][1]=res.a[2][2]=1;\rwhile(p)\r{\rif(p\u0026amp;1)\r{ res=res*bs;}\rbs=bs*bs,p\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main()\r{\rscanf(\u0026quot;%s%s\u0026quot;,ns+1,ms+1);\rscanf(\u0026quot;%lld%lld%lld%lld\u0026quot;,\u0026amp;a,\u0026amp;b,\u0026amp;c,\u0026amp;d);\rif(a!=1) { e=mod-1;}\relse\r{ e=mod;}\rll ln=strlen(ns+1),lm=strlen(ms+1);\rifor(i,1,ln)\r{ n=(n*10+(ns[i]-'0'))%e;}\rifor(i,1,lm)\r{ m=(m*10+(ms[i]-'0'))%e;}\rans.a[1][1]=1,ans.a[1][2]=1;\rbs1.a[1][1]=a,bs1.a[2][1]=b,bs1.a[2][2]=1;\rbs2.a[1][1]=c,bs2.a[2][1]=d,bs2.a[2][2]=1;\rbs1=qkpw(bs1,m-1);\rbs3=bs1*bs2;\rans=ans*qkpw(bs3,n-1);\rans=ans*bs1;\rprintf(\u0026quot;%lld\u0026quot;,ans.a[1][1]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":10,"section":"posts","summary":"","tags":["矩阵乘法"],"title":"Luogu P1397 [NOI2013]矩阵游戏","uri":"https://cs-fil.github.io/2020/11/luogu-p1397/","year":"2020"},{"content":"链接 摘要  $F_n$ $mod$ $10^9$$+$$7$\n $1\\lt n\\leq$ $2^{63}$\n解  限于数据范围, $O(n)$ 的递推会 $TLE$\n于是化递推为矩阵乘法, 相当于将递推式换为一个乘号\n于是可以使用快速幂求解\n技巧  满足结合律的数学运算都可以使用快速幂\ndebug  注意指数 $long$ $long$ 时, 将快速幂函数的定义区也写为 $long$ $long$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst ll mod=1e9+7;\rll n;\rstruct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rifor(i,1,2)\rifor(j,1,2)\rifor(k,1,2)\rres.a[i][j]=(res.a[i][j]+a[i][k]*x.a[k][j])%mod;\rreturn res;\r}\r}ans,base;\rinline void qkpw(ll p)\r{\rwhile(p)\r{ if(p\u0026amp;1)\r{ ans=ans*base;}\rbase=base*base,p\u0026gt;\u0026gt;=1;\r}\r}\rint main()\r{\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;n);\rif(n\u0026lt;=2)\r{ return puts(\u0026quot;1\u0026quot;),0;}\rbase.a[1][1]=base.a[1][2]=base.a[2][1]=1;\rans.a[1][1]=ans.a[1][2]=1;\rqkpw(n-2);\rprintf(\u0026quot;%lld\u0026quot;,ans.a[1][1]%mod);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":11,"section":"posts","summary":"","tags":["矩阵乘法"],"title":"Luogu P1962 斐波那契数列","uri":"https://cs-fil.github.io/2020/11/luogu-p1962/","year":"2020"},{"content":"链接 摘要  求有多少种 $1$ 到 $n$ 的排列 $a$, 满足序列恰好有 $m$ 个位置 $i$, 使得 $a_i$$=$$i$\n答案对 $10^9$$+$$7$ 取模\n解  首先对题目进行模拟, 枚举满足条件的序列\n先确定下这 $m$ 个位置, 不难发现得到的情况数即为 $C_n^m$\n其次确定其余的位置\n定义 $D[i]$ 为 $i$ 个位置的情况数, 不难得到 $D[1]=0$, $D[2]=1$, $D[3]=2$\n对于 $D[4]$ 首先考虑 $1$ 的位置, 会有位置 $2.3.4$ $3$ 个情况\n进一步考虑除 $1$ 外数字 $2.3.4$ 的位置\n发现 $2$ 放在位置 $1$ 情况时, 其余数字的情况变为 $D[2]$\n若不放在位置 $1$ 则可假想位置 $1$ 为位置 $2$, 情况就变为了 $D[3]$\n于是 大胆推测 $D[i]=(n-1)*(D[i-1]+D[i-2])$\n于是答案即为 $C_n^m$ * $D[i]$\n心得 1.做题方法  线性递推题有两点技巧\n$1)$ 模拟以发现规律\n$2)$ 猜测以得出规律\n2.特判  写完题目还要对特殊情况进行检查, 必要时设置特判\n技巧  对于除法式子取模, 可以先将其转化为被除数与除数的乘法逆元相乘的式子, 再对因数取模\n求乘法逆元用到费马小定理 $a^p$ $≡$ $a$ $(mod$ $p)$ ($p$ 为质数)\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int inf=1e6+5,mod=1e9+7;\rint T,n,m;\rll f[inf],inv[inf],d[inf];\rinline ll qkpw(ll x,int p)\r{\rll ans=1;\rwhile(p)\r{\rif(p\u0026amp;1)\rans=ans*x%mod;\rx=x*x%mod,p\u0026gt;\u0026gt;=1;\r}\rreturn ans;\r}\rinline void prwrk()\r{\rf[0]=1;\rifor(i,1,inf)\rf[i]=f[i-1]*i%mod,inv[i]=qkpw(f[i],mod-2);\rd[1]=0,d[2]=1,d[3]=2;\rifor(i,4,inf)\rd[i]=(i-1)*(d[i-1]+d[i-2])%mod;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rprwrk();\rwhile(T--)\r{ scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rif(n==m) puts(\u0026quot;1\u0026quot;);\relse if(m==0) printf(\u0026quot;%lld\\n\u0026quot;,d[n]);\relse printf(\u0026quot;%lld\\n\u0026quot;,(((f[n]*inv[m])%mod*inv[n-m])%mod)*d[n-m]%mod);}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":12,"section":"posts","summary":"","tags":["线性递推"],"title":"Luogu P4071 [SDOI]排列计数","uri":"https://cs-fil.github.io/2020/11/luogu-p4071/","year":"2020"},{"content":"$n$ 的简化剩余系是 φ(n) 阶 $Abel$ 群  对 $∀$ $a_i$$,$$a_j$, 若 $a$ * $a_i$ $≡$ $a$ * $a_j$ $(mod$ $m)$\n则 $a$ * $($$a_i$ $-$ $a_j$$)$ $≡$ $0$\n即 $a_i$ $≡$ $a_j$\n故当 $a_i$ $≠$ $a_j$时, $a$$a_i$$,$$a$$a_j$ 也表示不同的同余类\n","id":13,"section":"posts","summary":"","tags":["欧拉定理","费马小定理"],"title":"欧拉定理\u0026费马小定理","uri":"https://cs-fil.github.io/2020/11/eulers-theoremfermats-little-theorem/","year":"2020"},{"content":"定义  对一个有向无环图 ( Directed Acyclic Graph 简称 $DAG$ ) $G$ 进行拓扑排序, 是将 $G$ 中所有顶点排成一个线性序列, 使得图中任意一对顶点 $u$ 和 $v$,\n若边 $\u0026lt;$$u$$,$$v$$\u0026gt;$$∈$$E$$(G)$, 则 $u$ 在线性序列中出现在 $v$ 之前.\ncode inline void topsort()\r{\rstd::queue\u0026lt;int\u0026gt;q;\rifor(i,1,n)\rif(!id[i])\rq.push(i),tsrt[++c]=i;\rwhile(!q.empty())\r{\rint u=q.front();q.pop();\rfor(int i=h[u];i;i=nxt[i])\r{\rid[ver[i]]--;\rif(!id[ver[i]])\rq.push(ver[i]),tsrt[++c]=ver[i];\r}\r}\r}\r","id":14,"section":"posts","summary":"","tags":["拓扑排序"],"title":"拓扑排序","uri":"https://cs-fil.github.io/2020/11/topsort/","year":"2020"},{"content":"链接 摘要  $4$ 座汉诺塔\n解  回想 $3$ 座汉诺塔的解法, 对于 $n$ 塔, 先将 $n$$-$$1$ 塔移至 $B$ 座, 后将底塔移至 $C$ 座, 最后将 $n$$-$$1$ 塔移至 $C$ 座. 基于递推的思想.\n$4$ 座汉诺塔类似, 按照 $4$ 座的方式将 $i$ 塔移至 $B$ 座, 因为大塔不可覆盖小塔, 于是对于剩下的 $n$$-$$i$ 塔问题转化为 $3$ 座汉诺塔.\n于是有 $h4[i]=min$ { $h4[j]*2+h3[i-j]|i \\in [2,n],j \\in [1,i)$ } $, h4[1]=1$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint a[13],b[13];\rint main()\r{\rmemset(b,0x3f,sizeof(b));\ra[1]=b[1]=1;\rprintf(\u0026quot;%d\\n\u0026quot;,b[1]);\rifor(i,2,12)\r{\ra[i]=(a[i-1]\u0026lt;\u0026lt;1)+1;\rifor(j,1,i-1)\rb[i]=std::min(b[i],(b[j]\u0026lt;\u0026lt;1)+a[i-j]);\rprintf(\u0026quot;%d\\n\u0026quot;,b[i]);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":15,"section":"posts","summary":"","tags":["递推"],"title":"POJ 1958 Strange Towers of Hanoi","uri":"https://cs-fil.github.io/2020/09/poj-1958/","year":"2020"},{"content":"链接 摘要  给定 $5$ $\\times$ $5$ 的 $01$ 矩阵\n给出一个操作 使 $+$ 型共 $5$ 个数变为其相反的状态\n求使原矩阵归 $1$ 的操作数\n解 1. 怎么做及为什么是对的  通过观察 发现如下三点性质\n$1)$ 每一个数至多进行一次操作 因为两次以上则会自我抵消\n$2)$ 若要求不在第 $n$ 行前再进行操作 则下一行及之后的情况也一并固定只有一种 由于操作的特殊性 若想改变第 $n$ 行第 $i$ 个数且不在本行操作 则只能在下一行的第 $i$ 位操作来改变它\n$3)$ 操作顺序不影响最终结果\n于是只需枚举第一行的操作方式 验证是否可行记录最小值即可\n2. 怎么想到这样做  将无序的操作有序化，是本题的关键。将任意的操作行行分类，结合操作的特殊性，发现本题的突破口，找到其性质。最后将其转化为指数型枚举问题。\ndebug 及技巧  $01$ 矩阵 容易想到用位运算 然而再看操作 发现 $+$ 的横 实现不便(位运算不可移负数位) 于是将其整体向左移一位即可\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint T,a[6],ori[6];\rint mnx=0x7fffffff,k;\rstd::string s;\rinline void wrk(int x)\r{\rifor(i,1,5)\rif(!((a[x-1]\u0026gt;\u0026gt;(5-i+1))\u0026amp;1))\r{\r++k;\ra[x-1]^=(2\u0026lt;\u0026lt;(4-i+1));\ra[x]=(a[x]^(7\u0026lt;\u0026lt;(4-i+1)))\u0026amp;62;\ra[x+1]^=(2\u0026lt;\u0026lt;(4-i+1));\r}\rif(x==5)\r{\rif(a[5]==62)\rmnx=std::min(mnx,k);\rreturn;\r}\rwrk(x+1);\r}\rinline void cnt(int cur)\r{\rif(cur==6)\r{\rint m=k;\rifor(i,1,5) ori[i]=a[i];\rwrk(2);\r/*回归状态*/\rifor(i,1,5) a[i]=ori[i];\rk=m;\rreturn;\r}\r/*点击1行第cur个灯*/\ra[1]=(a[1]^(7\u0026lt;\u0026lt;(4-cur+1)))\u0026amp;62;\ra[2]^=(2\u0026lt;\u0026lt;(4-cur+1));\r++k;\rcnt(cur+1);\ra[1]=(a[1]^(7\u0026lt;\u0026lt;(4-cur+1)))\u0026amp;62;\ra[2]^=(2\u0026lt;\u0026lt;(4-cur+1));\r--k;\rcnt(cur+1);\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rwhile(T--)\r{\rmnx=0x7fffffff,k=0;\rmemset(a,0,sizeof(a));\rifor(i,1,5)\r{\rstd::cin\u0026gt;\u0026gt;s;\rifor(j,1,5)\rif(s[j-1]=='1')\ra[i]|=(1\u0026lt;\u0026lt;(5-j+1));\r}\rcnt(1);\rif(mnx==0x7fffffff||mnx\u0026gt;6)\rputs(\u0026quot;-1\u0026quot;);\relse printf(\u0026quot;%d\\n\u0026quot;,mnx);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":16,"section":"posts","summary":"","tags":["位运算","枚举"],"title":"CH 0201 费解的开关","uri":"https://cs-fil.github.io/2020/09/ch-0201/","year":"2020"},{"content":"链接 摘要  给定 $n$ 个数 求最长下降子序列位数和方案数1\n$1$ $\\leq$ $n$ $\\leq$ $5000$\n解  难点在于如何求方案数\n定义 $f[i]$ 表示以 $arr[i]$ 结尾的最长下降子序列位数\n判断末位大小关系 若可，f[i]=std::max(f[i],f[j]+1)以转移\n重点 定义 $c[i]$ 表示以 $arr[i]$ 结尾的最长下降子序列方案数\n 判重 若两个子序列位数相同且末位相等 那么容易得知构成前一个序列的方案必然可以构成后者 则需清空前者的 $c[]$ 以去重 转移 判断末位大小关系和子序列位数关系 若可，c[i]+=c[j]以转移   $dp$ 过程中存储位数最大值 最后位数符合最大值的子序列的方案数相加即为方案总数\ndebug  memset(arr,1,sizeof(arr))无法达到令 $arr$ 数组每一位为 $1$ 的效果，解决方案是手打循环赋值\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=5e3+9;\rint n,mxn,ans;\rint arr[inf],f[inf],c[inf];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]),f[i]=1;\rifor(i,1,n)\r{\rifor(j,1,i-1)\rif(arr[i]\u0026lt;arr[j])\rf[i]=std::max(f[i],f[j]+1);\rmxn=std::max(mxn,f[i]);\rifor(j,1,i-1)\rif(f[j]==f[i]\u0026amp;\u0026amp;arr[j]==arr[i])\rc[j]=0;\relse if(arr[i]\u0026lt;arr[j]\u0026amp;\u0026amp;f[j]==f[i]-1)\rc[i]+=c[j];\rif(!c[i]) ++c[i];\r}\rifor(i,1,n)\rif(f[i]==mxn)\rans+=c[i];\rprintf(\u0026quot;%d %d\u0026quot;,mxn,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r   若构成的队列相同则认为属于同一个方案 \u0026#x21a9;\u0026#xfe0e;\n  ","id":17,"section":"posts","summary":"","tags":["动态规划","递推"],"title":"Luogu P1108 低价购买","uri":"https://cs-fil.github.io/2020/03/luogu-p1108/","year":"2020"},{"content":"链接 摘要  对于一个整数 $n$ 的正整数次幂，后 $k$ 位是否发生循环\n若是 求循环长度 $k$ $\\leq$ $100$\n解  从尾部递推\n依次保证 后 $1$ 位循环，后 $2$ 位循环……后 $k$ 位循环\n定义fac在保证原数与之相乘 后 $m$ 位不变的前提下，探究保证第 $m+1$ 位不变的条件\n定义fac_maker以计算fac\n若次数 $cnt \u0026gt; 10$ 可判断不循环\n若 $cnt \u0026lt; 10$，将每一位探究的次数相乘可得到循环长度\n值得注意的是 由数据范围知应使用高精度\ndebug  乘法高精度中c[i+j-1]=a[i]*b[j] c[i+j-1]+=a[i]*b[j]  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=1e4+9,times[10]={1,1,4,4,2,1,1,4,4,2};\rint k;\rint ans[102],ori[102],maiN[inf],fac[inf],fac_maker[inf],tmp[inf];\rchar s[102];\rinline void mul_1(int a[],int b[],int c[])\r{\rifor(i,1,k)\rifor(j,1,k)\rc[i+j-1]+=a[i]*b[j],c[i+j]+=c[i+j-1]/10,c[i+j-1]%=10;\r}\rinline void mul_2(int a[],int b,int c[])\r{\rifor(i,1,k)\rc[i]+=a[i]*b,c[i+1]+=c[i]/10,c[i]%=10;\r}\rint main()\r{\rscanf(\u0026quot;%s%d\u0026quot;,s+1,\u0026amp;k);\rint l=strlen(s+1);\rfor(int i=l;i\u0026gt;=l-k+1;--i)\rori[l-i+1]=s[i]-'0';\rifor(i,1,k) maiN[i]=ori[i];\rifor(i,1,times[ori[1]]-1)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,ori,tmp);\rifor(j,1,k)\rmaiN[j]=tmp[j];\r}\rans[1]=times[ori[1]];\rifor(i,1,k)\rfac[i]=fac_maker[i]=maiN[i];\rint cur=1;\rwhile(++cur\u0026lt;k+1)\r{\rifor(i,1,k)\rmaiN[i]=ori[i];\rint cnt=0;\rwhile(cnt\u0026lt;=10)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,fac,tmp);\r++cnt;\rif(tmp[cur]==ori[cur]) break;\rifor(i,1,k)\rmaiN[i]=tmp[i];\rmemset(tmp,0,sizeof(tmp));\rmul_1(fac_maker,fac,tmp);\rifor(i,1,k)\rfac_maker[i]=tmp[i];\r}\rif(cnt\u0026gt;10) return puts(\u0026quot;-1\u0026quot;),0;\rmemset(tmp,0,sizeof(tmp));\rmul_2(ans,cnt,tmp);\rifor(i,1,100) ans[i]=tmp[i];\rifor(i,1,k) fac[i]=fac_maker[i];\r}\rint kk=100;\rwhile(ans[kk]==0\u0026amp;\u0026amp;kk\u0026gt;1) --kk;\rfor(int i=kk;i\u0026gt;=1;--i)\rprintf(\u0026quot;%d\u0026quot;,ans[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":18,"section":"posts","summary":"","tags":["模拟","递推"],"title":"Luogu P1050 循环","uri":"https://cs-fil.github.io/2020/03/luogu-p1050/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的字符串 $S$\n有 $m$ 个操作，保证 $m\\leq n$\n给定字符串 $T$1 初时为空\n共有以下两种操作\n 在字符串 $T$ 的末尾加上一个字符2 在字符串 $T$ 的开头加上一个字符   $n$ $\\leq$ $10^6$，$m$ $\\leq$ $3.3333$ $\\times$ $10^4$，$|\\Sigma|$ $\\leq$ $10^3$，$S_i$ $\\in$ $[1,|\\Sigma|]。$($\\Sigma$ 表示字符集$)$\n 每次操作完成后要求输出有几个 $l\\in [1,T.size]$ 满足对于 $\\forall i\\in [1,l]$ 有 $T_{T.size-l+i}$ $\\neq$ $S_i$\n解 $17$ $pts$  模拟\n时间复杂度 $O(m^3)$\n$50$ $pts$  $f[i]$ 表示当前 $l=i$ 时是否满足条件\n分别考虑两种情况\n$1.$ $op=0$\n操作之后 每一位会得到新的状态\n不难发现 f[i]继承f[i-1]的true状态的条件为ch==T[i]\n则需将 $ch$ 逐位比对更新状态\n$2.$ $op=1$\n操作之后 对于 $f[j]$$,$$j\\in [1,i-1]$ 的状态没有影响\n仅需考虑新增的 $f[i]$\n将字符串 $T$ 与 $S$ 逐位比对方可得出新增状态\n优化\n1. 定义 $l[]$ $r[]$ 分别表示首增和末增\n2. 对于第 $1$ 种情况 可先继承后判断，$coding$ 时会清楚一些\n值得注意的是 应倒序继承避免覆盖\n 时间复杂度 $O(m^2)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,opn,k,kk,res;\rint s[1000002],l[40002],r[40002],f[40002];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;s[i]);\rifor(i,1,m)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;opn,\u0026amp;k);\rif(opn)\r{\rl[++l[0]]=k;\rint flg=1;\rkk=0;\rfor(int j=l[0];j\u0026gt;=1;--j)\rif(l[j]==s[++kk])\r{flg=0; break;}\rifor(j,1,r[0])\rif(r[j]==s[++kk]||!flg)\r{flg=0; break;}\rres+=(f[i]=flg);\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\relse\r{\rr[++r[0]]=k;\rres=0;\rfor(int j=i;j\u0026gt;=2;--j)\rf[j]=f[j-1];\rf[1]=1;\rifor(j,1,i)\rres+=(f[j]\u0026amp;=(k!=s[j]));\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r $100$ $pts$  沿用 $50 pts$ 的思路，使用位运算进行优化\n定义 $01$数组 $id[i]$ 表示字符 $i$ 在字符串 $S$ 中的比对情况\n分别考虑两种情况\n$1.$ $op=0$\nf=f\u0026lt;\u0026lt;1|id[k]即继承状态并考虑 $ch$ 的比对情况\n$2.$ $op=1$\nf|=id[k]\u0026lt;\u0026lt;(i-1)即把比对状态更新至对应的 $l$ 处\n举个例子:\n$213$ 首先读取 $2$ 的比对状态 而归于 $l=3$ 的范畴\n输出时用一个 $01$ 数限制位数，~(f|now)中 $0$ 的个数即为所求\n 使用位运算对未来的状态进行了规划，是一个长远的考虑\n 优化\n引入压位优化的 $01$ 数组 $bitset$\n 时间复杂度 $O(m^2/w)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;bitset\u0026gt;\r#include\u0026lt;cstdlib\u0026gt; #include\u0026lt;cctype\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rconst int inf=1e6+2;\rint n,m,opn,k;\rint it[inf];\rstd::bitset\u0026lt;35000\u0026gt; id[1002],f,now;\rinline int read(){\rint res=0;\rchar ch;\rwhile(isspace(ch=getchar()));\rdo\r{\rres=(res\u0026lt;\u0026lt;1)+(res\u0026lt;\u0026lt;3)+(ch^48);\r}while(isdigit(ch=getchar()));\rreturn res;\r}\rint main()\r{\rn=read(),m=read();\rifor(i,1,n)\rit[i]=read();\rifor(i,1,m)\rid[it[i]].set(i);\rnow.set();\rifor(i,1,m)\r{\ropn=read(),k=read();\rnow.reset(i);\rif(!opn)\rf=f\u0026lt;\u0026lt;1|id[k];\relse f|=id[k]\u0026lt;\u0026lt;(i-1);\rprintf(\u0026quot;%d\\n\u0026quot;,(~(f|now)).count());\r}\rreturn 0;\r}\r   字符串下标从 $1$ 开始 \u0026#x21a9;\u0026#xfe0e;\n 此处字符可能不止一位 \u0026#x21a9;\u0026#xfe0e;\n  ","id":19,"section":"posts","summary":"","tags":["位运算"],"title":"Luogu P5640 【CSGRound2】逐梦者的初心","uri":"https://cs-fil.github.io/2020/03/luogu-p5640/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i$ \u0026amp; $b[i-1]$$\\neq$$0$，其中 $2$ $\\leq$ $i$ $\\leq$ $k$\n$1$ $\\leq$ $n$ $\\leq$ $100000$，$a_i$ $\\leq$ $10^9$\n解  定义 $f[i]$ 表示当前最后一项的第 $i$ 位为 $1$ 的最大子序列长度\n当 $a$ \u0026amp; $b$$\\neq$$0$，即 $ab$ 有相同的一位为 $1$，根据此性质进行转移\n在读入的过程中进行处理\n 若该数第 $i$ 位为 $1$，由于所定义的 $dp$ 数组的性质，转移时即为f[i]+1 取其中的最大值，再对其余数组进行更新，即 $k=max${$f[i]+1$} f[i]=k保证各个数组符合其性质  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,mxn;\rint f[30];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint t;\rwhile(n--)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rint k=1;\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rk=std::max(f[i]+1,k);\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rf[i]=k;\rmxn=std::max(mxn,k);\r}\rprintf(\u0026quot;%d\u0026quot;,mxn);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":20,"section":"posts","summary":"","tags":["位运算","动态规划"],"title":"Luogu P4310 绝世好题","uri":"https://cs-fil.github.io/2020/03/luogu-p4310/","year":"2020"},{"content":"链接 摘要  求数值 $k$$\\in$$[1,m]$ 经过 $n$ 次 $op$ $t$ 操作后的最大值\n $2\\leq n\\leq10^5$ $2\\leq m\\leq10^9$ $0\\leq t\\leq10^9$ $op$ 一定为 $or$ $xor$ $and$ 中的一种\n解  定义k1=0x7fffffff k2=0\n从二进制来看 $k1$ 每一位都是 $1$,$k2$ 每一位都是 $0$\n输入的过程中直接对 $k1$ $k2$ 进行操作\n对于第 $i$ 位 遵循贪心原则 $:$\n 若k2==1则ans+=1\u0026lt;\u0026lt;i 初始值的第 $i$ 位为 $0$ 或若k1==1则需考虑若初始值的第 $i$ 位为 $1$ 是否超出初始值范围 若否再而累加  debug  ans累加ans|=1\u0026lt;\u0026lt;i ans+=1\u0026lt;\u0026lt;i\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,t,ans,k1=0x7fffffff,k2=0;\rchar str[3];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\r{\rscanf(\u0026quot;%s%d\u0026quot;,str,\u0026amp;t);\rif(str[0]=='O') k1|=t,k2|=t;\rif(str[0]=='X') k1^=t,k2^=t;\rif(str[0]=='A') k1\u0026amp;=t,k2\u0026amp;=t;\r}\rfor(int i=29;~i;--i)\r{\rif(k2\u0026gt;\u0026gt;i\u0026amp;1) ans+=1\u0026lt;\u0026lt;i;\relse if(k1\u0026gt;\u0026gt;i\u0026amp;1\u0026amp;\u0026amp;m\u0026gt;=1\u0026lt;\u0026lt;i)\rans+=1\u0026lt;\u0026lt;i,m-=1\u0026lt;\u0026lt;i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":21,"section":"posts","summary":"","tags":["位运算","贪心"],"title":"Luogu P2114 [NOI2014]起床困难综合症","uri":"https://cs-fil.github.io/2020/03/luogu-p2114/","year":"2020"},{"content":"链接 摘要  $n$ 皇后问题\n $0\\lt n\\leq14$\n解  据数据范围 直接搜索会 $tle$\n使用位运算可以达到优化的目的\nmxstt即为列放置最终状态\n 构造函数dfs(cstt,l,r,ln)\n递归边界cstt==mxstt\n k=~(cstt|l|r|ln)\u0026amp;mxstt以获取改行状态\nlowbit(k)以列举可放置列 cstt表示列放置状态 $0$ 可放置 $1$ 不可放置\ncstt|lowbit(k) 以转移 l r分别表示左斜 右斜的状态 $01$ 义同上\n(l|lowbit(k))\u0026gt;\u0026gt;1 (r|lowbit(k))\u0026lt;\u0026lt;1以转移 ln表示当前行数\nln+1以转移   即dfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1)\ndebug  设置一个 $n$ 位二进制数的第 $k$ 位为 $1$ x|=k x|=1\u0026lt;\u0026lt;n-k l r的转移 (l|cstt)\u0026gt;\u0026gt;1 (l|lowbit(k))\u0026gt;\u0026gt;1 尤其注意用maxstate限制二进制位数  $Q$$\u0026amp;$$A$  $Q:$ 为什么不可以用单个状态stt 而是使用 $4$ 个变量推导状态 $？$\n$A:$ 因为左斜 右斜的转移方式与列放置状态的转移方式不同 $。$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint n,ans,mxstt;\rint stt[20];\rchar s[15];\rinline int lowbit(int x)\r{\rreturn x\u0026amp;-x;\r}\rinline void dfs(int cstt,int l,int r,int ln)\r{\rif(cstt==mxstt) {ans++; return;}\rint k=~(cstt|l|r|stt[ln])\u0026amp;mxstt;\rwhile(lowbit(k))\r{\rdfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1);\rk^=lowbit(k);\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rmxstt=(1\u0026lt;\u0026lt;n)-1;\rifor(i,1,n)\r{\rscanf(\u0026quot;%s\u0026quot;,s+1);\rifor(j,1,n)\rif(s[j]=='.')\rstt[i]|=(1\u0026lt;\u0026lt;n-j);\r}\rdfs(0,0,0,1);\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":22,"section":"posts","summary":"","tags":["位运算","搜索"],"title":"Luogu P1562 还是N皇后","uri":"https://cs-fil.github.io/2020/03/luogu-p1562/","year":"2020"},{"content":" $blog$ 建于 $2020.1.30$\n$aim:$ 每日 $4$ $AC$ 至 $2020$ $10$ 月下旬达成 $1000$ $AC\n","id":23,"section":"posts","summary":"","tags":["随笔"],"title":"2020 目标","uri":"https://cs-fil.github.io/2020/01/blog/","year":"2020"}],"tags":[{"title":"LCA","uri":"https://cs-fil.github.io/tags/lca/"},{"title":"二分","uri":"https://cs-fil.github.io/tags/%E4%BA%8C%E5%88%86/"},{"title":"位运算","uri":"https://cs-fil.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"动态规划","uri":"https://cs-fil.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"单调队列","uri":"https://cs-fil.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"title":"差分","uri":"https://cs-fil.github.io/tags/%E5%B7%AE%E5%88%86/"},{"title":"拓扑排序","uri":"https://cs-fil.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"搜索","uri":"https://cs-fil.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"title":"数学","uri":"https://cs-fil.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"title":"枚举","uri":"https://cs-fil.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"title":"模拟","uri":"https://cs-fil.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"title":"欧拉定理","uri":"https://cs-fil.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"title":"矩阵乘法","uri":"https://cs-fil.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"title":"离散化","uri":"https://cs-fil.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"title":"线性递推","uri":"https://cs-fil.github.io/tags/%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"},{"title":"贪心","uri":"https://cs-fil.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"title":"费马小定理","uri":"https://cs-fil.github.io/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"title":"递推","uri":"https://cs-fil.github.io/tags/%E9%80%92%E6%8E%A8/"},{"title":"随笔","uri":"https://cs-fil.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}