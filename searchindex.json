{"categories":[{"title":"thoughts","uri":"https://cs-fil.github.io/categories/thoughts/"},{"title":"文","uri":"https://cs-fil.github.io/categories/%E6%96%87/"},{"title":"知识点","uri":"https://cs-fil.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"题解","uri":"https://cs-fil.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"posts":[{"content":"链接 摘要  见链接\n解  小根堆以时间为第一关键字(优先队列以第一关键字排序), 为每一次输入时结束在此之前的进程; 第二关键字内存起始位置用于映射链表 用了set作为链表, 以位置为关键字排序, 类似链表的空间结构; 而其查找、删除、插入的复杂度都较低. 第二关键字为长度, 相当于确定了始末位置 依次读入, 首先判断在这个部件插入的时间时之前部件的运行(退出)情况(同时记录末位退出时间, 由于是单调递增的, 实际上只取了最后一次的退出时间), 队列补位情况 其次试插入该部件, 若否加入等候队列, 并记录个数 ·尤其记得在所有部件插入之后, 得出所有部件结束后(时刻2e9)的数据\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;set\u0026gt;\r#include\u0026lt;utility\u0026gt;\r#include\u0026lt;queue\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\r#define pii std::pair\u0026lt;int,int\u0026gt;\rint n,t,m,p,latest,cnt;\rstd::queue\u0026lt;pii\u0026gt;wait;\rstd::set\u0026lt;pii\u0026gt;runs;\rstd::priority_queue\u0026lt;pii,std::vector\u0026lt;pii\u0026gt;,std::greater\u0026lt;pii\u0026gt; \u0026gt;endt;\rinline bool operate(int t,int m,int p)\r{\rfor(std::set\u0026lt;pii\u0026gt;::iterator it=runs.begin();it!=runs.end();++it)\r{\rstd::set\u0026lt;pii\u0026gt;::iterator jt=it;jt++;\rif(jt==runs.end()) break;\rif(m\u0026lt;=jt-\u0026gt;first-(it-\u0026gt;first+it-\u0026gt;second-1)-1)\r{\rruns.insert({it-\u0026gt;first+it-\u0026gt;second,m});\rendt.push({t+p,it-\u0026gt;first+it-\u0026gt;second});\rreturn true;\r}\r}\rreturn false;\r}\rinline void finish(int t)\r{\rwhile(!endt.empty()\u0026amp;\u0026amp;endt.top().first\u0026lt;=t)\r{\rint f=endt.top().first;\rwhile(!endt.empty()\u0026amp;\u0026amp;endt.top().first==f)\r{\rpii p=endt.top();endt.pop();\rstd::set\u0026lt;pii\u0026gt;::iterator it=runs.lower_bound({p.second,0});\rruns.erase(it);\r}\rlatest=f;\rwhile(!wait.empty())\r{\rpii q=wait.front();\rif(operate(f,q.first,q.second))\rwait.pop();\relse break;\r}\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rruns.insert({-1,1}),runs.insert({n,1});\rwhile(scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;t,\u0026amp;m,\u0026amp;p)\u0026amp;\u0026amp;(t||m||p))\r{\rfinish(t);\rif(!operate(t,m,p))\rwait.push({m,p}),++cnt;\r}\rfinish(2e9);\rprintf(\u0026quot;%d\\n%d\u0026quot;,latest,cnt);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":0,"section":"posts","summary":"","tags":["链表","二叉堆","STL"],"title":"Luogu P5763 内存分配","uri":"https://cs-fil.github.io/2021/02/luogu-p5763/","year":"2021"},{"content":"链接 摘要  求合法最大矩形\n解  悬线法 维护每个点所能及的最左, 最右点 依次枚举右下角, 若上一行可取, 则取与上一行同位最左较右点, 最右较左点, 且高度 $++$ 左右位置之差与高度的乘积即为所求  单调栈 逐行计算 将高度入栈, 满足栈内单调递增 若当前高度低于栈顶高度, 则退栈直至栈顶小于(等于其实也可以)当前高度 退栈时累加宽度, 由于高度递增, 栈的较顶部的宽度可以累加到较底部 退完之后, 将累加的宽度及高度入栈 循环时多一位, 循环结束时恰好使栈内元素退完 值得注意的是, 高度和宽度都可以只用一维数组, 不同行高度继承即可, 若该点不合法则清空即可  debug  单调栈做法需要清空高度数组, 因为继承的存在, 每一次并不是赋予新值\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e3+5;\rint T,n,m,ans,ms[N],h[N],wdth[N];\rchar ch;\rbool a[N][N];\rinline void calc(int x)\r{\rifor(i,1,m)\rif(a[x][i]) h[i]++;\relse h[i]=0;\rifor(i,1,m+1)\r{\rif(h[i]\u0026gt;ms[ms[0]])\rms[++ms[0]]=h[i],wdth[ms[0]]=1;\relse\r{\rint w=0;\rwhile(ms[0]\u0026amp;\u0026amp;h[i]\u0026lt;=ms[ms[0]])\rw+=wdth[ms[0]],\rans=std::max(ans,w*ms[ms[0]--]);\rms[++ms[0]]=h[i],wdth[ms[0]]=w+1;\r}\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rwhile(T--)\r{\rans=0,ms[0]=0;\rmemset(h,0,sizeof(h));\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rifor(j,1,m)\r{\rstd::cin\u0026gt;\u0026gt;ch;\ra[i][j]=ch=='F'?true:false;\r}\rifor(i,1,n) calc(i);\rprintf(\u0026quot;%d\\n\u0026quot;,ans*3);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":1,"section":"posts","summary":"","tags":["栈"],"title":"POJ 1964 City Game","uri":"https://cs-fil.github.io/2021/02/poj-1964/","year":"2021"},{"content":"链接 摘要  求给定序列的最长美观括号序列长度\n解  对于美观括号序列, 括号一定是两两配对的 我们只需在栈中维护下标, 若与最近反括号配对成功则反括号退栈, 反之将其入栈 最后当前下标与栈顶下标之差即为该美观括号序列长度 只与栈顶配对, 若失败则直接归零 配对成功才退栈, 栈中剩余的反括号无影响\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5;\rint s[N],c;\rchar a[N];\rint main()\r{\rscanf(\u0026quot;%s\u0026quot;,a+1);\rint l=strlen(a+1);\rint ans=;\rifor(i,1,l)\r{\rif(c\u0026amp;\u0026amp;(a[i]==')'\u0026amp;\u0026amp;a[s[c]]=='(')\r||(a[i]==']'\u0026amp;\u0026amp;a[s[c]]=='[')||(a[i]=='}'\u0026amp;\u0026amp;a[s[c]]=='{'))\r--c;\relse s[++c]=i;\rans=std::max(ans,i-s[c]);\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":2,"section":"posts","summary":"","tags":["栈"],"title":"CH 1801 括号画家","uri":"https://cs-fil.github.io/2021/02/ch-1801/","year":"2021"},{"content":"链接 摘要  求中缀表达式的计算值\n解  先转为后缀表达式后计算 转换过程如下: 两个栈, 一个作暂存容器, 一个作结果存储 数字直接入结果栈, 小技巧:在数字结束后加 $#$, 方便之后将字符转化为数字 符号入暂存栈, 入前需要考虑优先级, 优先级在事先设置为函数或数组, 若栈中优先级更大, 则先弹出后入栈, 这样就能保证暂存栈中优先级单调递增, 之后弹出至结果栈时顺序颠倒, 即成为后缀表达式的运算顺序 左括号直接入栈 若为右括号, 将左括号至上的所有符号连同左括号弹出 后缀表达式的计算: 取数并得出数字, 遇到符号取两次堆顶计算再入堆, 最终堆顶即为结果\ndebug  1.判数字是 \u0026amp;\u0026amp; 而非 || 2.判优先级时注意暂存栈是否已空\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=6e1+5;\rchar a[N],s1[N],s2[N];\rint s3[N],c1,c2,c3;\rinline int level(char x)\r{\rif(x=='*'||x=='/')\rreturn 2;\relse if(x=='+'||x=='-')\rreturn 1;\relse if(x=='^')\rreturn 3;\rreturn 0;\r}\rinline int quickpow(int x,int p)\r{\rint res=1;\rwhile(p)\r{\rif(p\u0026amp;1)\rres*=x;\rx*=x,p\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main()\r{\rscanf(\u0026quot;%s\u0026quot;,a+1);\rint l=strlen(a+1);\rifor(i,1,l)\r{\rif(a[i]\u0026lt;='9'\u0026amp;\u0026amp;a[i]\u0026gt;='0')\r{s2[++c2]=a[i];continue;}\rif(a[i-1]\u0026lt;='9'\u0026amp;\u0026amp;a[i-1]\u0026gt;='0')\rs2[++c2]='#';\rif(a[i]=='(')\rs1[++c1]=a[i];\relse if(a[i]==')')\r{\rwhile(s1[c1]!='(')\rs2[++c2]=s1[c1--];\rc1--;\r}\relse {\rwhile(level(a[i])\u0026lt;=level(s1[c1])\u0026amp;\u0026amp;c1)\rs2[++c2]=s1[c1--];\rs1[++c1]=a[i];\r}\r}\rif(a[l]\u0026lt;='9'\u0026amp;\u0026amp;a[l]\u0026gt;='0')\rs2[++c2]='#';\rwhile(c1)\rs2[++c2]=s1[c1--];\rint tmp=0;\rifor(i,1,c2)\r{\rif(s2[i]\u0026gt;='0'\u0026amp;\u0026amp;s2[i]\u0026lt;='9')\r{\rtmp=(tmp\u0026lt;\u0026lt;1)+(tmp\u0026lt;\u0026lt;3)+(s2[i]^48);\rcontinue;\r}\rif(s2[i]=='#')\rs3[++c3]=tmp,tmp=0;\relse\r{\rc3--;\rif(s2[i]=='+')\rs3[c3]+=s3[c3+1];\relse if(s2[i]=='-')\rs3[c3]-=s3[c3+1];\relse if(s2[i]=='*')\rs3[c3]*=s3[c3+1];\relse if(s2[i]=='/')\rs3[c3]/=s3[c3+1];\relse if(s2[i]=='^')\rs3[c3]=quickpow(s3[c3],s3[c3+1]);\relse ++c3;\r}\r}\rprintf(\u0026quot;%d\u0026quot;,s3[c3]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":3,"section":"posts","summary":"","tags":["栈"],"title":"CH 1802 表达式计算4","uri":"https://cs-fil.github.io/2021/02/ch-1802/","year":"2021"},{"content":"链接 摘要  Huffman模板\n解  Huffman依托于树但是不需要建树, 仅需维护深度即可\n该题只需不断满足在权值最小的情况下深度最小即可\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int N=1e5+5;\rint n,k,cnt;\rstruct node\r{\rll val;\rint dpth;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{\rif(val==x.val)\rreturn dpth\u0026lt;x.dpth;\rreturn val\u0026lt;x.val;\r}\r}heap[N];\rinline void up(int x)\r{\rwhile(x!=1)\r{\rif(heap[x]\u0026lt;heap[x/2])\rstd::swap(heap[x],heap[x/2]),\rx/=2;\relse break;\r}\r}\rinline void down(int x)\r{\rint s=x*2;\rwhile(s\u0026lt;=cnt)\r{\rif(s\u0026lt;cnt\u0026amp;\u0026amp;heap[s+1]\u0026lt;heap[s]) ++s;\rif(heap[s]\u0026lt;heap[x])\rstd::swap(heap[s],heap[x]),\rx=s,s=x*2;\relse break;\r}\r}\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;k);\rifor(i,1,n)\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;heap[++cnt].val),\rheap[cnt].dpth=0,up(cnt);\rwhile((n-1)%(k-1))\r++n,\rheap[++cnt].val=0,heap[cnt].dpth=0,up(cnt);\rll ans=0;\rwhile(n\u0026gt;1)\r{\rll tmp=0;\rint mxn=0;\rifor(i,1,k)\r{\rnode t=heap[1];\rheap[1]=heap[cnt--],down(1);\rtmp+=t.val;\rmxn=std::max(mxn,t.dpth);\r}\rans+=tmp;\rnode e;\re.val=tmp,e.dpth=mxn+1;\rheap[++cnt]=e,up(cnt);\rn-=(k-1);\r}\rprintf(\u0026quot;%lld\\n%d\u0026quot;,ans,heap[1].dpth);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":4,"section":"posts","summary":"","tags":["Huffman","二叉堆"],"title":"Luogu P2168 荷马史诗","uri":"https://cs-fil.github.io/2021/02/luogu-p2168/","year":"2021"},{"content":"链接 摘要  从 $n$ 个数中选出 $k$ 个不相邻的数且其和最小\n解  首先对于 $k=1$, 显然选取最小值\n对于 $k=2$, 要么选取最小值和不相邻的次小值, 要么同时选取左右两个数\n假设选取最小值左边的数且不选取右边的数:\n1.最小值次小值在左, 相比之下它的次小值大于之前的次小值, 而它本身大于最小值, 该情况肯定不优\n2.选取其他的数时一定可以将其替换为最小值\n为了表示出这样的算法, 先将所有数插入小根堆, 堆顶即为最小值. 另建一个链表以查找前驱后继\n将堆顶连同前驱后继从堆, 链表中一并删除, 并在原位置插入元素, 其值为 $val_{min_{prv}}+val_{min_{nxt}}-val_{min}$\n那么若堆顶是该元素, 则相当于选择了左右两个数; 若不是, 则堆顶为最小值的非相邻次小值, 相当于选择了最小值\n由此, 对于第二次的操作, 第一次选择最小值对全局是无影响的, 事实也是如此; 而选择左右是会有影响的, 在第二层中会综合考虑两种情况, 所以可以这样递推, 可以实现用未来指导过去\n要实现从堆中删除元素, 其实可以换一个思路, 用 $vis$ 数组判断编号是否删除即可\n·尤其是连带删除后替换, 很妙的做法, 很好地适应了计算机的机制, 高效地实现了预期\ndebug  对于链表的删除, 切记在删除时会对前后关系有影响, 一步一步重新考虑前后关系\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int N=1e5+5;\rint n,k,prv[N],nxt[N],cnt;\rll a[N];\rbool vis[N];\rstruct node\r{\rll val;\rint p;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return val\u0026lt;x.val;}\r}heap[N];\rinline void up(int x)\r{\rwhile(x!=1)\r{\rif(heap[x]\u0026lt;heap[x/2])\rstd::swap(heap[x],heap[x/2]),\rx/=2;\relse break;\r}\r}\rinline void down(int x)\r{\rint s=x*2;\rwhile(s\u0026lt;=cnt)\r{\rif(s\u0026lt;cnt\u0026amp;\u0026amp;heap[s+1]\u0026lt;heap[s]) ++s;\rif(heap[s]\u0026lt;heap[x])\rstd::swap(heap[s],heap[x]),\rx=s,s=x*2;\relse break;\r}\r}\rint main()\r{\rll last;\rscanf(\u0026quot;%d%d%lld\u0026quot;,\u0026amp;n,\u0026amp;k,\u0026amp;last);\rll x;\rifor(i,1,n-1)\r{\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;x);\ra[i]=x-last;\rlast=x;\rheap[++cnt].val=a[i],heap[cnt].p=cnt,\rup(cnt);\rprv[cnt]=i-1,nxt[cnt]=i+1;\r}\rll ans=0;\ra[0]=a[n]=0x3f3f3f3f;\rifor(i,1,k)\r{\rnode t;\rdo\r{\rt=heap[1];\rheap[1]=heap[cnt--],down(1);\r}while(vis[t.p]);\rans+=t.val;\rnode e;\re.p=t.p,e.val=a[e.p]=a[prv[t.p]]+a[nxt[t.p]]-t.val;\rheap[++cnt]=e,up(cnt);\rvis[prv[t.p]]=vis[nxt[t.p]]=true;\rprv[e.p]=prv[prv[t.p]],nxt[prv[t.p]]=e.p;\rnxt[e.p]=nxt[nxt[t.p]],prv[nxt[t.p]]=e.p;\r}\rprintf(\u0026quot;%lld\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":5,"section":"posts","summary":"","tags":["二叉堆"],"title":"Luogu P3620 [APIO/CTSC 2007]数据备份","uri":"https://cs-fil.github.io/2021/02/luogu-p3620/","year":"2021"},{"content":"链接 [数据范围对应复杂度]https://www.acwing.com/blog/content/32/ 摘要  合并果子 $n\u0026lt;=1e7$ $a_i$$\u0026lt;=1e5$\n解  记录这道题的原因是有时候需要看数据范围做题 本题需要排序, 且发现合并后的数一定小于之后合并的数 所以用普通的队列就是单调递增的结果 本题 $n$ 范围太大, $nlogn$ 的堆做不了, 但是果子数只有 $1e5$ 低空间可以用高空间低时间的桶排 之后每次选取原队列和合并队列中最小的两个合并并累加即可\ndebug  1.注意中间变量的数据范围 2.判较小时还要判队列是否为空\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cctype\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int N=1e7+5;\rint n,bk[N],l1=1,l2=1,r1=0,r2=0;\rll q1[N],q2[N];\rinline ll read()\r{\rint res=0;\rchar ch;\rwhile(isspace(ch=getchar()));\rdo\r{\rres=(res\u0026lt;\u0026lt;1)+(res\u0026lt;\u0026lt;3)+(ch^48);\r}while(isdigit(ch=getchar()));\rreturn res;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rll x;\rifor(i,1,n)\rx=read(),bk[x]++;\rifor(i,1,100000)\rwhile(bk[i])\rq1[++r1]=i,bk[i]--;\rll ans=0;\rifor(i,1,n-1)\r{\rll a,b;\rif((q1[l1]\u0026lt;q2[l2]\u0026amp;\u0026amp;l1\u0026lt;=r1)||r2\u0026lt;l2)\ra=q1[l1++];\relse a=q2[l2++];\rif((q1[l1]\u0026lt;q2[l2]\u0026amp;\u0026amp;l1\u0026lt;=r1)||r2\u0026lt;l2)\rb=q1[l1++];\relse b=q2[l2++];\rans+=(q2[++r2]=a+b);\r}\rprintf(\u0026quot;%lld\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":6,"section":"posts","summary":"","tags":["排序","优先队列"],"title":"Luogu P6033 合并果子 加强版","uri":"https://cs-fil.github.io/2021/02/luogu-p6033/","year":"2021"},{"content":"链接 摘要  给定 $m$ 个长度为 $n$ 的序列, 从每个序列中各取一个数得到 $n^m$ 种序列\n求其中前 $n$ 小的序列和\n解  先从两个序列开始思考(对于很多题目, 从小情况着手后递推是很重要的思路)\n先对两个序列进行排序, 显然最小的即为 $a[1]+b[1]$\n次小的即可能为 $a[1+1]+b[1]$ 或 $a[1]+b[1+1]$\n那么我们可建一个小根堆, 先将 (1,1) 插入, 取出后插入以上两种情况\n但是如此会有重复的插入\n为了保证每一个数对只至多进一次: 对于每一个 $a[1]$ 对应插入 $b[1~n]$\n插入三元组 $(i,j,last)$\n当右指针移动时, 即锁定 $a[i]$, 不可移动 $i$, 只可移动 $j$, 对应插入 $b[1~n]$: 设置 $last$ 为 true, 之后每次判定先检查 $last$, 若真不动左指针\n为了兼顾 $a[1~n]$, 左指针移动时即可枚举 $b[1~n]$, 也可移步下一个 $a[i]$\n如此便可以不重不漏\n原问题即相当于做 $m-1$ 次该操作\ndebug  重置 $cnt$ 要放在每一次匹配新序列之前, 而非多组数据前\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=2e3+5;\rint T,n,m,a[N],b[N],c[N];\rint cnt;\rstruct node\r{\rint i,j;\rbool last;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return a[i]+b[j]\u0026lt;a[x.i]+b[x.j];}\r}heap[N*2];\rinline void up(int x)\r{\rwhile(x!=1)\r{\rif(heap[x]\u0026lt;heap[x/2])\rstd::swap(heap[x],heap[x/2]),\rx/=2;\relse break;\r}\r}\rinline void down(int x)\r{\rint s=x*2;\rwhile(s\u0026lt;=cnt)\r{\rif(s\u0026lt;cnt\u0026amp;\u0026amp;heap[s+1]\u0026lt;heap[s]) ++s;\rif(heap[s]\u0026lt;heap[x])\rstd::swap(heap[s],heap[x]),\rx=s,s=x*2;\relse break;\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rwhile(T--)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;m,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\rstd::sort(a+1,a+n+1);\rifor(i,2,m)\r{\rcnt=0;\rifor(j,1,n) scanf(\u0026quot;%d\u0026quot;,\u0026amp;b[j]);\rstd::sort(b+1,b+n+1);\rnode t;\rt.i=1,t.j=1,t.last=false;\rheap[++cnt]=t,up(cnt);\rifor(j,1,n)\r{\rnode p=heap[1];\rheap[1]=heap[cnt--],down(1);\rc[j]=a[p.i]+b[p.j];\rnode e1;\re1.i=p.i,e1.j=p.j+1,e1.last=true;\rheap[++cnt]=e1,up(cnt);\rif(!p.last)\r{\rnode e2;\re2.i=p.i+1,e2.j=p.j,e2.last=false;\rheap[++cnt]=e2,up(cnt);\r}\r}\rifor(j,1,n)\ra[j]=c[j];\r}\rifor(i,1,n)\rprintf(\u0026quot;%d \u0026quot;,a[i]);\rputs(\u0026quot;\u0026quot;);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":7,"section":"posts","summary":"","tags":["二叉堆"],"title":"POJ 2442 Sequence","uri":"https://cs-fil.github.io/2021/02/poj-2442/","year":"2021"},{"content":"链接 摘要  给定 $n$ 个商品, 各有利润 $val$ 及过期日期 $time$\n求最大利润\n解  利用小根堆\n先对商品依照过期日期排序, 因为日期短的不可以插在长的前面\n若过期时间大于堆内元素个数, 直接入堆+up\n若过期时间等于(由于已经排序不会出现小于)堆内元素个数, 替换堆顶(由于是小根堆所以堆顶即为过期时间内利润最小的商品)+down\n最后堆内元素之和即为所求\ndebug  1.$down$ 函数记得在判长子是否越界后判次子是否越界, 取较大(小)值后与父节点作比\n2.交换位置后更新要到位(注意比如更新子节点)\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e4+5;\rint n,cnt,heap[N];\rstruct node\r{\rint val,t;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return t\u0026lt;x.t;}\r}a[N];\rinline void up(int x)\r{\rwhile(x!=1)\r{\rif(heap[x/2]\u0026gt;heap[x])\rstd::swap(heap[x/2],heap[x]),\rx/=2;\relse break;\r}\r}\rinline void down(int x)\r{\rint s=x*2;\rwhile(s\u0026lt;=cnt)\r{\rif(s\u0026lt;cnt\u0026amp;\u0026amp;heap[s]\u0026gt;heap[s+1]) s++;\rif(heap[s]\u0026lt;heap[x])\rstd::swap(heap[x],heap[s]),\rx=s,s=x*2;\relse break;\r}\r}\rint main()\r{\rwhile(scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)!=EOF)\r{\rcnt=0;\rifor(i,1,n)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a[i].val,\u0026amp;a[i].t);\rstd::sort(a+1,a+n+1);\rifor(i,1,n)\r{\rif(a[i].t\u0026gt;cnt)\rheap[++cnt]=a[i].val,up(cnt);\relse if(a[i].val\u0026gt;heap[1])\rheap[1]=a[i].val,down(1);\r}\rint ans=0;\rifor(i,1,cnt)\rans+=heap[i];\rprintf(\u0026quot;%d\\n\u0026quot;,ans);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":8,"section":"posts","summary":"","tags":["二叉堆"],"title":"POJ 1456 Supermarket","uri":"https://cs-fil.github.io/2021/02/poj-1456/","year":"2021"},{"content":"链接 摘要  求给定字符串从任意处断开形成的字典序最小的字符串\n解  给两个指针, 初始化 i=1,j=2, 以之为起点朴素往后推 发现若在某一个结点出现大小差异, 根据同构串的形成方式, 对于这一段为起点的同构串, 一定可以构造小于其的串, 于是直接跳过即可 直至其中一个指针超过 $n$, 即代表小于 $n$ 的串已经小过了所有的串(列大小关系式可推)\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=3e5+5;\rint n,a[N*2];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]),a[i+n]=a[i];\rint i=1,j=2,k;\rwhile(i\u0026lt;=n\u0026amp;\u0026amp;j\u0026lt;=n)\r{\rk=0;\rwhile(k\u0026lt;n\u0026amp;\u0026amp;a[i+k]==a[j+k])\rk++;\rif(k==n) break;\rif(a[i+k]\u0026lt;a[j+k])\r{\rj=j+k+1;\rif(i==j)\rj++;\r}\relse\r{\ri=i+k+1;\rif(i==j)\ri++;\r}\r}\rfor(int m=std::min(i,j);m\u0026lt;=std::min(i,j)+n-1;++m)\rprintf(\u0026quot;%d \u0026quot;,a[m]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":9,"section":"posts","summary":"","tags":["字符串"],"title":"P1368 【模板】 最小表示法","uri":"https://cs-fil.github.io/2021/01/luogu-p1368/","year":"2021"},{"content":"动图 处理next数组是为了在匹配失败后搭建下一步的匹配路线\n匹配是一个连续的过程，匹配该位（小串）时，之前的部分正处于“匹配完成”的队列中，所以可以获取下一步\n","id":10,"section":"posts","summary":"","tags":["KMP"],"title":"KMP","uri":"https://cs-fil.github.io/2021/01/kmp/","year":"2021"},{"content":"链接 摘要  求给定字符串的最大循环次数\n解  先预处理 $next$\n以 $i$ 作结的子串的最小循环元长度为:$i-next[i]$\n列一个式子,i=8,s[3-8]对应s[1-6]\ns[1-2]=s[3-4]=s[5-6]=s[7-8]\n只需判断是否可以整除即可\n取末尾的 $next$ 是为了保证循环的可控范围可以覆盖整个子串\n若求次小循环元 再进行一次 $next$, 相当于在上一次的 $next$ 范围内再取一次 $next$\n由于原来的错位部分就是循环元, 再取一次 $next$ 相当于去了第一个循环元后再取循环元, 则现在求出来的循环元就是上一次的循环元加上这个小范围的循环元, 所以任何循环元一定是最小循环元的倍数\ndebug  $KMP$ 算法中自求 $next$ 用的是 $while$, 因为失败后需要不断配对直至可以延伸 或者 $j$ 变为 $0$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e6+5;\rint n,next[N];\rchar a[N];\rint main()\r{\rint c=0;\rwhile(scanf(\u0026quot;%d\u0026quot;,\u0026amp;n))\r{\rif(n==0) break;\rprintf(\u0026quot;Test case #%d\\n\u0026quot;,++c);\rscanf(\u0026quot;%s\u0026quot;,a+1);\rnext[1]=0;\rfor(int i=2,j=0;i\u0026lt;=n;i++)\r{\rwhile(j\u0026gt;0\u0026amp;\u0026amp;a[i]!=a[j+1])\rj=next[j];\rif(a[i]==a[j+1]) j++;\rnext[i]=j;\r}\rifor(i,2,n)\rif(next[i]\u0026gt;=(i\u0026gt;\u0026gt;1)\u0026amp;\u0026amp;i%(i-next[i])==0)\rprintf(\u0026quot;%d %d\\n\u0026quot;,i,i/(i-next[i]));\rputs(\u0026quot;\u0026quot;);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":11,"section":"posts","summary":"","tags":["KMP"],"title":"POJ 1961 Period","uri":"https://cs-fil.github.io/2021/01/poj-1961/","year":"2021"},{"content":"没有想过，半年前，我的激励竟然要杀了我。 就此吧，还有一整年，别低头，还有好多路可以走的，为时不晚一定。\n","id":12,"section":"posts","summary":"","tags":["thoughts"],"title":"有思","uri":"https://cs-fil.github.io/2021/01/%E6%9C%89%E6%80%9D/","year":"2021"},{"content":"链接 摘要  字符串 $s$ 的最长回文子串\n解  $O(nlogn)$\n关于字符串$Hash$:\n视作 $P$ 进制数, $P$ 取 $131$, $13331$ 冲突最少\null 自然取模, 规避模运算的高复杂度\n求子串的 $Hash$ 类似前缀和的思想 $s[j]-s[i-1]*$$P^{j-i+1}$\n分奇偶两种情况, 枚举中间点, 二分回文半径\n$O(n)$\n$manacher$ 算法\n对奇偶性的处理: 在字符间添加 '#'\n对边界的处理: $s[0]=$ '!', $s[l+2]=$ \u0026lsquo;^\u0026rsquo; $(s[l]=a[n],s[1]=s[l+1]=$ '#' $)$\n维护当前最大回文串的中心字符下标 $mid$ 、回文串右边界下标\n遍历字符串, 若下标 $i$$\u0026lt;$$r$, 则可运用中点公式查找关于 $mid$ 对称位置的回文半径\n对称位置的回文半径有三种情况:\n1.j-f[j] 未抵左边界, 则直接可以确定 f[i]=f[j](若扩展, 对称后与之前确定的矛盾)\n2.j-f[j] 恰抵左边界, 此时 f[i] 在 f[j] 的基础上扩展\n3.j-f[j] 越过左边界, 则也可以直接确定 f[i]=r-i+1(若扩展, 则非最大回文串)\n在这一基础上进一步分析复杂度:\nfor 循环 $n$ 次\n情况1、3: $O(1)$\n情况2:\nwhile 受 $r$ 制约, $r$ 依据 $i+k$, $i+k$ 在 $r$ 的基础之上递增\n相当于 $r$ 为 $i+k$ 存点, 循环下一个字符时要么读取存点, 要么新增并再存点\n=\u0026gt; while 循环 $n$ 次\n复杂度即是 $2n$ $=$ $O(n)$\n代码  字符串 $Hash$\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define max(a,b) ((a)\u0026gt;(b)?(a):(b))\r#define min(a,b) ((a)\u0026lt;(b)?(a):(b))\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef unsigned long long ull;\rconst int N=1e6+5,P=131;\rint lnth;\rchar s[N];\rull a[N],b[N],p[N];\rinline bool judge(int x,int l)\r{\rull a1=a[x+l]-a[x]*p[l];\rull b1=b[lnth-x+1+l]-b[lnth-x+1]*p[l];\rif(a1==b1)\rreturn true;\relse return false;\r}\rinline bool judge2(double x,int l)\r{\rull a1=a[(int)(x+l-0.5)]-a[(int)(x-0.5)]*p[l];\rull b1=b[(int)(lnth-x+0.5+l)]-b[(int)(lnth-x+0.5)]*p[l];\rif(a1==b1)\rreturn true;\relse return false;\r}\rint main()\r{\rp[0]=1;\rifor(i,1,1000000)\rp[i]=p[i-1]*P;\rint c=0;\rwhile(scanf(\u0026quot;%s\u0026quot;,s+1))\r{\r++c;\rif(s[1]=='E')\rbreak;\rlnth=strlen(s+1);\rifor(i,1,lnth)\r{\ra[i]=a[i-1]*P+(s[i]-'a'+1);\rb[i]=b[i-1]*P+(s[lnth-i+1]-'a'+1);\r}\rint mxn=1;\rifor(i,1,lnth)\r{\rint r=min(i-1,lnth-i),l=0;\rwhile(l\u0026lt;r)\r{\rint mid=(l+r+1)\u0026gt;\u0026gt;1;\rif(judge(i,mid))\rl=mid;\relse r=mid-1;\r}\rmxn=max(mxn,l*2+1);\r}\rfor(double i=0.5;i\u0026lt;=lnth-0.5;++i)\r{\rint r=min(i-0.5,lnth-i+0.5),l=0;\rwhile(l\u0026lt;r)\r{\rint mid=(l+r+1)\u0026gt;\u0026gt;1;\rif(judge2(i,mid))\rl=mid;\relse r=mid-1;\r}\rmxn=max(mxn,l*2);\r}\rprintf(\u0026quot;Case %d: %d\\n\u0026quot;,c,mxn);\r}\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r  $manacher$\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define max(a,b) ((a)\u0026gt;(b)?(a):(b))\r#define min(a,b) ((a)\u0026lt;(b)?(a):(b))\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef unsigned long long ull;\rconst int N=2e6+5,P=131;\rchar s[N],con[N];\rint f[N];\rint main()\r{\rint id=0;\rwhile(scanf(\u0026quot;%s\u0026quot;,s+1)\u0026amp;\u0026amp;s[1]!='E')\r{\rid++;\rint l=strlen(s+1);\rcon[0]='$';\rint c=0;\rifor(i,1,l)\rcon[++c]='#',con[++c]=s[i];\rcon[++c]='#',con[c+1]='^';\rint r=0,mid=0;\rint mxn=1;\rifor(i,1,c-1)\r{\rif(i\u0026lt;r)\rf[i]=min(f[2*mid-i],r-i+1);\relse f[i]=1;\rwhile(con[i+f[i]]==con[i-f[i]])\rf[i]++;\rif(r\u0026lt;i+f[i]-1)\rmid=i,r=i+f[i]-1;\rmxn=max(mxn,f[i]-1);\r}\rprintf(\u0026quot;Case %d: %d\\n\u0026quot;,id,mxn);\r} system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":13,"section":"posts","summary":"","tags":["字符串Hash","manacher"],"title":"POJ 3974 Palindrome","uri":"https://cs-fil.github.io/2020/12/poj-3974/","year":"2020"},{"content":" 通过尽可能减少 $Hash$ 冲突的特定运算将数据控在一个小范围 辅以链表解决 $Hash$ 冲突, 再在小范围维护原始数据, 出现冲突时调用原始数据进一步判断 可以理解为将长列折叠并对纵列分类 分类标准即是特定运算函数 $H(x)$ -为降低存在、出现次数类问题的复杂度\n","id":14,"section":"posts","summary":"","tags":["Hash"],"title":"Hash","uri":"https://cs-fil.github.io/2020/12/hash/","year":"2020"},{"content":"链接 摘要  判断若干个六元组是否重复(从任意一个元素开始顺序或倒序相同即视为相同)\n解  属出现次数类问题, 考虑用 $Hash$ 降低复杂度\ndebug  1.判不同需所有情况下皆不同才可判 2.注意取模后的范围与数组实际范围是否相符\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5,P=99991;\rint n,s[N][7];\rint head[N],nxt[N],c;\rinline bool check(int a[],int b[])\r{\rifor(i,1,6)\rifor(j,1,6)\r{\rbool flg=true;\rifor(k,1,6)\rif(a[(i+k)%6+1]!=b[(j+k)%6+1])\r{flg=false; break;}\rif(flg) return true;\rflg=true;\rifor(k,1,6)\rif(a[(i+k)%6+1]!=b[(j-k+6)%6+1])\r{flg=false; break;}\rif(flg) return true;\r}\rreturn false;\r}\rinline int hash(int a[])\r{\rint sum=0,mul=1;\rifor(i,1,6)\r{\rsum=(sum+a[i])%P;\rmul=(long long)mul*a[i]%P;\r}\rreturn (sum+mul)%P;\r}\rinline bool insert(int a[])\r{\rint val=hash(a);\rfor(int i=head[val];i;i=nxt[i])\rif(check(s[i],a))\rreturn true;\r++c;\rifor(i,1,6)\rs[c][i]=a[i];\rnxt[c]=head[val];\rhead[val]=c;\rreturn false;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\r{\rint a[7];\rifor(j,1,6)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[j]);\rif(insert(a))\rreturn puts(\u0026quot;Twin snowflakes found.\u0026quot;),0;\r}\rputs(\u0026quot;No two snowflakes are alike.\u0026quot;);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":15,"section":"posts","summary":"","tags":["Hash"],"title":"POJ 3349 Snowflake Snow Snowflakes","uri":"https://cs-fil.github.io/2020/12/poj-3349/","year":"2020"},{"content":"链接 摘要  对于一个长度为 $n$ 的序列, 对于每一个 $a_i$, 求:\n$min|a_i-a_j|(1$$\\leqslant$$j$$\u0026lt;$$i)$\n以及令上式取到最小值的 $j$, 若最小值点不唯一, 则选择较小的 $j$\n解  1.将数依次插入集合, 集合满足单调递增 (平衡树 $set$)\n2.排序, 建立链表, 从后往前循环, 借助链表在前驱后继中确定一个 $j$ 后删除之\n时间复杂度均为 $O(nlongn)$\ndebug  对边界的处理稍加注意\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5;\rint n,b[N],ans1[N],ans2[N];\rstruct node\r{\rint val,pre,nxt,p;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return val\u0026lt;x.val;} }l[N];\rinline void remove(int p)\r{\rl[l[p].pre].nxt=l[p].nxt;\rl[l[p].nxt].pre=l[p].pre;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;l[i].val),l[i].p=i;\rstd::sort(l+1,l+n+1);\rifor(i,1,n)\r{\rl[i].nxt=i+1,l[i+1].pre=i;\rb[l[i].p]=i;\r}\rl[0].val=-0x3f3f3f3f;\rl[n+1].val=0x3f3f3f3f;\rfor(int i=n;i\u0026gt;=2;--i)\r{\rint a1=l[l[b[i]].nxt].val-l[b[i]].val;\rint a2=l[b[i]].val-l[l[b[i]].pre].val;\rif(l[b[i]].pre==0)\rans1[i]=a1,ans2[i]=l[l[b[i]].nxt].p;\relse if(l[b[i]].nxt==n+1)\rans1[i]=a2,ans2[i]=l[l[b[i]].pre].p;\relse if(a1\u0026lt;a2)\rans1[i]=a1,ans2[i]=l[l[b[i]].nxt].p;\relse ans1[i]=a2,ans2[i]=l[l[b[i]].pre].p;\rremove(b[i]);\r}\rifor(i,2,n)\rprintf(\u0026quot;%d %d\\n\u0026quot;,ans1[i],ans2[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":16,"section":"posts","summary":"","tags":["链表"],"title":"CH 1301 邻值查找","uri":"https://cs-fil.github.io/2020/12/ch-1301/","year":"2020"},{"content":"链接 摘要  对于一个整数集合, 定义判定规则: 从中取出 $m$ 对数, 使得每对数的差的平方之和最大\n这个最大值若小于等于给定的值, 则该集合合法\n给定长度为 $n$ 的数列, 求合法的最少分段数\n解  对于判定, 最大时即为最大与最小, 次大与次小, 数学证明 划分数列需要枚举边界进行判断\n二分与倍增时间复杂度一致, 但是根据倍增的特性可以使用类似归并排序的做法,\n每次扩展可以省去部分排序, 时间复杂度近 $O(NlogN)$\n技巧  $merge$ 函数\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int N=5e5+5;\rint T,n,m;\rll k;\rint a[N],b[N],c[N];\rinline ll cal(int l,int r,int t)\r{\rint i=l,j=r,ct=m;\rll res=0;\rifor(k,t+1,r)\rb[k]=a[k];\rstd::sort(b+t+1,b+r+1);\rstd::merge(a+l,a+t+1,b+t+1,b+r+1,c+l);\rwhile(i\u0026lt;j\u0026amp;\u0026amp;ct\u0026gt;=1)\rres+=1ll*(c[i]-c[j])*(c[i++]-c[j--]),ct--;\rreturn res;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rwhile(T--)\r{\rscanf(\u0026quot;%d%d%lld\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;k);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\rint cnt=0,r=1,l=1,p=1;\rwhile(true)\r{\rif(r+p\u0026lt;=n)\r{\rif(cal(l,r+p,r)\u0026lt;=k)\r{\rr+=p,p*=2;\rifor(i,l,r)\ra[i]=c[i];\r}\relse if(p/2!=0)\rp/=2;\relse\r{\rifor(i,l,r)\ra[i]=c[i];\rl=r=r+1,cnt++,p=1;\r}\r}\relse\r{\rp=n-r;\rif(cal(l,r+p,r)\u0026lt;=k)\r{cnt++;break;}\relse if(p/2!=0)\rp/=2;\relse\r{ ifor(i,l,r)\ra[i]=c[i];\rcnt++,l=r=r+1,p=1;\r}\r} }\rprintf(\u0026quot;%d\\n\u0026quot;,cnt);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":17,"section":"posts","summary":"","tags":["倍增"],"title":"CH 0601 Genius ACM","uri":"https://cs-fil.github.io/2020/12/ch-0601/","year":"2020"},{"content":"链接 摘要  在 $n$$×$$m$ 的矩阵中, 有 $t$ 个关键点\n问是否可以通过上下左右移动关键点, 使得每行每列的关键点数相等 特别的, 第一列和第 $n$ 列相邻, 行亦然\n解  可以发现: 左右移动不会影响行关键点数, 上下不影响列\n于是拆分为两个部分: 左右移动使得列关键点数相等, 上下使行等\n于是问题变成了一维: 环形均分纸牌问题\n普通的均分纸牌问题, 先考虑第一个人索取或给予, 后将一二人视为一个整体考虑索取或给予\n若先预处理每一个人的手牌数减去均值, 则目标即是 $0$\n答案即是前缀和绝对值之和\n而考虑环形, 非环形的情况就是在第一个人和第 $n$ 个人之间断开 考虑朴素算法, 我们只需枚举断开的位置即可\n假设位置是 $k$, $a[k+1]$ 对应的前缀和即是 $s[k+1]-s[k]$\n多列几个关键点式子, 发现前缀和绝对值之和, 就是在之前的基础上, 每一项减去 $s[k]$\n该问题巧妙地指向了货仓选址问题, 即只需排序找到中位数便可得出答案\ndebug  $ceil$ 函数内外都是 double\n答案要考虑是否 $long$ $long$\n技巧  省 $ceil$ k=(n+(n\u0026amp;1))\u0026gt;\u0026gt;1\n最终求和还可以优化省去 $abs$\nfor(int i=1;i\u0026lt;=n;++i)s1[i]+=s1[i-1];\rrnum=s1[n]-s1[i]-(n-i)*(s1[i]-s1[i-1])+i*(s1[i]-s1[i-1])-s1[i];\r 代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int N=1e5+5;\rint n,m,t;\rll a[N],b[N],aa[N],ba[N],as[N],bs[N];\rbool flg1=false,flg2=false;\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;t);\rint x,y;\rifor(i,1,t)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;x,\u0026amp;y);\ra[x]++,b[y]++;\r}\rll a1=t/n,b1=t/m;\rll ans=0;\rif(t%n==0)\r{\rifor(i,1,n)\raa[i]=a[i]-a1,as[i]=as[i-1]+aa[i];\rstd::sort(as+1,as+n+1);\rll k=as[(int)ceil((double)n/2)];\rifor(i,1,n)\rans+=abs(as[i]-k);\rflg1=true;\r}\rif(t%m==0)\r{\rifor(i,1,m)\rba[i]=b[i]-b1,bs[i]=bs[i-1]+ba[i];\rstd::sort(bs+1,bs+m+1);\rll k=bs[(int)ceil((double)m/2)];\rifor(i,1,m)\rans+=abs(bs[i]-k);\rflg2=true;\r}\rif(flg1\u0026amp;\u0026amp;flg2)\rprintf(\u0026quot;both %lld\u0026quot;,ans);\relse if(flg1)\rprintf(\u0026quot;row %lld\u0026quot;,ans);\relse if(flg2)\rprintf(\u0026quot;column %lld\u0026quot;,ans);\relse printf(\u0026quot;impossible\u0026quot;);\rsystem(\u0026quot;pause\u0026quot;);\r}\r","id":18,"section":"posts","summary":"","tags":["数学"],"title":"CH 0502 七夕祭","uri":"https://cs-fil.github.io/2020/12/ch-0502/","year":"2020"},{"content":"链接 摘要  $n$ 个人各自会一门语言, 语言用 $int$ 范围内的整数表示\n$m$ 部电影, 各自有配音和字幕\n求一部电影, 其配音的语言其次字幕的语言会的人最多\n解  语言表示在 $int$ 范围内, 故需要离散化\n一是用 $map$ 直接用作数组\n二是手写离散化, 时空复杂度小\n代码  $map$\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;map\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=2e5+5;\rint n,m;\rstd::map\u0026lt;int,int\u0026gt; map;\rstruct node\r{\rint p,a,b;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return (a\u0026gt;x.a)||(a==x.a\u0026amp;\u0026amp;b\u0026gt;x.b);}\r}mv[N];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint x;\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x),map[x]++;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;m);\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rmv[i].p=i;\rif(map.count(x))\rmv[i].a=map[x];\r}\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rif(map.count(x))\rmv[i].b=map[x];\r}\rstd::sort(mv+1,mv+m+1);\rprintf(\u0026quot;%d\u0026quot;,mv[1].p);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r  手写离散化\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=2e5+5;\rint n,m;\rint l[N],t[N],ttl[N],c;\rstruct node\r{\rint p,a,b;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return (a\u0026gt;x.a)||((a==x.a)\u0026amp;\u0026amp;(b\u0026gt;x.b));}\r}mv[N];\rinline void discrete()\r{\rstd::sort(l+1,l+n+1);\rifor(i,1,n)\r{\rif(i==1||l[i]!=l[i-1])\rt[++c]=l[i];//t数组用于查位置\rttl[c]++;\r}\r}\rinline int query(int x)\r{\rreturn std::lower_bound(t+1,t+c+1,x)-t;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;l[i]);\rdiscrete();\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;m);\rint x;\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rmv[i].p=i;\rif(t[query(x)]==x)\rmv[i].a=ttl[query(x)];\r}\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rif(t[query(x)]==x)\rmv[i].b=ttl[query(x)];\r}\rstd::sort(mv+1,mv+m+1);\rprintf(\u0026quot;%d\u0026quot;,mv[1].p);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":19,"section":"posts","summary":"","tags":["离散化"],"title":"Codeforces 670C Cinema","uri":"https://cs-fil.github.io/2020/12/cf-670c/","year":"2020"},{"content":"inline void discrete()\r{\rstd::sort(l+1,l+n+1);\rifor(i,1,n)\r{\rif(i==1||l[i]!=l[i-1])\rt[++c]=l[i];//t数组用于查位置\r//ttl[c]++; 相关数据维护\r}\r}\rinline int query(int x)\r{\rreturn std::lower_bound(t+1,t+c+1,x)-t;\r}\r","id":20,"section":"posts","summary":"","tags":["离散化"],"title":"离散化","uri":"https://cs-fil.github.io/2020/12/discrete/","year":"2020"},{"content":"链接 摘要  $\u0026quot;\u0026lt;=\u0026quot;$ 且涉及无解判断的二分\n解  二分有两个模板\n$\u0026quot;\u0026lt;=\u0026quot;$ 用以下这个二分模板\n于是无解判断只需左边范围多开一位\n若最终 $l$ 在多开的那一位, 则无解\ndebug  (不知为何)输入时 (double)*100 转 (int) 需要 $ceil$ 函数 否则会有误差, 如 $8.19$ $=\u0026gt;$ $820$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e4+5;\rint n,m;\rdouble t;\rint a[N];\rchar tmp[100];\rinline bool judge(int x)\r{\rint res=0;\rifor(i,1,n)\rres+=a[i]/x;\rif(res\u0026gt;=m) return true;\relse return false;\r}\rint main()\r{\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\r//freopen(\u0026quot;out1.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\r//ifor(i,1,3) scanf(\u0026quot;%s\u0026quot;,tmp);\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rint r=0;\rifor(i,1,n)\rscanf(\u0026quot;%lf\u0026quot;,\u0026amp;t),a[i]=ceil(t*100),r=r\u0026gt;a[i]?r:a[i];\r//ifor(i,1,n)\r// printf(\u0026quot;%d\\n\u0026quot;,a[i]);\rint l=0;\rwhile(l\u0026lt;r)\r{\rint mid=(l+r+1)\u0026gt;\u0026gt;1;\r//printf(\u0026quot;%d %d %d\\n\u0026quot;,l,r,mid);\rif(judge(mid))\rl=mid;\relse r=mid-1;\r}\rif(l==0) printf(\u0026quot;0.00\u0026quot;);\relse printf(\u0026quot;%.2lf\u0026quot;,(double)l/100);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":21,"section":"posts","summary":"","tags":["二分"],"title":"POJ 1064 Cable master","uri":"https://cs-fil.github.io/2020/11/poj-1064/","year":"2020"},{"content":"链接 摘要  序列 $n$ 中长度 ∈[S,T] 的子序列的最大平均值\n解  答案具有单调性, 用二分转化为判定性问题\n考虑二分平均值\n简化取平均的操作, 预处理减去平均值的数列, 则只需判断是否有子段和大于零即可\n而求子段和最大值引入单调队列, 队列内维护子段首数前一个数的前缀和, 队列内单调递增\n技巧  实数范围内的二分需设置精度 $eps$ 即 while(l+eps\u0026lt;r)\n若保留 $k$ 位小数, 则取 $eps$$=$$10^{-(k+2)}$\nl=mid 或 r=mid\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5;\rint n,s,t,hd,tl,q[N];\rdouble a[N],tmp[N],sum[N];\rinline bool judge(double p)\r{\rifor(i,1,n)\rtmp[i]=a[i]-p;\rifor(i,1,n)\rsum[i]=sum[i-1]+tmp[i];\rhd=1,tl=0;\rifor(i,1,n)\r{\rif(i\u0026gt;=s)\r{\rwhile(hd\u0026lt;=tl\u0026amp;\u0026amp;sum[i-s]\u0026lt;sum[q[tl]]) tl--;\rq[++tl]=i-s;\r}\rif(hd\u0026lt;=tl\u0026amp;\u0026amp;q[hd]\u0026lt;i-t) hd++;\rif(hd\u0026lt;=tl\u0026amp;\u0026amp;sum[i]-sum[q[hd]]\u0026gt;=0) return true;\r}\rreturn false;\r}\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;s,\u0026amp;t);\rdouble l=-10000,r=10000;\rifor(i,1,n)\rscanf(\u0026quot;%lf\u0026quot;,\u0026amp;a[i]);\rdouble ans;\rwhile(r-l\u0026gt;1e-5)\r{\rdouble mid=(l+r)/2;\rif(judge(mid))\rl=ans=mid;\relse r=mid;\r}\rprintf(\u0026quot;%.3lf\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":22,"section":"posts","summary":"","tags":["单调队列","二分"],"title":"Luogu P1419 寻找段落","uri":"https://cs-fil.github.io/2020/11/luogu-p1419/","year":"2020"},{"content":"链接 解  树上差分:\n结点 $+$ $+$, 结点 $LCA$ $-$ $-$, 结点 $LCA$ 父亲 $-$ $-$\n处理完后 $dfs$ 祖先加上所有子结点\n值得注意的是端点会重复记录, 需最后减去\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=3e5+5;\rint n,a[N];\rint hd[N],ver[N\u0026lt;\u0026lt;1],nxt[N\u0026lt;\u0026lt;1],dpth[N],f[N][20],val[N],cnt;\rdouble lg2[N];\rinline void add(int u,int v)\r{\rver[++cnt]=v,nxt[cnt]=hd[u],hd[u]=cnt;\rver[++cnt]=u,nxt[cnt]=hd[v],hd[v]=cnt;\r}\rinline void build(int x,int p)\r{\rdpth[x]=dpth[p]+1;\rf[x][0]=p;\rfor(int i=1;(1\u0026lt;\u0026lt;i)\u0026lt;=dpth[x];++i)\rf[x][i]=f[f[x][i-1]][i-1];\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\rbuild(ver[i],x);\r}\rinline int lca(int x,int y)\r{\rif(dpth[x]\u0026lt;dpth[y])\rstd::swap(x,y);\rwhile(dpth[x]\u0026gt;dpth[y])\rx=f[x][(int)lg2[dpth[x]-dpth[y]]];\rif(x==y) return x;\rfor(int i=lg2[dpth[x]];i\u0026gt;=0;i--)\rif(f[x][i]!=f[y][i])\rx=f[x][i],y=f[y][i];\rreturn f[x][0];\r}\rinline void dfs(int x,int p)\r{\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\r{\rdfs(ver[i],x);\rval[x]+=val[ver[i]];\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\rint x,y;\rifor(i,1,n-1)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;x,\u0026amp;y),add(x,y);\rifor(i,1,n)\r{double k=log(i)/log(2);lg2[i]=k;}\rbuild(1,0);\rifor(i,1,n-1)\r{\rval[a[i]]++,val[a[i+1]]++,val[lca(a[i],a[i+1])]--;\rval[f[lca(a[i],a[i+1])][0]]--;\r}\rdfs(1,0);\rifor(i,2,n)\rval[a[i]]--;\rifor(i,1,n)\rprintf(\u0026quot;%d\\n\u0026quot;,val[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":23,"section":"posts","summary":"","tags":["差分","LCA"],"title":"Luogu P3258 [JLOI]松鼠的新家","uri":"https://cs-fil.github.io/2020/11/luogu-p3258/","year":"2020"},{"content":"链接 摘要  求序列 $n$ 中, 长度不超过 $m$ 的子序列的和的最大值 $n≤500000$\n解  $i$~$j$ 的序列和即为 $sum[j]-sum[i-1]$\n所以枚举过程中, 只需维护 $m$ 个数内 $sum[i]$ 的最小值\n考虑引入单调队列, 满足队列内 编号.$sum$ 都单调递增\n维护 $head.tail$, 于是便于弹出编号超出范围的, 便于弹出尾部加入新增的 $sum$ 值后不满足单调递增的\n只需 $O(n)$ 枚举, 时刻更新队列, 用 $sum[i]-sum[q[head]]$ 更新答案即可\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=5e5+5;\rint n,m,h=1,t;\rint q[N],sum[N];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rint x;\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x),sum[i]=sum[i-1]+x;\rint ans=-0x3f3f3f3f;\rifor(i,1,n)\r{\rif(h\u0026lt;=t\u0026amp;\u0026amp;q[h]\u0026lt;i-m) h++;\rans=std::max(ans,sum[i]-sum[q[h]]);\rwhile(h\u0026lt;=t\u0026amp;\u0026amp;sum[i]\u0026lt;=sum[q[t]]) t--;\rq[++t]=i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rreturn 0;\r}\r","id":24,"section":"posts","summary":"","tags":["单调队列"],"title":"Luogu P1714 切蛋糕","uri":"https://cs-fil.github.io/2020/11/luogu-p1714/","year":"2020"},{"content":" 1.建树 (同时预处理深度, 子父关系) 2.找祖先: 先到达同一深度, 后同时上跳直至公共祖先的下一层, 输出此时的父亲 预处理 $log_2$ 便于计算\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=5e5+5;\rint n,m,s;\rint hd[N],ver[N\u0026lt;\u0026lt;1],nxt[N\u0026lt;\u0026lt;1],dpth[N],f[N][20],cnt;\rdouble lg2[N];\rinline void add(int u,int v)\r{\rver[++cnt]=v,nxt[cnt]=hd[u],hd[u]=cnt;\rver[++cnt]=u,nxt[cnt]=hd[v],hd[v]=cnt;\r}\rinline void build(int x,int p)\r{\rdpth[x]=dpth[p]+1;\rf[x][0]=p;\rfor(int i=1;(1\u0026lt;\u0026lt;i)\u0026lt;=dpth[x];++i)\rf[x][i]=f[f[x][i-1]][i-1];\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\rdfs(ver[i],x);\r}\rinline int lca(int x,int y)\r{\rif(dpth[x]\u0026lt;dpth[y])\rstd::swap(x,y);\rwhile(dpth[x]\u0026gt;dpth[y])\rx=f[x][(int)lg2[dpth[x]-dpth[y]]];\rif(x==y) return x;\rfor(int i=lg2[dpth[x]];i\u0026gt;=0;i--)\rif(f[x][i]!=f[y][i])\rx=f[x][i],y=f[y][i];\rreturn f[x][0];\r}\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;s);\rint a,b;\rifor(i,1,n-1)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a,\u0026amp;b),add(a,b);\rifor(i,1,n)\r{double k=log(i)/log(2);lg2[i]=k;}\rbuild(s,0);\rifor(i,1,m)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a,\u0026amp;b),printf(\u0026quot;%d\\n\u0026quot;,lca(a,b));\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":25,"section":"posts","summary":"","tags":["LCA"],"title":"最近公共祖先(LCA)","uri":"https://cs-fil.github.io/2020/11/least-common-ancestors/","year":"2020"},{"content":"链接 摘要  给定 $n$ 个元素, 每个元素有 $number$, $color$, $value$ 三个数据 定义三元组$:$ $(x,y,z)$ 满足两个条件\n1. $xyz$ 是整数, $x＜y＜z$, $y$$-$$x$$=$$z$$-$$y$\n2. $color_x$ $=$ $color_z$\n其分数为 $(x$$+$$z)$$×$$($$value_x$$+$$value_y$$)$\n求所有满足条件的三元组的分数的和 $mod$ $10007$\n解  值得学习的思想过程:\n考虑枚举 $x,y,z$, 复杂度 $O($$n^3$$)$超时\n由三元组条件得 $2y$$=$$x$$+$$z$, 枚举复杂度 $O($$n^2$$)$超时\n但是我们得到若 $x,z$ 奇偶性相同且颜色一致, 那么此三元组一定满足条件 于是按照颜色和奇偶性分为 $2*m$ 个组, 答案就是所有组的分数之和\n对于每一个组枚举列式计算化简得:\n$ans$ $=$ $x_1$ * $($$y_1$ * $(k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k$$)$$+$$x_2$ * $($$y_2$ * $($$k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k$$)$$+$$\u0026hellip;$$+$$x_k$ * $($$y_k$ * $($$k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k)$\n预处理 $k,sum$, $O(n)$ 计算 $ans$\n心得  寻找特征, 根据特征步步优化, 有时化成数学问题得到式子\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5,mod=1e4+7;\rint m,n;\rint v[N],c[N],cnt[N][2],sum[N][2];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;v[i]);\rifor(i,1,n)\r{ scanf(\u0026quot;%d\u0026quot;,\u0026amp;c[i]);\rcnt[c[i]][i%2]++,sum[c[i]][i%2]=(sum[c[i]][i%2]+v[i])%mod; }\rint ans=0;\rifor(i,1,n)\rans=(ans+i*(sum[c[i]][i%2]+v[i]*(cnt[c[i]][i%2]-2)%mod)%mod)%mod;\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":26,"section":"posts","summary":"","tags":["数学"],"title":"Luogu P2671 求和","uri":"https://cs-fil.github.io/2020/11/luogu-p2671/","year":"2020"},{"content":"链接 摘要  数轴上 $n$ 个不等高的建筑, 从左看到 $A$ 个, 右看 $B$ 个\n两种方案不同, 即高度排列不同, 求方案数\n 1≤n≤50000, 1≤A,B≤100\n解  对每一个可见的建筑及其挡住的建筑建组\n求方案数即枚举分组方式, 后固定下每组最高建筑, 组内其余全排列\n这恰好是第一类斯特林数\n简单阐述正确性:\n斯特林数包括全部分组方式, 对于不同的分组方式, 其序列一定不同\n后在组中选取一个值固定\n定量分析\n在 $n-1$ 个数中分 $A+B-2$ 组, 由于 $A$ $B$ 等价,选取 $A-1$ 放左即是组合数问题\n最终答案 $s(n-1,A+B-2)$*$C^{A+B-2}_{A-1}$\n技巧  将斯特林数及组合数的递推式可视化为二维数组, 容易考虑初始赋值\ndebug  1.预处理的数组范围要与所求的数组范围一致\n2.递推越界问题(实际可用的范围比所开的数组范围少1, 慎用 $N$)\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int inf=5e4+5,mod=1e9+7;\rint T,n,a,b;\rll c[205][105],s[inf][205];\rinline void prework()\r{\rs[0][0]=s[1][1]=1;\rifor(i,2,inf)\rs[i][1]=s[i-1][1]*(i-1);\rifor(i,0,205) c[i][0]=1;\rifor(i,2,inf)\rfor(int j=2;j\u0026lt;=i\u0026amp;\u0026amp;j\u0026lt;=205;++j)\rs[i][j]=(s[i-1][j-1]+s[i-1][j]*(i-1))%mod;\rifor(i,1,205)\rfor(int j=1;j\u0026lt;=i\u0026amp;\u0026amp;j\u0026lt;=105;++j)\rc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rprework();\rwhile(T--)\r{ scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;a,\u0026amp;b);\rprintf(\u0026quot;%lld\\n\u0026quot;,s[n-1][a+b-2]*c[a+b-2][a-1]%mod); }\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":27,"section":"posts","summary":"","tags":["数学","线性递推"],"title":"Luogu P4609 [FJOI]建筑师","uri":"https://cs-fil.github.io/2020/11/luogu-p4609/","year":"2020"},{"content":"链接 摘要  根据递推式求 $F[n][m]$ $mod$ $1e9$$+$$7$\n数据范围见原题\n解  由递推式, 很容易想到构造使用矩阵乘法\n技巧 1.扩展欧拉定理  $a^b$ $≡$ $a^{b\\ mod\\ φ(n)}$ $(mod$ $n)$ $(a$与$n$互质$)$\n对指数、底数取模, 优化复杂度\n2.十进制快速幂  本题中, 为应对高精度指数(未使用扩展欧拉定理)\ninline node qkpw(node bs,char *p)\r{\rnode res;\rres.a[1][1]=res.a[2][2]=1;\rll l=strlen(p+1);\rfor(ll i=l;i\u0026gt;=1;i--)\r{\rnode t=bs;\rif(p[i]=='9')\r{ t=t*t,t=t*t,t=t*t,t=t*bs;\rres=res*t;}\relse if(p[i]=='8')\r{ t=t*t,t=t*t,t=t*t;\rres=res*t;}\relse\r{ ifor(j,1,p[i]-'0')\r{ res=res*bs;}}\rnode k=bs;\rbs=bs*bs,bs=bs*bs,bs=bs*bs,bs=bs*k,bs=bs*k;\r}\rreturn res;\r}\r 3.卡常 循环展开(未测试) struct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rres.a[1][1]=md(a[1][1]*x.a[1][1]%mod+a[1][2]*x.a[2][1]%mod);\rres.a[1][2]=md(a[1][1]*x.a[1][2]%mod+a[1][2]*x.a[2][2]%mod);\rres.a[2][1]=md(a[2][1]*x.a[1][1]%mod+a[2][2]*x.a[2][1]%mod);\rres.a[2][2]=md(a[2][1]*x.a[1][2]%mod+a[2][2]*x.a[2][2]%mod);\rreturn res;\r}\r}ans,bs1,bs2,bs3;\r 4.卡常 加法取模(未测试)  两个小于 $mod$ 的数相加\ninline ll md(ll x)\r{ return x\u0026gt;=mod?x-mod:x;}\r 5.特判  注意特判 $a$$=$$1$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst ll inf=1e6+5,mod=1e9+7;\rll n,m,a,b,c,d,e;\rchar ns[inf],ms[inf];\rinline ll md(ll x)\r{ return x\u0026gt;=mod?x-mod:x;}\rstruct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rres.a[1][1]=md(a[1][1]*x.a[1][1]%mod+a[1][2]*x.a[2][1]%mod);\rres.a[1][2]=md(a[1][1]*x.a[1][2]%mod+a[1][2]*x.a[2][2]%mod);\rres.a[2][1]=md(a[2][1]*x.a[1][1]%mod+a[2][2]*x.a[2][1]%mod);\rres.a[2][2]=md(a[2][1]*x.a[1][2]%mod+a[2][2]*x.a[2][2]%mod);\rreturn res;\r}\r}ans,bs1,bs2,bs3;\rinline node qkpw(node bs,ll p)\r{\rnode res;\rres.a[1][1]=res.a[2][2]=1;\rwhile(p)\r{\rif(p\u0026amp;1)\r{ res=res*bs;}\rbs=bs*bs,p\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main()\r{\rscanf(\u0026quot;%s%s\u0026quot;,ns+1,ms+1);\rscanf(\u0026quot;%lld%lld%lld%lld\u0026quot;,\u0026amp;a,\u0026amp;b,\u0026amp;c,\u0026amp;d);\rif(a!=1) { e=mod-1;}\relse\r{ e=mod;}\rll ln=strlen(ns+1),lm=strlen(ms+1);\rifor(i,1,ln)\r{ n=(n*10+(ns[i]-'0'))%e;}\rifor(i,1,lm)\r{ m=(m*10+(ms[i]-'0'))%e;}\rans.a[1][1]=1,ans.a[1][2]=1;\rbs1.a[1][1]=a,bs1.a[2][1]=b,bs1.a[2][2]=1;\rbs2.a[1][1]=c,bs2.a[2][1]=d,bs2.a[2][2]=1;\rbs1=qkpw(bs1,m-1);\rbs3=bs1*bs2;\rans=ans*qkpw(bs3,n-1);\rans=ans*bs1;\rprintf(\u0026quot;%lld\u0026quot;,ans.a[1][1]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":28,"section":"posts","summary":"","tags":["矩阵乘法"],"title":"Luogu P1397 [NOI2013]矩阵游戏","uri":"https://cs-fil.github.io/2020/11/luogu-p1397/","year":"2020"},{"content":"链接 摘要  $F_n$ $mod$ $10^9$$+$$7$\n $1\\lt n\\leq$ $2^{63}$\n解  限于数据范围, $O(n)$ 的递推会 $TLE$\n于是化递推为矩阵乘法, 相当于将递推式换为一个乘号\n于是可以使用快速幂求解\n技巧  满足结合律的数学运算都可以使用快速幂\ndebug  注意指数 $long$ $long$ 时, 将快速幂函数的定义区也写为 $long$ $long$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst ll mod=1e9+7;\rll n;\rstruct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rifor(i,1,2)\rifor(j,1,2)\rifor(k,1,2)\rres.a[i][j]=(res.a[i][j]+a[i][k]*x.a[k][j])%mod;\rreturn res;\r}\r}ans,base;\rinline void qkpw(ll p)\r{\rwhile(p)\r{ if(p\u0026amp;1)\r{ ans=ans*base;}\rbase=base*base,p\u0026gt;\u0026gt;=1;\r}\r}\rint main()\r{\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;n);\rif(n\u0026lt;=2)\r{ return puts(\u0026quot;1\u0026quot;),0;}\rbase.a[1][1]=base.a[1][2]=base.a[2][1]=1;\rans.a[1][1]=ans.a[1][2]=1;\rqkpw(n-2);\rprintf(\u0026quot;%lld\u0026quot;,ans.a[1][1]%mod);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":29,"section":"posts","summary":"","tags":["矩阵乘法"],"title":"Luogu P1962 斐波那契数列","uri":"https://cs-fil.github.io/2020/11/luogu-p1962/","year":"2020"},{"content":"链接 摘要  求有多少种 $1$ 到 $n$ 的排列 $a$, 满足序列恰好有 $m$ 个位置 $i$, 使得 $a_i$$=$$i$\n答案对 $10^9$$+$$7$ 取模\n解  首先对题目进行模拟, 枚举满足条件的序列\n先确定下这 $m$ 个位置, 不难发现得到的情况数即为 $C_n^m$\n其次确定其余的位置\n定义 $D[i]$ 为 $i$ 个位置的情况数, 不难得到 $D[1]=0$, $D[2]=1$, $D[3]=2$\n对于 $D[4]$ 首先考虑 $1$ 的位置, 会有位置 $2.3.4$ $3$ 个情况\n进一步考虑除 $1$ 外数字 $2.3.4$ 的位置\n发现 $2$ 放在位置 $1$ 情况时, 其余数字的情况变为 $D[2]$\n若不放在位置 $1$ 则可假想位置 $1$ 为位置 $2$, 情况就变为了 $D[3]$\n于是 大胆推测 $D[i]=(n-1)*(D[i-1]+D[i-2])$\n于是答案即为 $C_n^m$ * $D[i]$\n心得 1.做题方法  线性递推题有两点技巧\n$1)$ 模拟以发现规律\n$2)$ 猜测以得出规律\n2.特判  写完题目还要对特殊情况进行检查, 必要时设置特判\n技巧  对于除法式子取模, 可以先将其转化为被除数与除数的乘法逆元相乘的式子, 再对因数取模\n求乘法逆元用到费马小定理 $a^p$ $≡$ $a$ $(mod$ $p)$ ($p$ 为质数)\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int inf=1e6+5,mod=1e9+7;\rint T,n,m;\rll f[inf],inv[inf],d[inf];\rinline ll qkpw(ll x,int p)\r{\rll ans=1;\rwhile(p)\r{\rif(p\u0026amp;1)\rans=ans*x%mod;\rx=x*x%mod,p\u0026gt;\u0026gt;=1;\r}\rreturn ans;\r}\rinline void prwrk()\r{\rf[0]=1;\rifor(i,1,inf)\rf[i]=f[i-1]*i%mod,inv[i]=qkpw(f[i],mod-2);\rd[1]=0,d[2]=1,d[3]=2;\rifor(i,4,inf)\rd[i]=(i-1)*(d[i-1]+d[i-2])%mod;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rprwrk();\rwhile(T--)\r{ scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rif(n==m) puts(\u0026quot;1\u0026quot;);\relse if(m==0) printf(\u0026quot;%lld\\n\u0026quot;,d[n]);\relse printf(\u0026quot;%lld\\n\u0026quot;,(((f[n]*inv[m])%mod*inv[n-m])%mod)*d[n-m]%mod);}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":30,"section":"posts","summary":"","tags":["线性递推"],"title":"Luogu P4071 [SDOI]排列计数","uri":"https://cs-fil.github.io/2020/11/luogu-p4071/","year":"2020"},{"content":"$n$ 的简化剩余系是 φ(n) 阶 $Abel$ 群  对 $∀$ $a_i$$,$$a_j$, 若 $a$ * $a_i$ $≡$ $a$ * $a_j$ $(mod$ $m)$\n则 $a$ * $($$a_i$ $-$ $a_j$$)$ $≡$ $0$\n即 $a_i$ $≡$ $a_j$\n故当 $a_i$ $≠$ $a_j$时, $a$$a_i$$,$$a$$a_j$ 也表示不同的同余类\n","id":31,"section":"posts","summary":"","tags":["欧拉定理","费马小定理"],"title":"欧拉定理\u0026费马小定理","uri":"https://cs-fil.github.io/2020/11/eulers-theoremfermats-little-theorem/","year":"2020"},{"content":"定义  对一个有向无环图 ( Directed Acyclic Graph 简称 $DAG$ ) $G$ 进行拓扑排序, 是将 $G$ 中所有顶点排成一个线性序列, 使得图中任意一对顶点 $u$ 和 $v$,\n若边 $\u0026lt;$$u$$,$$v$$\u0026gt;$$∈$$E$$(G)$, 则 $u$ 在线性序列中出现在 $v$ 之前.\ncode inline void topsort()\r{\rstd::queue\u0026lt;int\u0026gt;q;\rifor(i,1,n)\rif(!id[i])\rq.push(i),tsrt[++c]=i;\rwhile(!q.empty())\r{\rint u=q.front();q.pop();\rfor(int i=h[u];i;i=nxt[i])\r{\rid[ver[i]]--;\rif(!id[ver[i]])\rq.push(ver[i]),tsrt[++c]=ver[i];\r}\r}\r}\r","id":32,"section":"posts","summary":"","tags":["拓扑排序"],"title":"拓扑排序","uri":"https://cs-fil.github.io/2020/11/topsort/","year":"2020"},{"content":"链接 摘要  $4$ 座汉诺塔\n解  回想 $3$ 座汉诺塔的解法, 对于 $n$ 塔, 先将 $n$$-$$1$ 塔移至 $B$ 座, 后将底塔移至 $C$ 座, 最后将 $n$$-$$1$ 塔移至 $C$ 座. 基于递推的思想.\n$4$ 座汉诺塔类似, 按照 $4$ 座的方式将 $i$ 塔移至 $B$ 座, 因为大塔不可覆盖小塔, 于是对于剩下的 $n$$-$$i$ 塔问题转化为 $3$ 座汉诺塔.\n于是有 $h4[i]=min$ { $h4[j]*2+h3[i-j]|i \\in [2,n],j \\in [1,i)$ } $, h4[1]=1$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint a[13],b[13];\rint main()\r{\rmemset(b,0x3f,sizeof(b));\ra[1]=b[1]=1;\rprintf(\u0026quot;%d\\n\u0026quot;,b[1]);\rifor(i,2,12)\r{\ra[i]=(a[i-1]\u0026lt;\u0026lt;1)+1;\rifor(j,1,i-1)\rb[i]=std::min(b[i],(b[j]\u0026lt;\u0026lt;1)+a[i-j]);\rprintf(\u0026quot;%d\\n\u0026quot;,b[i]);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":33,"section":"posts","summary":"","tags":["递推"],"title":"POJ 1958 Strange Towers of Hanoi","uri":"https://cs-fil.github.io/2020/09/poj-1958/","year":"2020"},{"content":"链接 摘要  给定 $5$ $\\times$ $5$ 的 $01$ 矩阵\n给出一个操作 使 $+$ 型共 $5$ 个数变为其相反的状态\n求使原矩阵归 $1$ 的操作数\n解 1. 怎么做及为什么是对的  通过观察 发现如下三点性质\n$1)$ 每一个数至多进行一次操作 因为两次以上则会自我抵消\n$2)$ 若要求不在第 $n$ 行前再进行操作 则下一行及之后的情况也一并固定只有一种 由于操作的特殊性 若想改变第 $n$ 行第 $i$ 个数且不在本行操作 则只能在下一行的第 $i$ 位操作来改变它\n$3)$ 操作顺序不影响最终结果\n于是只需枚举第一行的操作方式 验证是否可行记录最小值即可\n2. 怎么想到这样做  将无序的操作有序化，是本题的关键。将任意的操作行行分类，结合操作的特殊性，发现本题的突破口，找到其性质。最后将其转化为指数型枚举问题。\ndebug 及技巧  $01$ 矩阵 容易想到用位运算 然而再看操作 发现 $+$ 的横 实现不便(位运算不可移负数位) 于是将其整体向左移一位即可\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint T,a[6],ori[6];\rint mnx=0x7fffffff,k;\rstd::string s;\rinline void wrk(int x)\r{\rifor(i,1,5)\rif(!((a[x-1]\u0026gt;\u0026gt;(5-i+1))\u0026amp;1))\r{\r++k;\ra[x-1]^=(2\u0026lt;\u0026lt;(4-i+1));\ra[x]=(a[x]^(7\u0026lt;\u0026lt;(4-i+1)))\u0026amp;62;\ra[x+1]^=(2\u0026lt;\u0026lt;(4-i+1));\r}\rif(x==5)\r{\rif(a[5]==62)\rmnx=std::min(mnx,k);\rreturn;\r}\rwrk(x+1);\r}\rinline void cnt(int cur)\r{\rif(cur==6)\r{\rint m=k;\rifor(i,1,5) ori[i]=a[i];\rwrk(2);\r/*回归状态*/\rifor(i,1,5) a[i]=ori[i];\rk=m;\rreturn;\r}\r/*点击1行第cur个灯*/\ra[1]=(a[1]^(7\u0026lt;\u0026lt;(4-cur+1)))\u0026amp;62;\ra[2]^=(2\u0026lt;\u0026lt;(4-cur+1));\r++k;\rcnt(cur+1);\ra[1]=(a[1]^(7\u0026lt;\u0026lt;(4-cur+1)))\u0026amp;62;\ra[2]^=(2\u0026lt;\u0026lt;(4-cur+1));\r--k;\rcnt(cur+1);\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rwhile(T--)\r{\rmnx=0x7fffffff,k=0;\rmemset(a,0,sizeof(a));\rifor(i,1,5)\r{\rstd::cin\u0026gt;\u0026gt;s;\rifor(j,1,5)\rif(s[j-1]=='1')\ra[i]|=(1\u0026lt;\u0026lt;(5-j+1));\r}\rcnt(1);\rif(mnx==0x7fffffff||mnx\u0026gt;6)\rputs(\u0026quot;-1\u0026quot;);\relse printf(\u0026quot;%d\\n\u0026quot;,mnx);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":34,"section":"posts","summary":"","tags":["位运算","枚举"],"title":"CH 0201 费解的开关","uri":"https://cs-fil.github.io/2020/09/ch-0201/","year":"2020"},{"content":"链接 摘要  给定 $n$ 个数 求最长下降子序列位数和方案数1\n$1$ $\\leq$ $n$ $\\leq$ $5000$\n解  难点在于如何求方案数\n定义 $f[i]$ 表示以 $arr[i]$ 结尾的最长下降子序列位数\n判断末位大小关系 若可，f[i]=std::max(f[i],f[j]+1)以转移\n重点 定义 $c[i]$ 表示以 $arr[i]$ 结尾的最长下降子序列方案数\n 判重 若两个子序列位数相同且末位相等 那么容易得知构成前一个序列的方案必然可以构成后者 则需清空前者的 $c[]$ 以去重 转移 判断末位大小关系和子序列位数关系 若可，c[i]+=c[j]以转移   $dp$ 过程中存储位数最大值 最后位数符合最大值的子序列的方案数相加即为方案总数\ndebug  memset(arr,1,sizeof(arr))无法达到令 $arr$ 数组每一位为 $1$ 的效果，解决方案是手打循环赋值\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=5e3+9;\rint n,mxn,ans;\rint arr[inf],f[inf],c[inf];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]),f[i]=1;\rifor(i,1,n)\r{\rifor(j,1,i-1)\rif(arr[i]\u0026lt;arr[j])\rf[i]=std::max(f[i],f[j]+1);\rmxn=std::max(mxn,f[i]);\rifor(j,1,i-1)\rif(f[j]==f[i]\u0026amp;\u0026amp;arr[j]==arr[i])\rc[j]=0;\relse if(arr[i]\u0026lt;arr[j]\u0026amp;\u0026amp;f[j]==f[i]-1)\rc[i]+=c[j];\rif(!c[i]) ++c[i];\r}\rifor(i,1,n)\rif(f[i]==mxn)\rans+=c[i];\rprintf(\u0026quot;%d %d\u0026quot;,mxn,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r   若构成的队列相同则认为属于同一个方案 \u0026#x21a9;\u0026#xfe0e;\n  ","id":35,"section":"posts","summary":"","tags":["动态规划","递推"],"title":"Luogu P1108 低价购买","uri":"https://cs-fil.github.io/2020/03/luogu-p1108/","year":"2020"},{"content":"链接 摘要  对于一个整数 $n$ 的正整数次幂，后 $k$ 位是否发生循环\n若是 求循环长度 $k$ $\\leq$ $100$\n解  从尾部递推\n依次保证 后 $1$ 位循环，后 $2$ 位循环……后 $k$ 位循环\n定义fac在保证原数与之相乘 后 $m$ 位不变的前提下，探究保证第 $m+1$ 位不变的条件\n定义fac_maker以计算fac\n若次数 $cnt \u0026gt; 10$ 可判断不循环\n若 $cnt \u0026lt; 10$，将每一位探究的次数相乘可得到循环长度\n值得注意的是 由数据范围知应使用高精度\ndebug  乘法高精度中c[i+j-1]=a[i]*b[j] c[i+j-1]+=a[i]*b[j]  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=1e4+9,times[10]={1,1,4,4,2,1,1,4,4,2};\rint k;\rint ans[102],ori[102],maiN[inf],fac[inf],fac_maker[inf],tmp[inf];\rchar s[102];\rinline void mul_1(int a[],int b[],int c[])\r{\rifor(i,1,k)\rifor(j,1,k)\rc[i+j-1]+=a[i]*b[j],c[i+j]+=c[i+j-1]/10,c[i+j-1]%=10;\r}\rinline void mul_2(int a[],int b,int c[])\r{\rifor(i,1,k)\rc[i]+=a[i]*b,c[i+1]+=c[i]/10,c[i]%=10;\r}\rint main()\r{\rscanf(\u0026quot;%s%d\u0026quot;,s+1,\u0026amp;k);\rint l=strlen(s+1);\rfor(int i=l;i\u0026gt;=l-k+1;--i)\rori[l-i+1]=s[i]-'0';\rifor(i,1,k) maiN[i]=ori[i];\rifor(i,1,times[ori[1]]-1)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,ori,tmp);\rifor(j,1,k)\rmaiN[j]=tmp[j];\r}\rans[1]=times[ori[1]];\rifor(i,1,k)\rfac[i]=fac_maker[i]=maiN[i];\rint cur=1;\rwhile(++cur\u0026lt;k+1)\r{\rifor(i,1,k)\rmaiN[i]=ori[i];\rint cnt=0;\rwhile(cnt\u0026lt;=10)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,fac,tmp);\r++cnt;\rif(tmp[cur]==ori[cur]) break;\rifor(i,1,k)\rmaiN[i]=tmp[i];\rmemset(tmp,0,sizeof(tmp));\rmul_1(fac_maker,fac,tmp);\rifor(i,1,k)\rfac_maker[i]=tmp[i];\r}\rif(cnt\u0026gt;10) return puts(\u0026quot;-1\u0026quot;),0;\rmemset(tmp,0,sizeof(tmp));\rmul_2(ans,cnt,tmp);\rifor(i,1,100) ans[i]=tmp[i];\rifor(i,1,k) fac[i]=fac_maker[i];\r}\rint kk=100;\rwhile(ans[kk]==0\u0026amp;\u0026amp;kk\u0026gt;1) --kk;\rfor(int i=kk;i\u0026gt;=1;--i)\rprintf(\u0026quot;%d\u0026quot;,ans[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":36,"section":"posts","summary":"","tags":["模拟","递推"],"title":"Luogu P1050 循环","uri":"https://cs-fil.github.io/2020/03/luogu-p1050/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的字符串 $S$\n有 $m$ 个操作，保证 $m\\leq n$\n给定字符串 $T$1 初时为空\n共有以下两种操作\n 在字符串 $T$ 的末尾加上一个字符2 在字符串 $T$ 的开头加上一个字符   $n$ $\\leq$ $10^6$，$m$ $\\leq$ $3.3333$ $\\times$ $10^4$，$|\\Sigma|$ $\\leq$ $10^3$，$S_i$ $\\in$ $[1,|\\Sigma|]。$($\\Sigma$ 表示字符集$)$\n 每次操作完成后要求输出有几个 $l\\in [1,T.size]$ 满足对于 $\\forall i\\in [1,l]$ 有 $T_{T.size-l+i}$ $\\neq$ $S_i$\n解 $17$ $pts$  模拟\n时间复杂度 $O(m^3)$\n$50$ $pts$  $f[i]$ 表示当前 $l=i$ 时是否满足条件\n分别考虑两种情况\n$1.$ $op=0$\n操作之后 每一位会得到新的状态\n不难发现 f[i]继承f[i-1]的true状态的条件为ch==T[i]\n则需将 $ch$ 逐位比对更新状态\n$2.$ $op=1$\n操作之后 对于 $f[j]$$,$$j\\in [1,i-1]$ 的状态没有影响\n仅需考虑新增的 $f[i]$\n将字符串 $T$ 与 $S$ 逐位比对方可得出新增状态\n优化\n1. 定义 $l[]$ $r[]$ 分别表示首增和末增\n2. 对于第 $1$ 种情况 可先继承后判断，$coding$ 时会清楚一些\n值得注意的是 应倒序继承避免覆盖\n 时间复杂度 $O(m^2)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,opn,k,kk,res;\rint s[1000002],l[40002],r[40002],f[40002];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;s[i]);\rifor(i,1,m)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;opn,\u0026amp;k);\rif(opn)\r{\rl[++l[0]]=k;\rint flg=1;\rkk=0;\rfor(int j=l[0];j\u0026gt;=1;--j)\rif(l[j]==s[++kk])\r{flg=0; break;}\rifor(j,1,r[0])\rif(r[j]==s[++kk]||!flg)\r{flg=0; break;}\rres+=(f[i]=flg);\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\relse\r{\rr[++r[0]]=k;\rres=0;\rfor(int j=i;j\u0026gt;=2;--j)\rf[j]=f[j-1];\rf[1]=1;\rifor(j,1,i)\rres+=(f[j]\u0026amp;=(k!=s[j]));\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r $100$ $pts$  沿用 $50 pts$ 的思路，使用位运算进行优化\n定义 $01$数组 $id[i]$ 表示字符 $i$ 在字符串 $S$ 中的比对情况\n分别考虑两种情况\n$1.$ $op=0$\nf=f\u0026lt;\u0026lt;1|id[k]即继承状态并考虑 $ch$ 的比对情况\n$2.$ $op=1$\nf|=id[k]\u0026lt;\u0026lt;(i-1)即把比对状态更新至对应的 $l$ 处\n举个例子:\n$213$ 首先读取 $2$ 的比对状态 而归于 $l=3$ 的范畴\n输出时用一个 $01$ 数限制位数，~(f|now)中 $0$ 的个数即为所求\n 使用位运算对未来的状态进行了规划，是一个长远的考虑\n 优化\n引入压位优化的 $01$ 数组 $bitset$\n 时间复杂度 $O(m^2/w)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;bitset\u0026gt;\r#include\u0026lt;cstdlib\u0026gt; #include\u0026lt;cctype\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rconst int inf=1e6+2;\rint n,m,opn,k;\rint it[inf];\rstd::bitset\u0026lt;35000\u0026gt; id[1002],f,now;\rinline int read(){\rint res=0;\rchar ch;\rwhile(isspace(ch=getchar()));\rdo\r{\rres=(res\u0026lt;\u0026lt;1)+(res\u0026lt;\u0026lt;3)+(ch^48);\r}while(isdigit(ch=getchar()));\rreturn res;\r}\rint main()\r{\rn=read(),m=read();\rifor(i,1,n)\rit[i]=read();\rifor(i,1,m)\rid[it[i]].set(i);\rnow.set();\rifor(i,1,m)\r{\ropn=read(),k=read();\rnow.reset(i);\rif(!opn)\rf=f\u0026lt;\u0026lt;1|id[k];\relse f|=id[k]\u0026lt;\u0026lt;(i-1);\rprintf(\u0026quot;%d\\n\u0026quot;,(~(f|now)).count());\r}\rreturn 0;\r}\r   字符串下标从 $1$ 开始 \u0026#x21a9;\u0026#xfe0e;\n 此处字符可能不止一位 \u0026#x21a9;\u0026#xfe0e;\n  ","id":37,"section":"posts","summary":"","tags":["位运算"],"title":"Luogu P5640 【CSGRound2】逐梦者的初心","uri":"https://cs-fil.github.io/2020/03/luogu-p5640/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i$ \u0026amp; $b[i-1]$$\\neq$$0$，其中 $2$ $\\leq$ $i$ $\\leq$ $k$\n$1$ $\\leq$ $n$ $\\leq$ $100000$，$a_i$ $\\leq$ $10^9$\n解  定义 $f[i]$ 表示当前最后一项的第 $i$ 位为 $1$ 的最大子序列长度\n当 $a$ \u0026amp; $b$$\\neq$$0$，即 $ab$ 有相同的一位为 $1$，根据此性质进行转移\n在读入的过程中进行处理\n 若该数第 $i$ 位为 $1$，由于所定义的 $dp$ 数组的性质，转移时即为f[i]+1 取其中的最大值，再对其余数组进行更新，即 $k=max${$f[i]+1$} f[i]=k保证各个数组符合其性质  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,mxn;\rint f[30];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint t;\rwhile(n--)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rint k=1;\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rk=std::max(f[i]+1,k);\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rf[i]=k;\rmxn=std::max(mxn,k);\r}\rprintf(\u0026quot;%d\u0026quot;,mxn);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":38,"section":"posts","summary":"","tags":["位运算","动态规划"],"title":"Luogu P4310 绝世好题","uri":"https://cs-fil.github.io/2020/03/luogu-p4310/","year":"2020"},{"content":"链接 摘要  求数值 $k$$\\in$$[1,m]$ 经过 $n$ 次 $op$ $t$ 操作后的最大值\n $2\\leq n\\leq10^5$ $2\\leq m\\leq10^9$ $0\\leq t\\leq10^9$ $op$ 一定为 $or$ $xor$ $and$ 中的一种\n解  定义k1=0x7fffffff k2=0\n从二进制来看 $k1$ 每一位都是 $1$,$k2$ 每一位都是 $0$\n输入的过程中直接对 $k1$ $k2$ 进行操作\n对于第 $i$ 位 遵循贪心原则 $:$\n 若k2==1则ans+=1\u0026lt;\u0026lt;i 初始值的第 $i$ 位为 $0$ 或若k1==1则需考虑若初始值的第 $i$ 位为 $1$ 是否超出初始值范围 若否再而累加  debug  ans累加ans|=1\u0026lt;\u0026lt;i ans+=1\u0026lt;\u0026lt;i\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,t,ans,k1=0x7fffffff,k2=0;\rchar str[3];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\r{\rscanf(\u0026quot;%s%d\u0026quot;,str,\u0026amp;t);\rif(str[0]=='O') k1|=t,k2|=t;\rif(str[0]=='X') k1^=t,k2^=t;\rif(str[0]=='A') k1\u0026amp;=t,k2\u0026amp;=t;\r}\rfor(int i=29;~i;--i)\r{\rif(k2\u0026gt;\u0026gt;i\u0026amp;1) ans+=1\u0026lt;\u0026lt;i;\relse if(k1\u0026gt;\u0026gt;i\u0026amp;1\u0026amp;\u0026amp;m\u0026gt;=1\u0026lt;\u0026lt;i)\rans+=1\u0026lt;\u0026lt;i,m-=1\u0026lt;\u0026lt;i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":39,"section":"posts","summary":"","tags":["位运算","贪心"],"title":"Luogu P2114 [NOI2014]起床困难综合症","uri":"https://cs-fil.github.io/2020/03/luogu-p2114/","year":"2020"},{"content":"链接 摘要  $n$ 皇后问题\n $0\\lt n\\leq14$\n解  据数据范围 直接搜索会 $tle$\n使用位运算可以达到优化的目的\nmxstt即为列放置最终状态\n 构造函数dfs(cstt,l,r,ln)\n递归边界cstt==mxstt\n k=~(cstt|l|r|ln)\u0026amp;mxstt以获取改行状态\nlowbit(k)以列举可放置列 cstt表示列放置状态 $0$ 可放置 $1$ 不可放置\ncstt|lowbit(k) 以转移 l r分别表示左斜 右斜的状态 $01$ 义同上\n(l|lowbit(k))\u0026gt;\u0026gt;1 (r|lowbit(k))\u0026lt;\u0026lt;1以转移 ln表示当前行数\nln+1以转移   即dfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1)\ndebug  设置一个 $n$ 位二进制数的第 $k$ 位为 $1$ x|=k x|=1\u0026lt;\u0026lt;n-k l r的转移 (l|cstt)\u0026gt;\u0026gt;1 (l|lowbit(k))\u0026gt;\u0026gt;1 尤其注意用maxstate限制二进制位数  $Q$$\u0026amp;$$A$  $Q:$ 为什么不可以用单个状态stt 而是使用 $4$ 个变量推导状态 $？$\n$A:$ 因为左斜 右斜的转移方式与列放置状态的转移方式不同 $。$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint n,ans,mxstt;\rint stt[20];\rchar s[15];\rinline int lowbit(int x)\r{\rreturn x\u0026amp;-x;\r}\rinline void dfs(int cstt,int l,int r,int ln)\r{\rif(cstt==mxstt) {ans++; return;}\rint k=~(cstt|l|r|stt[ln])\u0026amp;mxstt;\rwhile(lowbit(k))\r{\rdfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1);\rk^=lowbit(k);\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rmxstt=(1\u0026lt;\u0026lt;n)-1;\rifor(i,1,n)\r{\rscanf(\u0026quot;%s\u0026quot;,s+1);\rifor(j,1,n)\rif(s[j]=='.')\rstt[i]|=(1\u0026lt;\u0026lt;n-j);\r}\rdfs(0,0,0,1);\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":40,"section":"posts","summary":"","tags":["位运算","搜索"],"title":"Luogu P1562 还是N皇后","uri":"https://cs-fil.github.io/2020/03/luogu-p1562/","year":"2020"},{"content":" $blog$ 建于 $2020.1.30$\n$aim:$ 每日 $4$ $AC$ 至 $2020$ $10$ 月下旬达成 $1000$ $AC\n","id":41,"section":"posts","summary":"","tags":["随笔"],"title":"2020 目标","uri":"https://cs-fil.github.io/2020/01/blog/","year":"2020"}],"tags":[{"title":"Hash","uri":"https://cs-fil.github.io/tags/hash/"},{"title":"Huffman","uri":"https://cs-fil.github.io/tags/huffman/"},{"title":"KMP","uri":"https://cs-fil.github.io/tags/kmp/"},{"title":"LCA","uri":"https://cs-fil.github.io/tags/lca/"},{"title":"manacher","uri":"https://cs-fil.github.io/tags/manacher/"},{"title":"STL","uri":"https://cs-fil.github.io/tags/stl/"},{"title":"thoughts","uri":"https://cs-fil.github.io/tags/thoughts/"},{"title":"二分","uri":"https://cs-fil.github.io/tags/%E4%BA%8C%E5%88%86/"},{"title":"二叉堆","uri":"https://cs-fil.github.io/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"},{"title":"优先队列","uri":"https://cs-fil.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"title":"位运算","uri":"https://cs-fil.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"倍增","uri":"https://cs-fil.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"title":"动态规划","uri":"https://cs-fil.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"单调队列","uri":"https://cs-fil.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"title":"字符串","uri":"https://cs-fil.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"字符串Hash","uri":"https://cs-fil.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2hash/"},{"title":"差分","uri":"https://cs-fil.github.io/tags/%E5%B7%AE%E5%88%86/"},{"title":"拓扑排序","uri":"https://cs-fil.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"排序","uri":"https://cs-fil.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"title":"搜索","uri":"https://cs-fil.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"title":"数学","uri":"https://cs-fil.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"title":"枚举","uri":"https://cs-fil.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"title":"栈","uri":"https://cs-fil.github.io/tags/%E6%A0%88/"},{"title":"模拟","uri":"https://cs-fil.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"title":"欧拉定理","uri":"https://cs-fil.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"title":"矩阵乘法","uri":"https://cs-fil.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"title":"离散化","uri":"https://cs-fil.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"title":"线性递推","uri":"https://cs-fil.github.io/tags/%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"},{"title":"贪心","uri":"https://cs-fil.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"title":"费马小定理","uri":"https://cs-fil.github.io/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"title":"递推","uri":"https://cs-fil.github.io/tags/%E9%80%92%E6%8E%A8/"},{"title":"链表","uri":"https://cs-fil.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"title":"随笔","uri":"https://cs-fil.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}