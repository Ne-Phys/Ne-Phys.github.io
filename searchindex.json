{"categories":[{"title":"thoughts","uri":"https://cs-fil.github.io/categories/thoughts/"},{"title":"文","uri":"https://cs-fil.github.io/categories/%E6%96%87/"},{"title":"知识点","uri":"https://cs-fil.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"题解","uri":"https://cs-fil.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"posts":[{"content":"没有想过，半年前，我的激励竟然要杀了我。 就此吧，还有一整年，别低头，还有好多路可以走的，为时不晚一定。\n","id":0,"section":"posts","summary":"","tags":["thoughts"],"title":"有思","uri":"https://cs-fil.github.io/2021/01/%E6%9C%89%E6%80%9D/","year":"2021"},{"content":"链接 摘要  字符串 $s$ 的最长回文子串\n解  $O(nlogn)$\n关于字符串$Hash$:\n视作 $P$ 进制数, $P$ 取 $131$, $13331$ 冲突最少\null 自然取模, 规避模运算的高复杂度\n求子串的 $Hash$ 类似前缀和的思想 $s[j]-s[i-1]*$$P^{j-i+1}$\n分奇偶两种情况, 枚举中间点, 二分回文半径\n$O(n)$\n$manacher$ 算法\n对奇偶性的处理: 在字符间添加 '#'\n对边界的处理: $s[0]=$ '!', $s[l+2]=$ \u0026lsquo;^\u0026rsquo; $(s[l]=a[n],s[1]=s[l+1]=$ '#' $)$\n维护当前最大回文串的中心字符下标 $mid$ 、回文串右边界下标\n遍历字符串, 若下标 $i$$\u0026lt;$$r$, 则可运用中点公式查找关于 $mid$ 对称位置的回文半径\n对称位置的回文半径有三种情况:\n1.j-f[j] 未抵左边界, 则直接可以确定 f[i]=f[j](若扩展, 对称后与之前确定的矛盾)\n2.j-f[j] 恰抵左边界, 此时 f[i] 在 f[j] 的基础上扩展\n3.j-f[j] 越过左边界, 则也可以直接确定 f[i]=r-i+1(若扩展, 则非最大回文串)\n在这一基础上进一步分析复杂度:\nfor 循环 $n$ 次\n情况1、3: $O(1)$\n情况2:\nwhile 受 $r$ 制约, $r$ 依据 $i+k$, $i+k$ 在 $r$ 的基础之上递增\n相当于 $r$ 为 $i+k$ 存点, 循环下一个字符时要么读取存点, 要么新增并再存点\n=\u0026gt; while 循环 $n$ 次\n复杂度即是 $2n$ $=$ $O(n)$\n代码  字符串 $Hash$\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define max(a,b) ((a)\u0026gt;(b)?(a):(b))\r#define min(a,b) ((a)\u0026lt;(b)?(a):(b))\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef unsigned long long ull;\rconst int N=1e6+5,P=131;\rint lnth;\rchar s[N];\rull a[N],b[N],p[N];\rinline bool judge(int x,int l)\r{\rull a1=a[x+l]-a[x]*p[l];\rull b1=b[lnth-x+1+l]-b[lnth-x+1]*p[l];\rif(a1==b1)\rreturn true;\relse return false;\r}\rinline bool judge2(double x,int l)\r{\rull a1=a[(int)(x+l-0.5)]-a[(int)(x-0.5)]*p[l];\rull b1=b[(int)(lnth-x+0.5+l)]-b[(int)(lnth-x+0.5)]*p[l];\rif(a1==b1)\rreturn true;\relse return false;\r}\rint main()\r{\rp[0]=1;\rifor(i,1,1000000)\rp[i]=p[i-1]*P;\rint c=0;\rwhile(scanf(\u0026quot;%s\u0026quot;,s+1))\r{\r++c;\rif(s[1]=='E')\rbreak;\rlnth=strlen(s+1);\rifor(i,1,lnth)\r{\ra[i]=a[i-1]*P+(s[i]-'a'+1);\rb[i]=b[i-1]*P+(s[lnth-i+1]-'a'+1);\r}\rint mxn=1;\rifor(i,1,lnth)\r{\rint r=min(i-1,lnth-i),l=0;\rwhile(l\u0026lt;r)\r{\rint mid=(l+r+1)\u0026gt;\u0026gt;1;\rif(judge(i,mid))\rl=mid;\relse r=mid-1;\r}\rmxn=max(mxn,l*2+1);\r}\rfor(double i=0.5;i\u0026lt;=lnth-0.5;++i)\r{\rint r=min(i-0.5,lnth-i+0.5),l=0;\rwhile(l\u0026lt;r)\r{\rint mid=(l+r+1)\u0026gt;\u0026gt;1;\rif(judge2(i,mid))\rl=mid;\relse r=mid-1;\r}\rmxn=max(mxn,l*2);\r}\rprintf(\u0026quot;Case %d: %d\\n\u0026quot;,c,mxn);\r}\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r  $manacher$\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define max(a,b) ((a)\u0026gt;(b)?(a):(b))\r#define min(a,b) ((a)\u0026lt;(b)?(a):(b))\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef unsigned long long ull;\rconst int N=2e6+5,P=131;\rchar s[N],con[N];\rint f[N];\rint main()\r{\rint id=0;\rwhile(scanf(\u0026quot;%s\u0026quot;,s+1)\u0026amp;\u0026amp;s[1]!='E')\r{\rid++;\rint l=strlen(s+1);\rcon[0]='$';\rint c=0;\rifor(i,1,l)\rcon[++c]='#',con[++c]=s[i];\rcon[++c]='#',con[c+1]='^';\rint r=0,mid=0;\rint mxn=1;\rifor(i,1,c-1)\r{\rif(i\u0026lt;r)\rf[i]=min(f[2*mid-i],r-i+1);\relse f[i]=1;\rwhile(con[i+f[i]]==con[i-f[i]])\rf[i]++;\rif(r\u0026lt;i+f[i]-1)\rmid=i,r=i+f[i]-1;\rmxn=max(mxn,f[i]-1);\r}\rprintf(\u0026quot;Case %d: %d\\n\u0026quot;,id,mxn);\r} system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":1,"section":"posts","summary":"","tags":["字符串Hash","manacher"],"title":"POJ 3974 Palindrome","uri":"https://cs-fil.github.io/2020/12/poj-3974/","year":"2020"},{"content":"Linear Work Suffix Array Construction Juha K¨arkk¨ainen∗ Peter Sanders† Stefan Burkhardt‡ Abstract Suffix trees and suffix arrays are widely used and largely interchangeable index structures on strings and sequences. Practitioners prefer suffix arrays due to their simplicity and space efficiency while theoreticians use suffix trees due to linear-time construction algorithms and more explicit structure. We narrow this gap between theory and practice with a simple linear-time construction algorithm for suffix arrays. The simplicity is demonstrated with a C++ implementation of 50 effective lines of code. The algorithm is called DC3, which stems from the central underlying concept of difference cover. This view leads to a generalized algorithm, DC, that allows a space-efficient implementation and, moreover, supports the choice of a space–time tradeoff. For any v ∈ [1, √ n], it runs in O(vn) time using O(n/√ v) space in addition to the input string and the suffix array. We also present variants of the algorithm for several parallel and hierarchical memory models of computation. The algorithms for BSP and EREW-PRAM models are asymptotically faster than all previous suffix tree or array construction algorithms. 1 Introduction The suffix tree [60] of a string is the compact trie of all its suffixes. It is a powerful data structure with numerous applications in computational biology [28] and elsewhere [26]. It can be constructed in linear time in the length of the string [16, 19, 48, 57, 60]. The suffix array [24, 45] is the lexicographically sorted array of the suffixes of a string. It contains much the same information as the suffix tree, although in a more implicit form, but is a simpler and more compact data structure for many applications [2, 7, 24, 45]. However, until recently, the only linear-time construction algorithm was based on a lexicographic traversal of the suffix tree. ∗Department of Computer Science, P.O.Box 68 (Gustaf H¨allstr¨omin katu 2b) FI-00014 University of Helsinki, Finland, juha.karkkainen@cs.helsinki.fi. Supported by the Academy of Finland grant 201560. †Universit¨at Karlsruhe, 76128 Karlsruhe, Germany, sanders@ira.uka.de. ‡Google Inc, 1600 Amphitheatre Parkway, 94043 Mountain View, CA, USA, Burkhardt@ Google.com. 1 Due to a more explicit structure and the direct linear-time construction algorithms, theoreticians tend to prefer suffix trees over suffix arrays. This is evident, for example, in text books, including recent ones [13, 56]. Practitioners, on the other hand, often use suffix arrays, because they are more space-efficient and simpler to implement. This difference of theoretical and practical approaches appears even within a single paper [50]. We address the gap between theory and practice by describing the first direct linear-time suffix array construction algorithm, elevating suffix arrays to equals of suffix trees in this sense. Independently and simultaneously to our result, which originally appeared in [36], two different linear-time algorithms were introduced by Kim et al. [40], and Ko and Aluru [41]. In this paper, we will also introduce several extensions and generalizations of the algorithm, including space-efficient, parallel and external memory variants. Linear-time algorithm. Many linear-time suffix tree construction algorithms are truly linear-time only for constant alphabet, i.e, when the size of the alphabet is constant [48, 57, 60]. Farach [16] introduced the first algorithm to overcome this restriction; it works in linear-time for integer alphabet, i.e., when the characters are integers from a linear-sized range. This is a significant improvement, since a string over any alphabet can be transformed into such a string by sorting the characters and replacing them with their ranks. This preserves the structure of the suffix tree and the order of the suffixes. Consequently, the complexity of constructing the suffix tree of a string is the same as the complexity of sorting the characters of the string [19]. Whereas the algorithms requiring a constant alphabet are incremental, adding one suffix or one character at a time to the tree, Farach’s algorithm takes the following half-recursive divide-and-conquer approach:\n Construct the suffix tree of the suffixes starting at odd positions. This is done by reduction to the suffix tree construction of a string of half the length, which is solved recursively. Construct the suffix tree of the remaining suffixes using the result of the first step. Merge the two suffix trees into one. The crux of the algorithm is the merging step, which is an intricate and complicated procedure. The same structure appears in some parallel and external memory suffix tree construction algorithms [17, 18, 19] as well as the direct linear-time suffix array construction algorithm of Kim et al. [40]. In all cases, the merge is a very complicated procedure. The linear-time suffix array construction algorithm of Ko and Aluru [41] 2 also uses the divide-and-conquer approach of first sorting a subset or sample of suffixes by recursion. However, its choice of the sample and the rest of the algorithm are quite different. We introduce a linear-time suffix array construction algorithm following the structure of Farach’s algorithm but using 2/3-recursion instead of half-recursion: Construct the suffix array of the suffixes starting at positions i mod 3 6= 0. This is done by reduction to the suffix array construction of a string of two thirds the length, which is solved recursively. Construct the suffix array of the remaining suffixes using the result of the first step. Merge the two suffix arrays into one. Surprisingly, the use of two thirds instead of half of the suffixes in the first step makes the last step almost trivial: simple comparison-based merging is sufficient. For example, to compare suffixes starting at i and j with i mod 3 = 0 and j mod 3 = 1, we first compare the initial characters, and if they are the same, we compare the suffixes starting at i + 1 and j + 1, whose relative order is already known from the first step. Space-efficient algorithms. All the above suffix array construction algorithms require at least n pointers or integers of extra space in addition to the n characters of the input and the n pointers/integers of the suffix array. Until recently, this was true for all algorithms running in O(n log n) time. There are also so-called lightweight algorithms that use significantly less extra space [47, 4], but their worst-case time complexity is Ω(n 2 ). Manzini and Ferragina [47] have raised the question of whether it is possible to achieve O(n log n) runtime using sublinear extra space. The question was answered positively by Burkhardt and K¨arkk¨ainen [6] with an algorithm running in O(n log n) time and O(n/√ log n) extra space. They also gave a generalization running in O(n log n + nv) time and O(n/√ v) extra space for any v ∈ [3, n]. In this paper, combining ideas from [6] with the linear-time algorithm, we improve the result to O(nv) time in O(n/√ v) extra space, leading to an o(n log n) time and o(n) extra space algorithm. To achieve the result, we generalize the linear-time algorithm so that the sample of suffixes sorted in the first step can be chosen from a family, called the difference cover samples, that includes arbitrarily sparse samples. This family was introduced in [6] and its name comes from a characterization using the concept of difference cover. Difference covers have also been used for VLSI design [39], distributed mutual exclusion [44, 10], and quantum computing [5]. An even more space-efficient approach is to construct compressed indexes [21, 27, 42, 31, 32]. However, for constant v our algorithm is a factor of at least Θ(log log σ) faster than these algorithms, where σ is the alphabet size. 3 Table 1: Suffix array construction algorithms. The algorithms in [16, 17, 18, 19] are indirect, i.e., they actually construct a suffix tree, which can be then be transformed into a suffix array model of computation complexity alphabet source RAM O(n log n) time general [45, 43, 6] O(n) time integer [16, 40, 41],DC External Memory [59] D disks, block size B, fast memory of size M O( n DB log M B n B log n) I/Os O(n log M B n B log n) internal work integer [12] O( n DB log M B n B ) I/Os O(n log M B n B ) internal work integer [19],DC Cache Oblivious [22] M/B cache blocks of size B O( n B log M B n B log n) cache faults general [12] O( n B log M B n B ) cache faults general [19],DC BSP [58] P processors h-relation in time L + gh O( n log n P + (L + gn P ) log3 n log P log(n/P) ) time general [17] O( n log n P + L log2 P + gn log n P log(n/P) ) time general DC P = O(n 1−\u000f ) processors O(n/P + L log2 P + gn/P) time integer DC EREW-PRAM [33] O(log4 n) time, O(n log n) work general [17] O(log2 n) time, O(n log n) work general DC arbitrary-CRCW-PRAM [33]O(log n) time, O(n) work (rand.) constant [18] priority-CRCW-PRAM [33] O(log2 n) time, O(n) work (rand.) constant DC Advanced models of computation. Since our algorithm is constructed from well studied building blocks like integer sorting and merging, simple direct suffix array construction algorithms for several models of computation are almost a corollary. Table 1 summarizes these results. We win a factor Θ(log n) over the previously best direct external memory algorithm. For BSP and EREW-PRAM models, we obtain an improvement over all previous results, including the first linear work BSP algorithm. 4 Overview. The paper is organized as follows. Section 3 explains the basic linear time algorithm DC3. We then use the concept of a difference cover introduced in Section 4 to describe a generalized algorithm called DC in Section 5 that leads to a space efficient algorithm in Section 6. Section 7 explains implementations of the DC3 algorithm in advanced models of computation. The results together with some open issues are discussed in Section 8. 2 Notation We use the shorthands [i, j] = {i, . . . , j} and [i, j) = [i, j − 1] for ranges of integers and extend to substrings as seen below. The input of a suffix array construction algorithm is a string T = T[0, n) = t0t1 · · ·tn−1 over the alphabet [1, n], that is, a sequence of n integers from the range [1, n]. For convenience, we assume that tj = 0 for j ≥ n. Sometimes we also assume that n + 1 is a multiple of some constant v or a square to avoid a proliferation of trivial case distinctions and d·e operations. An implementation will either spell out the case distinctions or pad (sub)problems with an appropriate number of zero characters. The restriction to the alphabet [1, n] is not a serious one. For a string T over any alphabet, we can first sort the characters of T, remove duplicates, assign a rank to each character, and construct a new string T 0 over the alphabet [1, n] by renaming the characters of T with their ranks. Since the renaming is order preserving, the order of the suffixes does not change. For i ∈ [0, n], let Si denote the suffix T[i, n) = titi+1 · · ·tn−1. We also extend the notation to sets: for C ⊆ [0, n], SC = {Si | i ∈ C}. The goal is to sort the set S[0,n] of suffixes of T, where comparison of substrings or tuples assumes the lexicographic order throughout this paper. The output is the suffix array SA[0, n] of T, a permutation of [0, n] satisfying SSA[0] \u0026lt; SSA[1] \u0026lt; · · · \u0026lt; SSA[n] . 3 Linear-time algorithm We begin with a detailed description of the simple linear-time algorithm, which we call DC3 (for Difference Cover modulo 3, see Section 4). A complete implementation in C++ is given in Appendix A. The execution of the algorithm is illustrated with the following example 0 1 2 3 4 5 6 7 8 9 10 11 T[0, n) = y a b b a d a b b a d o where we are looking for the suffix array SA = (12, 1, 6, 4, 9, 3, 8, 2, 7, 5, 10, 11, 0) . 5 Step 0: Construct a sample. For k = 0, 1, 2, define Bk = {i ∈ [0, n] | i mod 3 = k}. Let C = B1 ∪ B2 be the set of sample positions and SC the set of sample suffixes. Example. B1 = {1, 4, 7, 10}, B2 = {2, 5, 8, 11}, i.e., C = {1, 4, 7, 10, 2, 5, 8, 11}. Step 1: Sort sample suffixes. For k = 1, 2, construct the strings Rk = [tktk+1tk+2][tk+3tk+4tk+5] . . . [tmax Bk tmax Bk+1tmax Bk+2] whose characters are triples [titi+1ti+2]. Note that the last character of Rk is always unique because tmax Bk+2 = 0. Let R = R1 R2 be the concatenation of R1 and R2. Then the (nonempty) suffixes of R correspond to the set SC of sample suffixes: [titi+1ti+2][ti+3ti+4ti+5] . . . corresponds to Si . The correspondence is order preserving, i.e., by sorting the suffixes of R we get the order of the sample suffixes SC. Example. R = [abb][ada][bba][do0][bba][dab][bad][o00]. To sort the suffixes of R, first radix sort the characters of R and rename them with their ranks to obtain the string R0 . If all characters are different, the order of characters gives directly the order of suffixes. Otherwise, sort the suffixes of R0 using Algorithm DC3. Example. R0 = (1, 2, 4, 6, 4, 5, 3, 7) and SAR0 = (8, 0, 1, 6, 4, 2, 5, 3, 7). Once the sample suffixes are sorted, assign a rank to each suffix. For i ∈ C, let rank(Si) denote the rank of Si in the sample set SC. Additionally, define rank(Sn+1) = rank(Sn+2) = 0. For i ∈ B0, rank(Si) is undefined. Example. i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rank(Si) ⊥ 1 4 ⊥ 2 6 ⊥ 5 3 ⊥ 7 8 ⊥ 0 0 Step 2: Sort nonsample suffixes. Represent each nonsample suffix Si ∈ SB0 with the pair (ti , rank(Si+1)). Note that rank(Si+1) is always defined for i ∈ B0. Clearly we have, for all i, j ∈ B0, Si ≤ Sj ⇐⇒ (ti , rank(Si+1)) ≤ (tj , rank(Sj+1)). The pairs (ti , rank(Si+1)) are then radix sorted. Example. S12 \u0026lt; S6 \u0026lt; S9 \u0026lt; S3 \u0026lt; S0 because (0, 0) \u0026lt; (a, 5) \u0026lt; (a, 7) \u0026lt; (b, 2) \u0026lt; (y, 1). 6 Step 3: Merge. The two sorted sets of suffixes are merged using a standard comparison-based merging. To compare suffix Si ∈ SC with Sj ∈ SB0 , we distinguish two cases: i ∈ B1 : Si ≤ Sj ⇐⇒ (ti , rank(Si+1)) ≤ (tj , rank(Sj+1)) i ∈ B2 : Si ≤ Sj ⇐⇒ (ti ,ti+1, rank(Si+2)) ≤ (tj ,tj+1, rank(Sj+2)) Note that the ranks are defined in all cases. Example. S1 \u0026lt; S6 because (a, 4) \u0026lt; (a, 5) and S3 \u0026lt; S8 because (b, a, 6) \u0026lt; (b, a, 7). The time complexity is established by the following theorem. Theorem 1. The time complexity of Algorithm DC3 is O(n). Proof. Excluding the recursive call, everything can clearly be done in linear time. The recursion is on a string of length d2n/3e. Thus the time is given by the recurrence T(n) = T(2n/3) + O(n), whose solution is T(n) = O(n). 4 Difference cover sample The sample of suffixes in DC3 is a special case of a difference cover sample. In this section, we describe what difference cover samples are, and in the next section we give a general algorithm based on difference cover samples. The sample used by the algorithms has to satisfy two sample conditions: The sample itself can be sorted efficiently. Only certain special cases are known to satisfy this condition (see [37, 3, 9, 41] for examples). For example, a random sample would not work for this reason. Difference cover samples can be sorted efficiently because they are periodic (with a small period). Steps 0 and 1 of the general algorithm could be modified for sorting any periodic sample of size m with period length v in O(vm) time. The sorted sample helps in sorting the set of all suffixes. The set of difference cover sample positions has the property that for any i, j ∈ [0, n − v + 1] there is a small such that both i + and j +  are sample positions. See Steps 2–4\rin Section 5 for how this property is utilized in the algorithm.\rThe difference cover sample is based on difference covers [39, 10].\rDefinition 1. A set D ⊆ [0, v) is a difference cover modulo v if\r{(i − j) mod v | i, j ∈ D} = [0, v) .\r7\rDefinition 2. A v-periodic sample C of [0, n] with the period D, i.e.,\rC = {i ∈ [0, n] | i mod v ∈ D} ,\ris a difference cover sample if D is a difference cover modulo v.\rBy being periodic, a difference cover sample satisfies the first of the sample\rconditions. That it satisfies the second condition is shown by the following lemma.\rLemma 1. If D is a difference cover modulo v, and i and j are integers, there exists\r ∈ [0, v) such that (i + ) mod v and (j + ) mod v are in D. Proof. By the definition of difference cover, there exists i 0 , j 0 ∈ D such that i 0 −j 0 ≡ i − j (mod v). Let = (i\r0 − i) mod v. Then\ri + ≡ i 0 ∈ D (mod v) j + ≡ i\r0 − (i − j) ≡ j\r0 ∈ D (mod v) .\rNote that by using a lookup table of size v that maps (i − j) mod v into i\r0\r, the\rvalue can be computed in constant time. The size of the difference cover is a key parameter for the space-efficient algorithm in Sections 6. Clearly, √ v is a lower bound. The best general upper bound that we are aware of is achieved by a simple algorithm due to Colbourn and Ling [10]: Lemma 2 ([10]). For any v, a difference cover modulo v of size at most √ 1.5v + 6 can be computed in O( √ v) time. The sizes of the smallest known difference covers for several period lengths are shown in Table 2. Table 2: The size of the smallest known difference cover D modulo v for several period lengths v. The difference covers were obtained from [44] (v ≤ 64) and [6] (v = 128, 256), or computed using the algorithm of Colbourn and Ling [10] (v ≥ 512). For v ≤ 128, the sizes are known to be optimal v 3 7 13 21 31 32 64 128 256 512 1024 2048 |D| 2 3 4 5 6 7 9 13 20 28 40 58 5 General algorithm The algorithm DC3 sorts suffixes with starting positions in a difference cover sample modulo 3 and then uses these to sort all suffixes. In this section, we present a generalized algorithm DC that can use any difference cover D modulo v. 8 Step 0: Construct a sample. For k ∈ [0, v), define Bk = {i ∈ [0, n] | i mod v = k}. The set of sample positions is now C = S k∈D Bk. Let D¯ = [0, v) \\ D and C¯ = [0, n] \\ C. Step 1: Sort sample suffixes. For k ∈ D, construct the strings Rk = [tktk+1 . . .tk+v−1][tk+vtk+v+1 . . .tk+2v−1] . . . [tmax Bk . . .tmax Bk+v−1]. Let R = J k∈D Rk, where J denotes a concatenation. The (nonempty) suffixes of R correspond to the sample suffixes, and they are sorted recursively (using any period length from 3 to (1 − \u000f)v 2/|D| to ensure the convergence of the recursion). Let rank(Si) be defined as in DC3 for i ∈ C, and additionally define rank(Sn+1) = rank(Sn+2) = · · · = rank(Sn+v−1) = 0. Again, rank(Si) is undefined for i ∈ C¯. Step 2: Sort nonsample suffixes. Sort each SBk , k ∈ D¯, separately. Let k ∈ D¯ and let ∈ [0, v) be such that (k +) mod v ∈ D. To sort SBk , represent each suffix Si ∈ SBk with the tuples (ti ,ti+1, . . . ,ti+−1, rank(Si+)). Note that the rank is always defined. The tuples are then radix sorted. The most straightforward generalization of DC3 would now merge the sets SBk , k ∈ D¯. However, this would be a Θ(v)-way merging with O(v)-time comparisons giving O(nv log v) time complexity. Therefore, we take a slightly different approach. Step 3: Sort by first v characters. Separate the sample suffixes SC into sets SBk , k ∈ D, keeping each set ordered. Then we have all the sets SBk , k ∈ [0, v), as sorted sequences. Concatenate these sequences and sort the result stably by the first v characters. For α ∈ [0, n] v , let S α be the set of suffixes starting with α, and let S α Bk = S α ∩ SBk . The algorithm has now separated the suffixes into the sets S α Bk , each of which is correctly sorted. The sets are also grouped by α and the groups are sorted. For v = 3, the situation could look like this: S aaa B0 S aaa B1 S aaa B2 S aab B0 S aab B1 S aab B2 S aac B0 · · · Step 4: Merge. For each α ∈ [0, n] v , merge the sets S α Bk , k ∈ [0, v), into the set S α . This completes the sorting. The merging is done by a comparison-based v-way merging. For i, j ∈ [0, n], let ∈ [0, v) be such that (i +) mod v and (j + ) mod v are both in D. Suffixes\rSi and Sj are compared by comparing rank(Si+) and rank(Sj+). This gives the\rcorrect order because Si and Sj belong to the same set S\rα and thus titi+1 . . .ti+−1 = tj tj+1 . . .tj+−1.\rTheorem 2. The time complexity of Algorithm DC is O(vn).\r9\r6 Lightweight algorithm\rWe now explain how to implement algorithm DC using only O(n/√\rv) space in\raddition to the input and the output. We will however reuse the space for the\routput array a[0, n] as intermediate storage.\rStep 0:. The sample can be represented using their O(n/√\rv) starting positions.\rStep 1:. To sort the sample suffixes, we first (non-inplace) radix sort the v-tuples\rthat start at sample positions. This is easy using two arrays of size O(n/√\rv) for\rstoring starting positions of samples and n + 1 counters (one for each character)\rstored in the output array a[0, n]. This is analogous to the arrays R, SA12 and c\rused in Appendix A. Renaming the tuples with ranks only needs the O(n/√\rv) space\rfor the recursive subproblem. The same space bound applies to the suffix array of\rthe sample and the space needed within the recursive call.\rStep 2:. Sorting nonsample suffixes for a particular class SBk\r, k ∈ D¯ amounts to\rradix sorting (n + 1)/v many tuples of up to v integers in the range [0, n]. Similar\rto Step 1, we need only space O(n/v) for describing these tuples. However, we now\rarrange the sorted tuples in a[k(n + 1)/v,(k + 1)(n + 1)/v) so that the output array\ris not available for counters as in Step 1. We solve this problem by viewing each\rcharacter as two subcharacters in the range [0,\r√\rn + 1).\rStep 3: Sort by first v characters. Scan the suffix array of the sample and store\rthe sample suffixes SBk\r, k ∈ C in a[k(n+1)/v,(k+1)(n+1)/v) maintaining the order\rgiven by the sample within each class SBk\r. Together with the computation in Step 2,\rthe output array now stores the desired concatenation of all sorted sets SBk\r. We\rnow sort all suffixes stably by their first v characters. Using a counter array of size\rO(\r√\rn) we can do that in 2v passes, total time O(vn), and additional space O(n\r3/4\r)\rby applying the almost inplace distribution sorting algorithm from Theorem 5 in\rthe appendix with k =\r√\rn + 1. Note that for v = O(\r√\rn), n\r3/4 = O(n/√\rv).\rStep 4: Merge. Suppose S\rα\ris stored in a[b, b\r0\r). This array consists of v consecutive (possibly empty) subarrays that represent S\rα\rBk\r, k ∈ [0, v) respectively.\rWe can merge them with O(\rp\r|Sα|v) additional space using the almost inplace\rmerging routine (see Theorem 6 in the appendix). Note that for v = O(\r√\rp\rn),\r|Sα|v = O(n/√\rv).\rTheorem 3. For v = O(\r√\rn), algorithm DC can be implemented to run in time\rO(vn) using additional space O(n/√\rv).\rThe upper bound for v can be increased to O(n\r2/3\r) by using the comparison\rbased algorithm from [6] when v = ω(\r√\rn).\r10\r7 Advanced models\rIn this section, we adapt the DC3 algorithm for several advanced models of computation. We first explain the main ideas and then bundle the results in Theorem 4\rbelow.\rThe adaptation to memory hierarchies is easy since all operations can be described in terms of scanning, sorting, and permuting sequences of tuples using standard techniques. Since scanning is trivial and since permuting is equivalent to\rsorting, all we really need is a good external sorting algorithm. The proof therefore\rconcentrates on bounding the internal work associated with integer sorting.\rParallelization is slightly more complicated since the scanning needed to find the\rranks of elements looks like a sequential process on the first glance. However, the\rtechnique to overcome this is also standard: Consider a sorted array a[0, n]. Define\rc[0] = 1 and c[i] = 1 if c[i − 1] 6= c[i] and c[i] = 0 otherwise for i ∈ [1, n]. Now the\rprefix sums P\ri∈[0,j]\rc[i] give the rank of a[j]. Computing prefix sums in parallel is\ragain a well studied problem.\rTheorem 4. The DC3 algorithm can be implemented to achieve the following performance guarantees on advanced models of computation:\rmodel of computation complexity alphabet\rExternal Memory [59]\rD disks, block size B,\rfast memory of size M\rO(\rn\rDB\rlog M\rB\rn\rB\r) I/Os\rO(n log M\rB\rn\rB\r) internal work integer\rCache Oblivious [22] O(\rn\rB\rlog M\rB\rn\rB\r) cache faults general\rBSP [58]\rP processors\rh-relation in time L + gh\rO(\rn log n\rP + L log2 P +\rgn log n\rP log(n/P)\r) time general\rP = O(n\r1−\u000f\r) processors O(n/P + L log2 P + gn/P) time integer\rEREW-PRAM [33] O(log2 n) time and O(n log n) work general\rpriority-CRCW-PRAM [33] O(log2 n) time and O(n) work\r(randomized) constant\rProof. External memory: Step 1 of the DC3 algorithm begins by scanning the\rinput and producing tuples ([t3i+kt3i+k+1t3i+k+2], 3i + k) for k ∈ {1, 2} and 3i + k ∈\r[0, n]. These tuples are then sorted by lexicographic order of the character triples.\rThe results are scanned producing rank position pairs (r3i+k, 3i + k). Constructing\ra recursive problem instance then amounts to sorting using the lexicographic order\rof (k, i) for comparing positions of the form 3i + k. Similarly, assigning ranks to\ra sample suffix j at position i in the suffix array of the sample amounts to sorting\rpairs of the form (i, j).\r11\rStep 2 sorts triples of the form (ti\r, rank(Si+1), i). Step 3 represents S3i as\r(t3i\r,t3i+1, rank(S3i+1), rank(S3i+2), 3i), S3i+1 as (t3i+1, rank(S3i+2), 3i+1), and S3i+2\ras (t3i+2,t3i+3, rank(S3i+4)), 3i + 2). This way all the information needed for comparisons is available. These representations are produced using additional sorting\rand scanning passes. A more detailed description and analysis of external DC3 is\rgiven in [14]. It turns out that the total I/O volume is equivalent to the amount\rI/O needed for sorting 30n words of memory plus the I/O needed for scanning 6n\rwords.\rAll in all, the complexity of external suffix array construction is governed by the\reffort for sorting objects consisting of a constant number of machine words. The\rkeys are integers in the range [0, n], or pairs or triples of such integers. I/O optimal\rdeterministic1 parallel disk sorting algorithms are well known [53, 52]. We have to\rmake a few remarks regarding internal work however. To achieve optimal internal\rwork for all values of n, M, and B, we can use radix sort where the most significant\rdigit has blog Mc − 1 bits and the remaining digits have blog M/Bc bits. Sorting\rthen starts with O(logM/B n/M) data distribution phases that need linear work each\rand can be implemented using O(n/DB) I/Os using the same I/O strategy as in\r[52]. It remains to stably sort the elements by their blog Mc−1 most significant bits.\rThis is also done using multiple phases of distribution sorting similar to [52] but we\rcan now afford to count how often each key appears and use this information to\rproduce splitters that perfectly balance the bucket sizes (we may have large buckets\rwith identical keys but this is no problem because no further sorting is required for\rthem). Mapping keys to buckets can use lookup tables of size O(M).\rCache oblivious: These algorithms are similar to external algorithms with a single\rdisk but they are not allowed to make explicit use of the block size B or the internal\rmemory size M. This is a serious restriction here since no cache oblivious integer\rsorting with O(\rn\rB\rlogM/B\rn\rB\r) cache faults and o(n log n) work is known. Hence, we\rcan as well go to the comparison based alphabet model. The result is then an\rimmediate corollary of the optimal comparison based sorting algorithm [22].\rEREW PRAM: We can use Cole’s merge sort [11] for parallel sorting and\rmerging. For an input of size m and P processors, Cole’s algorithm takes time\rO((m log m)/P +log P). The i-th level or recursion has an input of size n(2/3)i and\rthus takes time (2/3)iO((n log n)/P +log P). After Θ(log P) levels of recursion, the\rproblem size has reduced so far that the remaining subproblem can be solved in\rtime O((n/P log(n/P)) on a single processor. We get an overall execution time of\rO((n log n)/P + log2 P).\rBSP: For the case of many processors, we proceed as for the EREW-PRAM algorithm using the optimal comparison based sorting algorithm [25] that takes time\rO((n log n)/P + (gn/P + L)\rlog n\rlog(n/P)\r).\r1Simpler randomized algorithms with favorable constant factors are also available [15].\r12\rFor the case of few processors, we can use a linear work sorting algorithm based\ron radix sort [8] and a linear work merging algorithm [23]. The integer sorting\ralgorithm remains applicable at least during the first Θ(log log n) levels of recursion\rof the DC3 algorithm. Then we can afford to switch to a comparison based algorithm\rwithout increasing the overall amount of internal work.\rCRCW PRAM: We employ the stable integer sorting algorithm [55] that works in\rO(log n) time using linear work for keys with O(log log n) bits. This algorithm can\rbe used for the first Θ(log log log n) iterations for constant input alphabets. Then\rwe can afford to switch to the algorithm [29] that works for keys with O(log n) bits\rat the price of being inefficient by a factor O(log log n). Comparison based merging\rcan be implemented with linear work and O(log n) time using [30].\rThe resulting algorithms are simple except that they may use complicated subroutines for sorting to obtain theoretically optimal results. There are usually much\rsimpler implementations of sorting that work well in practice although they may\rsacrifice determinism or optimality for certain combinations of parameters.\r8 Conclusion\rThe main result of this paper is DC3, a simple, direct, linear time algorithm for\rsuffix sorting with integer alphabets. The algorithm is easy to implement and it\rcan be used as an example for advanced string algorithms even in undergraduate\rlevel algorithms courses. Its simplicity also makes it an ideal candidate for implementation on advanced models of computation. For example in [14] we describe\ran external memory implementation that clearly outperforms the best previously\rknown implementations and several other new algorithms.\rThe concept of difference covers makes it possible to generalize the DC3 algorithm. This generalized DC algorithm allows space efficient implementation. An\robvious remaining question is how to adapt DC to advanced models of computation\rin a space efficient way. At least for the external memory model this is possible but\rwe only know an approach that needs I/O volume Ω (nv2.5\r).\rThe space efficient algorithm can also be adapted to sort an arbitrary set of\rsuffixes by simply excluding the nonsample suffixes that we do not want to sort in\rthe Steps 2–4. Sorting a set of m suffixes can be implemented to run in O(vm+n\r√\rv)\rtime using O(m + n/√\rv) additional space. Previously, the only alternatives were\rstring sorting in O(mn) worst case time or sorting all suffixes using O(n) additional\rspace. The space efficient Burrows–Wheeler transform in [35] relies on space efficient\rsorting of subsets of suffixes.\rIn many applications [1, 2, 34, 38, 45], the suffix array needs to be augmented\rwith the longest common prefix array lcp that stores the length of the longest common prefix of SAi and SAi+1 in lcp[i]. Once the lcp information is known it also\r13\reasy to infer advanced search data structures like suffix trees and string B-trees [20].\rThere are simple linear time algorithms for computing the lcp array from the suffix\rarray [38, 46], but they do not appear to be suitable for parallel or external computation. Farach’s algorithm [16] and the other half-recursive algorithms compute\rthe lcp array at each level of the recursion since it is needed for merging. With a\rsimilar technique the DC algorithm can be modified to compute the lcp array as\ra byproduct: If k = SA[i] and j = SA[i + 1] then find an  such that k + and\rj + are both in the sample. If T[k, k + ) 6= T[j, j + ) then lcp[i] can be computed locally. Otherwise, lcp[i] =  + lcp(Sk+ , Sj+). The lcp of Sk+ and Sj+` can be approximated within an additive term v from the lcp information of the recursive string R using range minima queries. All these operations can be implemented in parallel or for memory hierarchies using standard techniques. References [1] M. I. Abouelhoda, S. Kurtz, and E. Ohlebusch. The enhanced suffix array and its applications to genome analysis. In Proc. 2nd Workshop on Algorithms in Bioinformatics, volume 2452 of LNCS, pages 449–463. Springer, 2002. [2] M. I. Abouelhoda, E. Ohlebusch, and S. Kurtz. Optimal exact string matching based on suffix arrays. In Proc. 9th Symposium on String Processing and Information Retrieval, volume 2476 of LNCS, pages 31–43. Springer, 2002. [3] A. Andersson, N. J. Larsson, and K. Swanson. Suffix trees on words. Algorithmica, 23(3):246–260, 1999. [4] J. L. Bentley and R. Sedgewick. Fast algorithms for sorting and searching strings. In Proc. 8th Annual Symposium on Discrete Algorithms, pages 360– ACM, 1997. [5] A. Bertoni, C. Mereghetti, and B. Palano. Golomb rulers and difference sets for succinct quantum automata. Int. J. Found. Comput. Sci., 14(5):871–888, 2003. [6] S. Burkhardt and J. K¨arkk¨ainen. Fast lightweight suffix array construction and checking. In Proc. 14th Annual Symposium on Combinatorial Pattern Matching, volume 2676 of LNCS, pages 55–69. Springer, 2003. [7] M. Burrows and D. J. Wheeler. A block-sorting lossless data compression algorithm. Technical Report 124, SRC (digital, Palo Alto), May 1994. [8] A. Chan and F. Dehne. A note on coarse grained parallel integer sorting. Parallel Processing Letters, 9(4):533–538, 1999. 14 [9] R. Clifford and M. Sergot. Distributed and paged suffix trees for large genetic databases. In Proc. 14th Annual Symposium on Combinatorial Pattern Matching, volume 2676 of LNCS, pages 70–82. Springer, 2003. [10] C. J. Colbourn and A. C. H. Ling. Quorums from difference covers. Inf. Process. Lett., 75(1–2):9–12, July 2000. [11] R. Cole. Parallel merge sort. SIAM J. Comput., 17(4):770–785, 1988. [12] A. Crauser and P. Ferragina. Theoretical and experimental study on the construction of suffix arrays in external memory. Algorithmica, 32(1):1–35, 2002. [13] M. Crochemore and W. Rytter. Jewels of Stringology. World Scientific, 2002. [14] R. Dementiev, J. Mehnert, and J. K¨arkk¨ainen. Better external memory suffix array construction. In Workshop on Algorithm Engineering \u0026amp; Experiments, Vancouver, 2005. [15] R. Dementiev and P. Sanders. Asynchronous parallel disk sorting. In Proc. 15th Annual Symposium on Parallelism in Algorithms and Architectures, pages 138–148. ACM, 2003. [16] M. Farach. Optimal suffix tree construction with large alphabets. In Proc. 38th Annual Symposium on Foundations of Computer Science, pages 137–143. IEEE, 1997. [17] M. Farach, P. Ferragina, and S. Muthukrishnan. Overcoming the memory bottleneck in suffix tree construction. In Proc. 39th Annual Symposium on Foundations of Computer Science, pages 174–183. IEEE, 1998. [18] M. Farach and S. Muthukrishnan. Optimal logarithmic time randomized suffix tree construction. In Proc. 23th International Conference on Automata, Languages and Programming, pages 550–561. IEEE, 1996. [19] M. Farach-Colton, P. Ferragina, and S. Muthukrishnan. On the sortingcomplexity of suffix tree construction. J. ACM, 47(6):987–1011, 2000. [20] P. Ferragina and R. Grossi. The string B-tree: A new data structure for string search in external memory and its applications. J. ACM, 46(2):236–280, 1999. [21] P. Ferragina and G. Manzini. Opportunistic data structures with applications. In Proc. 41st Annual Symposium on Foundations of Computer Science, pages 390–398. IEEE, 2000. [22] M. Frigo, C. E. Leiserson, H. Prokop, and S. Ramachandran. Cache-oblivious algorithms. In Proc. 40th Annual Symposium on Foundations of Computer Science, pages 285–298. IEEE, 1999. 15 [23] A. V. Gerbessiotis and C. J. Siniolakis. Merging on the BSP model. Parallel Computing, 27:809–822, 2001. [24] G. Gonnet, R. Baeza-Yates, and T. Snider. New indices for text: PAT trees and PAT arrays. In W. B. Frakes and R. Baeza-Yates, editors, Information Retrieval: Data Structures \u0026amp; Algorithms. Prentice-Hall, 1992. [25] M. T. Goodrich. Communication-efficient parallel sorting. SIAM J. Comput., 29(2):416–432, 1999. [26] R. Grossi and G. F. Italiano. Suffix trees and their applications in string algorithms. Rapporto di Ricerca CS-96-14, Universit`a “Ca’ Foscari” di Venezia, Italy, 1996. [27] R. Grossi and J. S. Vitter. Compressed suffix arrays and suffix trees with applications to text indexing and string matching (extended abstract). In Proc. 32nd Annual Symposium on Theory of Computing, pages 397–406. ACM, 2000. [28] D. Gusfield. Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology. Cambridge University Press, 1997. [29] T. Hagerup and R. Raman. Waste makes haste: Tight bounds for loose parallel sorting. In Proc. 33rd Annual Symposium on Foundations of Computer Science, pages 628–637. IEEE, 1992. [30] T. Hagerup and C. Rub. ¨ Optimal merging and sorting on the EREW-PRAM. Information Processing Letters, 33:181–185, 1989. [31] W.-K. Hon, T.-W. Lam, K. Sadakane, and W.-K. Sung. Constructing compressed suffix arrays with large alphabets. In Proc. 14th International Symposium on Algorithms and Computation, volume 2906 of LNCS, pages 240–249. Springer, 2003. [32] W.-K. Hon, K. Sadakane, and W.-K. Sung. Breaking a time-and-space barrier in constructing full-text indices. In Proc. 44th Annual Symposium on Foundations of Computer Science, pages 251–260. IEEE, 2003. [33] J. J´aj´a. An Introduction to Parallel Algorithms. Addison Wesley, 1992. [34] J. K¨arkk¨ainen. Suffix cactus: A cross between suffix tree and suffix array. In Z. Galil and E. Ukkonen, editors, Proc. 6th Annual Symposium on Combinatorial Pattern Matching, volume 937 of LNCS, pages 191–204. Springer, 1995. [35] J. K¨arkk¨ainen. Fast BWT in small space by blockwise suffix sorting. In DIMACS Working Group on The Burrows–Wheeler Transform: Ten Years Later, Aug. 2004. To appear. 16 [36] J. K¨arkk¨ainen and P. Sanders. Simple linear work suffix array construction. In Proc. 30th International Conference on Automata, Languages and Programming, volume 2719 of LNCS, pages 943–955. Springer, 2003. [37] J. K¨arkk¨ainen and E. Ukkonen. Sparse suffix trees. In Proc. 2nd Annual International Conference on Computing and Combinatorics, volume 1090 of LNCS, pages 219–230. Springer, 1996. [38] T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park. Linear-time longestcommon-prefix computation in suffix arrays and its applications. In Proc. 12th Annual Symposium on Combinatorial Pattern Matching, volume 2089 of LNCS, pages 181–192. Springer, 2001. [39] J. Kilian, S. Kipnis, and C. E. Leiserson. The organization of permutation architectures with bused interconnections. IEEE Transactions on Computers, 39(11):1346–1358, Nov. 1990. [40] D. K. Kim, J. S. Sim, H. Park, and K. Park. Linear-time construction of suffix arrays. In Proc. 14th Annual Symposium on Combinatorial Pattern Matching, volume 2676 of LNCS, pages 186–199. Springer, June 2003. [41] P. Ko and S. Aluru. Space efficient linear time construction of suffix arrays. In Proc. 14th Annual Symposium on Combinatorial Pattern Matching, volume 2676 of LNCS, pages 200–210. Springer, June 2003. [42] T.-W. Lam, K. Sadakane, W.-K. Sung, and S.-M. Yiu. A space and time efficient algorithm for constructing compressed suffix arrays. In Proc. 8th Annual International Conference on Computing and Combinatorics, volume 2387 of LNCS, pages 401–410. Springer, 2002. [43] N. J. Larsson and K. Sadakane. Faster suffix sorting. Technical report LU-CSTR:99-214, Dept. of Computer Science, Lund University, Sweden, 1999. [44] W.-S. Luk and T.-T. Wong. Two new quorum based algorithms for distributed mutual exclusion. In Proc. 17th International Conference on Distributed Computing Systems, pages 100–106. IEEE, 1997. [45] U. Manber and G. Myers. Suffix arrays: A new method for on-line string searches. SIAM J. Comput., 22(5):935–948, Oct. 1993. [46] G. Manzini. Two space saving tricks for linear time LCP array computation. In Proc. 9th Scandinavian Workshop on Algorithm Theory, volume 3111 of LNCS, pages 372–383. Springer, 2004. 17 [47] G. Manzini and P. Ferragina. Engineering a lightweight suffix array construction algorithm. In Proc. 10th Annual European Symposium on Algorithms, volume 2461 of LNCS, pages 698–710. Springer, 2002. [48] E. M. McCreight. A space-economic suffix tree construction algorithm. J. ACM, 23(2):262–272, 1976. [49] P. M. McIlroy, K. Bostic, and M. D. McIlroy. Engineering radix sort. Computing systems, 6(1):5–27, 1993. [50] G. Navarro and R. Baeza-Yates. A hybrid indexing method for approximate string matching. Journal of Discrete Algorithms (JDA), 1(1):205–239, 2000. Special issue on Matching Patterns. [51] K. S. Neubert. The flashsort1 algorithm. Dr. Dobb’s Journal, pages 123–125, February 1998. [52] M. H. Nodine and J. S. Vitter. Deterministic distribution sort in shared and distributed memory multiprocessors. In Proc. 5th Annual Symposium on Parallel Algorithms and Architectures, pages 120–129. ACM, 1993. [53] M. H. Nodine and J. S. Vitter. Greed sort: An optimal sorting algorithm for multiple disks. J. ACM, 42(4):919–933, 1995. [54] S. Puglisi, W. Smyth, and A. Turpin. The performance of linear time suffix sorting algorithms. In Proc. Data Compression Conference, March 2005. to appear. [55] S. Rajasekaran and J. H. Reif. Optimal and sublogarithmic time randomized parallel sorting algorithms. SIAM J. Comput., 18(3):594–607, 1989. [56] B. Smyth. Computing Patterns in Strings. Pearson Addison–Wesley, 2003. [57] E. Ukkonen. On-line construction of suffix trees. Algorithmica, 14(3):249–260, 1995. [58] L. G. Valiant. A bridging model for parallel computation. Commun. ACM, 22(8):103–111, Aug. 1990. [59] J. S. Vitter and E. A. M. Shriver. Algorithms for parallel memory, I: Two level memories. Algorithmica, 12(2/3):110–147, 1994. [60] P. Weiner. Linear pattern matching algorithm. In Proc. 14th Symposium on Switching and Automata Theory, pages 1–11. IEEE, 1973. [61] I. H. Witten, A. Moffat, and T. C. Bell. Managing Gigabytes: Compressing and Indexing Documents and Images. Morgan Kaufmann, 1999. 18 A Source code The following C++ file contains a complete linear time implementation of suffix array construction. The main purpose of this code is to “prove” that the algorithm is indeed simple and that our natural language description is not hiding nonobvious complications. It should be noted that there are now faster (more complicated) implementations of our algorithm [54]. A driver program can be found at http: //www.mpi-sb.mpg.de/~sanders/programs/suffix/. inline bool leq(int a1, int a2, int b1, int b2) // lexicographic order { return(a1 \u0026lt; b1 || a1 == b1 \u0026amp;\u0026amp; a2 \u0026lt;= b2); } // for pairs inline bool leq(int a1, int a2, int a3, int b1, int b2, int b3) { return(a1 \u0026lt; b1 || a1 == b1 \u0026amp;\u0026amp; leq(a2,a3, b2,b3)); } // and triples // stably sort a[0..n-1] to b[0..n-1] with keys in 0..K from r static void radixPass(int* a, int* b, int* r, int n, int K) { // count occurrences int* c = new int[K + 1]; // counter array for (int i = 0; i \u0026lt;= K; i++) c[i] = 0; // reset counters for (int i = 0; i \u0026lt; n; i++) c[r[a[i]]]++; // count occurrences for (int i = 0, sum = 0; i \u0026lt;= K; i++) // exclusive prefix sums { int t = c[i]; c[i] = sum; sum += t; } for (int i = 0; i \u0026lt; n; i++) b[c[r[a[i]]]++] = a[i]; // sort delete [] c; } // find the suffix array SA of T[0..n-1] in {1..K}^n // require T[n]=T[n+1]=T[n+2]=0, n\u0026gt;=2 void suffixArray(int* T, int* SA, int n, int K) { int n0=(n+2)/3, n1=(n+1)/3, n2=n/3, n02=n0+n2; int* R = new int[n02 + 3]; R[n02]= R[n02+1]= R[n02+2]=0; int* SA12 = new int[n02 + 3]; SA12[n02]=SA12[n02+1]=SA12[n02+2]=0; int* R0 = new int[n0]; int* SA0 = new int[n0]; //******* Step 0: Construct sample ******** // generate positions of mod 1 and mod 2 suffixes // the \u0026ldquo;+(n0-n1)\u0026rdquo; adds a dummy mod 1 suffix if n%3 == 1 for (int i=0, j=0; i \u0026lt; n+(n0-n1); i++) if (i%3 != 0) R[j++] = i; //******* Step 1: Sort sample suffixes ******** // lsb radix sort the mod 1 and mod 2 triples radixPass(R , SA12, T+2, n02, K); radixPass(SA12, R , T+1, n02, K); radixPass(R , SA12, T , n02, K); 19 // find lexicographic names of triples and // write them to correct places in R int name = 0, c0 = -1, c1 = -1, c2 = -1; for (int i = 0; i \u0026lt; n02; i++) { if (T[SA12[i]] != c0 || T[SA12[i]+1] != c1 || T[SA12[i]+2] != c2) { name++; c0 = T[SA12[i]]; c1 = T[SA12[i]+1]; c2 = T[SA12[i]+2]; } if (SA12[i] % 3 == 1) { R[SA12[i]/3] = name; } // write to R1 else { R[SA12[i]/3 + n0] = name; } // write to R2 } // recurse if names are not yet unique if (name \u0026lt; n02) { suffixArray(R, SA12, n02, name); // store unique names in R using the suffix array for (int i = 0; i \u0026lt; n02; i++) R[SA12[i]] = i + 1; } else // generate the suffix array of R directly for (int i = 0; i \u0026lt; n02; i++) SA12[R[i] - 1] = i; //******* Step 2: Sort nonsample suffixes ******** // stably sort the mod 0 suffixes from SA12 by their first character for (int i=0, j=0; i \u0026lt; n02; i++) if (SA12[i] \u0026lt; n0) R0[j++] = 3*SA12[i]; radixPass(R0, SA0, T, n0, K); //******* Step 3: Merge ******** // merge sorted SA0 suffixes and sorted SA12 suffixes for (int p=0, t=n0-n1, k=0; k \u0026lt; n; k++) { #define GetI() (SA12[t] \u0026lt; n0 ? SA12[t] * 3 + 1 : (SA12[t] - n0) * 3 + 2) int i = GetI(); // pos of current offset 12 suffix int j = SA0[p]; // pos of current offset 0 suffix if (SA12[t] \u0026lt; n0 ? // different compares for mod 1 and mod 2 suffixes leq(T[i], R[SA12[t] + n0], T[j], R[j/3]) : leq(T[i],T[i+1],R[SA12[t]-n0+1], T[j],T[j+1],R[j/3+n0])) { // suffix from SA12 is smaller SA[k] = i; t++; if (t == n02) // done \u0026mdash; only SA0 suffixes left for (k++; p \u0026lt; n0; p++, k++) SA[k] = SA0[p]; } else { // suffix from SA0 is smaller SA[k] = j; p++; if (p == n0) // done \u0026mdash; only SA12 suffixes left for (k++; t \u0026lt; n02; t++, k++) SA[k] = GetI(); } } delete [] R; delete [] SA12; delete [] SA0; delete [] R0; } 20 B Almost inplace stable distribution sorting and multiway merging For the lightweight implementation of the DC-algorithm, we need subroutines that are combinations of well known ideas. We outline them here to keep the paper self-contained. The first idea is used for inplace yet instable distribution sorting (e.g., [49, 51]): The algorithm works similar to the radixPass routine in Appendix A yet it reuses the input array to allocate the output buckets. When character a[i] is moved to its destination bucket at array entry j, a[j] is taken as the next element to be distributed. This process is continued until an element is encountered that has already been moved. This order of moving elements decomposes the permutation implied by sorting into its constituent cycles. Therefore, the termination condition is easy to check: A cycle ends when we get back to the element that started the cycle. Unfortunately, this order of moving elements can destroy a preexisting order of keys with identical value and hence is instable. The second idea avoids instability using a reinterpretation of the input as a sequence of blocks. For example, (almost) inplace multiway merging of files is a standard technique in external memory processing [61, Section 5.3]. 1 2 3 4 5 6 7 8 6 2 4 3 7 8 1 5 b 1 b 0 b 2 b 1 b 2 b 0 a a a a Figure 1: Example for the distribution algorithm for k = 3, n = 32, and B = 4. Four states are shown: Before distribution, when all but two blocks have been distributed, when all blocks are distributed, and the final sorted arrays. The numbers give the order of block moves in the final permutation. In this example, only three additional blocks are needed for temporary storage. The synthesis of these two ideas leads to a “file-like” stable implementation of distribution sorting and multiway merging followed by an inplace permutation at 21 the block level that converts the file-representation back to an array representation. We work out the details in the proofs of the following two theorems. Theorem 5. An array a[0, n) containing elements with keys in the range [0, k), k = O(n), can be stably sorted in time O(n) using O( √ kn) additional space. Proof. Let bj = [a[i] : i ∈ [0, n), key(a[i]) = j] denote the j=th bucket, i.e., the sequence of elements with key j. Sorting a means to permute it in such a way that bj = a[ P i∈[0,j) |bi |, P i∈[0,j] |bi |). We begin with a counting phase that computes the bucket sizes |bj |. Then we reinterpret a as a sequence of blocks of size B = Θ(p n/k). For the time being, buckets will also be represented as sequences of blocks. For each key, we create an initially empty bucket that is implemented as an array of d|bj |/Be pointers to blocks. The first ( P i∈[0,j) |bi |) mod B elements of the first block of bj are left empty in the distribution process. This way, elements are immediately moved to the correct position modB. Buckets aquire additional blocks from a free list as needed. However, for the last block of a bucket bj , j \u0026lt; k − 1, the first block of bucket bj+1 is used. This way, only one partially filled block remains at the end: The last block of bk−1 is stored in another preallocated block outside of a. The free list is initially equipped with 2k + 2 empty blocks. The distribution process scans through the input sequence and appends an element with key j to bucket bj . When the last element from an input block has been consumed, this block is added to the free list. Since at any point of time there are at most 2k + 1 partially filled blocks (one for the input sequence, one at the start of a bucket, and one at the end of a bucket), the free list never runs out of available blocks. After the distribution phase, the blocks are permuted in such a way that a becomes a sorted array. The blocks can be viewed as the nodes of a directed graph where each nonempty block has an edge leading to the block in a where it should be stored in the sorted order. The nodes of this graph have maximum in-degree and out-degree one and hence the graph is a collection of paths and cycles. Paths end at empty blocks in a. This structure can be exploited for the permutation algorithm: In the outermost loop, we scan the blocks in a until we encounter a nonempty block a[i, i + B) that has not been moved to its destination position j yet. This block is moved to a temporary space t. We repeatedly swap t with the block of a where its content should be moved until we reach the end of a path or cycle. When all blocks from a are moved to their final destination, the additionally allocated blocks can be moved to their final position directly. This includes the partially filled last block of bk−1. The total space overhead is O(kB) = O( √ nk) for the additional blocks, O(dn/Be+ k) = O( √ nk) for representing buckets, and O(dn/Be + k) = O( √ nk) for pointers that tell every block where it wants to go. Theorem 6. An array a[0, n) consisting of k ≤ n sorted subarrays can be sorted in time O(n log k) using O( √ kn) additional space. 22 Proof. The algorithm is similar to the distribution algorithm from Theorem 5 so that we only outline the differences. We reinterpret the subarrays as sequences of blocks of a with a partially filled block at their start and end. Only blocks that completely belong to a subarray are handed to the free list. The smallest unmerged elements from each sequence are kept in a priority queue. Merging repeatedly removes the smallest element and appends it to the output sequence that is represented as a sequence of blocks aquired from the free list. After the merging process, it remains to permute blocks to obtain a sorted array. Except for space O(k) for the priority queue, the space overhead is the same as for distribution sorting. 23 ","id":2,"section":"posts","summary":"","tags":["字符串Hash","manacher"],"title":"txt","uri":"https://cs-fil.github.io/2020/12/txt/","year":"2020"},{"content":" 通过尽可能减少 $Hash$ 冲突的特定运算将数据控在一个小范围 辅以链表解决 $Hash$ 冲突, 再在小范围维护原始数据, 出现冲突时调用原始数据进一步判断 可以理解为将长列折叠并对纵列分类 分类标准即是特定运算函数 $H(x)$ -为降低存在、出现次数类问题的复杂度\n","id":3,"section":"posts","summary":"","tags":["Hash"],"title":"Hash","uri":"https://cs-fil.github.io/2020/12/hash/","year":"2020"},{"content":"链接 摘要  判断若干个六元组是否重复(从任意一个元素开始顺序或倒序相同即视为相同)\n解  属出现次数类问题, 考虑用 $Hash$ 降低复杂度\ndebug  1.判不同需所有情况下皆不同才可判 2.注意取模后的范围与数组实际范围是否相符\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5,P=99991;\rint n,s[N][7];\rint head[N],nxt[N],c;\rinline bool check(int a[],int b[])\r{\rifor(i,1,6)\rifor(j,1,6)\r{\rbool flg=true;\rifor(k,1,6)\rif(a[(i+k)%6+1]!=b[(j+k)%6+1])\r{flg=false; break;}\rif(flg) return true;\rflg=true;\rifor(k,1,6)\rif(a[(i+k)%6+1]!=b[(j-k+6)%6+1])\r{flg=false; break;}\rif(flg) return true;\r}\rreturn false;\r}\rinline int hash(int a[])\r{\rint sum=0,mul=1;\rifor(i,1,6)\r{\rsum=(sum+a[i])%P;\rmul=(long long)mul*a[i]%P;\r}\rreturn (sum+mul)%P;\r}\rinline bool insert(int a[])\r{\rint val=hash(a);\rfor(int i=head[val];i;i=nxt[i])\rif(check(s[i],a))\rreturn true;\r++c;\rifor(i,1,6)\rs[c][i]=a[i];\rnxt[c]=head[val];\rhead[val]=c;\rreturn false;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\r{\rint a[7];\rifor(j,1,6)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[j]);\rif(insert(a))\rreturn puts(\u0026quot;Twin snowflakes found.\u0026quot;),0;\r}\rputs(\u0026quot;No two snowflakes are alike.\u0026quot;);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":4,"section":"posts","summary":"","tags":["Hash"],"title":"POJ 3349 Snowflake Snow Snowflakes","uri":"https://cs-fil.github.io/2020/12/poj-3349/","year":"2020"},{"content":"链接 摘要  对于一个长度为 $n$ 的序列, 对于每一个 $a_i$, 求:\n$min|a_i-a_j|(1$$\\leqslant$$j$$\u0026lt;$$i)$\n以及令上式取到最小值的 $j$, 若最小值点不唯一, 则选择较小的 $j$\n解  1.将数依次插入集合, 集合满足单调递增 (平衡树 $set$)\n2.排序, 建立链表, 从后往前循环, 借助链表在前驱后继中确定一个 $j$ 后删除之\n时间复杂度均为 $O(nlongn)$\ndebug  对边界的处理稍加注意\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5;\rint n,b[N],ans1[N],ans2[N];\rstruct node\r{\rint val,pre,nxt,p;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return val\u0026lt;x.val;} }l[N];\rinline void remove(int p)\r{\rl[l[p].pre].nxt=l[p].nxt;\rl[l[p].nxt].pre=l[p].pre;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;l[i].val),l[i].p=i;\rstd::sort(l+1,l+n+1);\rifor(i,1,n)\r{\rl[i].nxt=i+1,l[i+1].pre=i;\rb[l[i].p]=i;\r}\rl[0].val=-0x3f3f3f3f;\rl[n+1].val=0x3f3f3f3f;\rfor(int i=n;i\u0026gt;=2;--i)\r{\rint a1=l[l[b[i]].nxt].val-l[b[i]].val;\rint a2=l[b[i]].val-l[l[b[i]].pre].val;\rif(l[b[i]].pre==0)\rans1[i]=a1,ans2[i]=l[l[b[i]].nxt].p;\relse if(l[b[i]].nxt==n+1)\rans1[i]=a2,ans2[i]=l[l[b[i]].pre].p;\relse if(a1\u0026lt;a2)\rans1[i]=a1,ans2[i]=l[l[b[i]].nxt].p;\relse ans1[i]=a2,ans2[i]=l[l[b[i]].pre].p;\rremove(b[i]);\r}\rifor(i,2,n)\rprintf(\u0026quot;%d %d\\n\u0026quot;,ans1[i],ans2[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":5,"section":"posts","summary":"","tags":["链表"],"title":"CH 1301 邻值查找","uri":"https://cs-fil.github.io/2020/12/ch-1301/","year":"2020"},{"content":"链接 摘要  对于一个整数集合, 定义判定规则: 从中取出 $m$ 对数, 使得每对数的差的平方之和最大\n这个最大值若小于等于给定的值, 则该集合合法\n给定长度为 $n$ 的数列, 求合法的最少分段数\n解  对于判定, 最大时即为最大与最小, 次大与次小, 数学证明 划分数列需要枚举边界进行判断\n二分与倍增时间复杂度一致, 但是根据倍增的特性可以使用类似归并排序的做法,\n每次扩展可以省去部分排序, 时间复杂度近 $O(NlogN)$\n技巧  $merge$ 函数\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int N=5e5+5;\rint T,n,m;\rll k;\rint a[N],b[N],c[N];\rinline ll cal(int l,int r,int t)\r{\rint i=l,j=r,ct=m;\rll res=0;\rifor(k,t+1,r)\rb[k]=a[k];\rstd::sort(b+t+1,b+r+1);\rstd::merge(a+l,a+t+1,b+t+1,b+r+1,c+l);\rwhile(i\u0026lt;j\u0026amp;\u0026amp;ct\u0026gt;=1)\rres+=1ll*(c[i]-c[j])*(c[i++]-c[j--]),ct--;\rreturn res;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rwhile(T--)\r{\rscanf(\u0026quot;%d%d%lld\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;k);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\rint cnt=0,r=1,l=1,p=1;\rwhile(true)\r{\rif(r+p\u0026lt;=n)\r{\rif(cal(l,r+p,r)\u0026lt;=k)\r{\rr+=p,p*=2;\rifor(i,l,r)\ra[i]=c[i];\r}\relse if(p/2!=0)\rp/=2;\relse\r{\rifor(i,l,r)\ra[i]=c[i];\rl=r=r+1,cnt++,p=1;\r}\r}\relse\r{\rp=n-r;\rif(cal(l,r+p,r)\u0026lt;=k)\r{cnt++;break;}\relse if(p/2!=0)\rp/=2;\relse\r{ ifor(i,l,r)\ra[i]=c[i];\rcnt++,l=r=r+1,p=1;\r}\r} }\rprintf(\u0026quot;%d\\n\u0026quot;,cnt);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":6,"section":"posts","summary":"","tags":["倍增"],"title":"CH 0601 Genius ACM","uri":"https://cs-fil.github.io/2020/12/ch-0601/","year":"2020"},{"content":"链接 摘要  在 $n$$×$$m$ 的矩阵中, 有 $t$ 个关键点\n问是否可以通过上下左右移动关键点, 使得每行每列的关键点数相等 特别的, 第一列和第 $n$ 列相邻, 行亦然\n解  可以发现: 左右移动不会影响行关键点数, 上下不影响列\n于是拆分为两个部分: 左右移动使得列关键点数相等, 上下使行等\n于是问题变成了一维: 环形均分纸牌问题\n普通的均分纸牌问题, 先考虑第一个人索取或给予, 后将一二人视为一个整体考虑索取或给予\n若先预处理每一个人的手牌数减去均值, 则目标即是 $0$\n答案即是前缀和绝对值之和\n而考虑环形, 非环形的情况就是在第一个人和第 $n$ 个人之间断开 考虑朴素算法, 我们只需枚举断开的位置即可\n假设位置是 $k$, $a[k+1]$ 对应的前缀和即是 $s[k+1]-s[k]$\n多列几个关键点式子, 发现前缀和绝对值之和, 就是在之前的基础上, 每一项减去 $s[k]$\n该问题巧妙地指向了货仓选址问题, 即只需排序找到中位数便可得出答案\ndebug  $ceil$ 函数内外都是 double\n答案要考虑是否 $long$ $long$\n技巧  省 $ceil$ k=(n+(n\u0026amp;1))\u0026gt;\u0026gt;1\n最终求和还可以优化省去 $abs$\nfor(int i=1;i\u0026lt;=n;++i)s1[i]+=s1[i-1];\rrnum=s1[n]-s1[i]-(n-i)*(s1[i]-s1[i-1])+i*(s1[i]-s1[i-1])-s1[i];\r 代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int N=1e5+5;\rint n,m,t;\rll a[N],b[N],aa[N],ba[N],as[N],bs[N];\rbool flg1=false,flg2=false;\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;t);\rint x,y;\rifor(i,1,t)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;x,\u0026amp;y);\ra[x]++,b[y]++;\r}\rll a1=t/n,b1=t/m;\rll ans=0;\rif(t%n==0)\r{\rifor(i,1,n)\raa[i]=a[i]-a1,as[i]=as[i-1]+aa[i];\rstd::sort(as+1,as+n+1);\rll k=as[(int)ceil((double)n/2)];\rifor(i,1,n)\rans+=abs(as[i]-k);\rflg1=true;\r}\rif(t%m==0)\r{\rifor(i,1,m)\rba[i]=b[i]-b1,bs[i]=bs[i-1]+ba[i];\rstd::sort(bs+1,bs+m+1);\rll k=bs[(int)ceil((double)m/2)];\rifor(i,1,m)\rans+=abs(bs[i]-k);\rflg2=true;\r}\rif(flg1\u0026amp;\u0026amp;flg2)\rprintf(\u0026quot;both %lld\u0026quot;,ans);\relse if(flg1)\rprintf(\u0026quot;row %lld\u0026quot;,ans);\relse if(flg2)\rprintf(\u0026quot;column %lld\u0026quot;,ans);\relse printf(\u0026quot;impossible\u0026quot;);\rsystem(\u0026quot;pause\u0026quot;);\r}\r","id":7,"section":"posts","summary":"","tags":["数学"],"title":"CH 0502 七夕祭","uri":"https://cs-fil.github.io/2020/12/ch-0502/","year":"2020"},{"content":"链接 摘要  $n$ 个人各自会一门语言, 语言用 $int$ 范围内的整数表示\n$m$ 部电影, 各自有配音和字幕\n求一部电影, 其配音的语言其次字幕的语言会的人最多\n解  语言表示在 $int$ 范围内, 故需要离散化\n一是用 $map$ 直接用作数组\n二是手写离散化, 时空复杂度小\n代码  $map$\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;map\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=2e5+5;\rint n,m;\rstd::map\u0026lt;int,int\u0026gt; map;\rstruct node\r{\rint p,a,b;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return (a\u0026gt;x.a)||(a==x.a\u0026amp;\u0026amp;b\u0026gt;x.b);}\r}mv[N];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint x;\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x),map[x]++;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;m);\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rmv[i].p=i;\rif(map.count(x))\rmv[i].a=map[x];\r}\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rif(map.count(x))\rmv[i].b=map[x];\r}\rstd::sort(mv+1,mv+m+1);\rprintf(\u0026quot;%d\u0026quot;,mv[1].p);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r  手写离散化\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=2e5+5;\rint n,m;\rint l[N],t[N],ttl[N],c;\rstruct node\r{\rint p,a,b;\rinline bool operator\u0026lt;(const node\u0026amp;x)\rconst\r{return (a\u0026gt;x.a)||((a==x.a)\u0026amp;\u0026amp;(b\u0026gt;x.b));}\r}mv[N];\rinline void discrete()\r{\rstd::sort(l+1,l+n+1);\rifor(i,1,n)\r{\rif(i==1||l[i]!=l[i-1])\rt[++c]=l[i];//t数组用于查位置\rttl[c]++;\r}\r}\rinline int query(int x)\r{\rreturn std::lower_bound(t+1,t+c+1,x)-t;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;l[i]);\rdiscrete();\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;m);\rint x;\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rmv[i].p=i;\rif(t[query(x)]==x)\rmv[i].a=ttl[query(x)];\r}\rifor(i,1,m)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x);\rif(t[query(x)]==x)\rmv[i].b=ttl[query(x)];\r}\rstd::sort(mv+1,mv+m+1);\rprintf(\u0026quot;%d\u0026quot;,mv[1].p);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":8,"section":"posts","summary":"","tags":["离散化"],"title":"Codeforces 670C Cinema","uri":"https://cs-fil.github.io/2020/12/cf-670c/","year":"2020"},{"content":"inline void discrete()\r{\rstd::sort(l+1,l+n+1);\rifor(i,1,n)\r{\rif(i==1||l[i]!=l[i-1])\rt[++c]=l[i];//t数组用于查位置\r//ttl[c]++; 相关数据维护\r}\r}\rinline int query(int x)\r{\rreturn std::lower_bound(t+1,t+c+1,x)-t;\r}\r","id":9,"section":"posts","summary":"","tags":["离散化"],"title":"离散化","uri":"https://cs-fil.github.io/2020/12/discrete/","year":"2020"},{"content":"链接 摘要  $\u0026quot;\u0026lt;=\u0026quot;$ 且涉及无解判断的二分\n解  二分有两个模板\n$\u0026quot;\u0026lt;=\u0026quot;$ 用以下这个二分模板\n于是无解判断只需左边范围多开一位\n若最终 $l$ 在多开的那一位, 则无解\ndebug  (不知为何)输入时 (double)*100 转 (int) 需要 $ceil$ 函数 否则会有误差, 如 $8.19$ $=\u0026gt;$ $820$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e4+5;\rint n,m;\rdouble t;\rint a[N];\rchar tmp[100];\rinline bool judge(int x)\r{\rint res=0;\rifor(i,1,n)\rres+=a[i]/x;\rif(res\u0026gt;=m) return true;\relse return false;\r}\rint main()\r{\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\r//freopen(\u0026quot;out1.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\r//ifor(i,1,3) scanf(\u0026quot;%s\u0026quot;,tmp);\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rint r=0;\rifor(i,1,n)\rscanf(\u0026quot;%lf\u0026quot;,\u0026amp;t),a[i]=ceil(t*100),r=r\u0026gt;a[i]?r:a[i];\r//ifor(i,1,n)\r// printf(\u0026quot;%d\\n\u0026quot;,a[i]);\rint l=0;\rwhile(l\u0026lt;r)\r{\rint mid=(l+r+1)\u0026gt;\u0026gt;1;\r//printf(\u0026quot;%d %d %d\\n\u0026quot;,l,r,mid);\rif(judge(mid))\rl=mid;\relse r=mid-1;\r}\rif(l==0) printf(\u0026quot;0.00\u0026quot;);\relse printf(\u0026quot;%.2lf\u0026quot;,(double)l/100);\r//system(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":10,"section":"posts","summary":"","tags":["二分"],"title":"POJ 1064 Cable master","uri":"https://cs-fil.github.io/2020/11/poj-1064/","year":"2020"},{"content":"链接 摘要  序列 $n$ 中长度 ∈[S,T] 的子序列的最大平均值\n解  答案具有单调性, 用二分转化为判定性问题\n考虑二分平均值\n简化取平均的操作, 预处理减去平均值的数列, 则只需判断是否有子段和大于零即可\n而求子段和最大值引入单调队列, 队列内维护子段首数前一个数的前缀和, 队列内单调递增\n技巧  实数范围内的二分需设置精度 $eps$ 即 while(l+eps\u0026lt;r)\n若保留 $k$ 位小数, 则取 $eps$$=$$10^{-(k+2)}$\nl=mid 或 r=mid\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5;\rint n,s,t,hd,tl,q[N];\rdouble a[N],tmp[N],sum[N];\rinline bool judge(double p)\r{\rifor(i,1,n)\rtmp[i]=a[i]-p;\rifor(i,1,n)\rsum[i]=sum[i-1]+tmp[i];\rhd=1,tl=0;\rifor(i,1,n)\r{\rif(i\u0026gt;=s)\r{\rwhile(hd\u0026lt;=tl\u0026amp;\u0026amp;sum[i-s]\u0026lt;sum[q[tl]]) tl--;\rq[++tl]=i-s;\r}\rif(hd\u0026lt;=tl\u0026amp;\u0026amp;q[hd]\u0026lt;i-t) hd++;\rif(hd\u0026lt;=tl\u0026amp;\u0026amp;sum[i]-sum[q[hd]]\u0026gt;=0) return true;\r}\rreturn false;\r}\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;s,\u0026amp;t);\rdouble l=-10000,r=10000;\rifor(i,1,n)\rscanf(\u0026quot;%lf\u0026quot;,\u0026amp;a[i]);\rdouble ans;\rwhile(r-l\u0026gt;1e-5)\r{\rdouble mid=(l+r)/2;\rif(judge(mid))\rl=ans=mid;\relse r=mid;\r}\rprintf(\u0026quot;%.3lf\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":11,"section":"posts","summary":"","tags":["单调队列","二分"],"title":"Luogu P1419 寻找段落","uri":"https://cs-fil.github.io/2020/11/luogu-p1419/","year":"2020"},{"content":"链接 解  树上差分:\n结点 $+$ $+$, 结点 $LCA$ $-$ $-$, 结点 $LCA$ 父亲 $-$ $-$\n处理完后 $dfs$ 祖先加上所有子结点\n值得注意的是端点会重复记录, 需最后减去\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=3e5+5;\rint n,a[N];\rint hd[N],ver[N\u0026lt;\u0026lt;1],nxt[N\u0026lt;\u0026lt;1],dpth[N],f[N][20],val[N],cnt;\rdouble lg2[N];\rinline void add(int u,int v)\r{\rver[++cnt]=v,nxt[cnt]=hd[u],hd[u]=cnt;\rver[++cnt]=u,nxt[cnt]=hd[v],hd[v]=cnt;\r}\rinline void build(int x,int p)\r{\rdpth[x]=dpth[p]+1;\rf[x][0]=p;\rfor(int i=1;(1\u0026lt;\u0026lt;i)\u0026lt;=dpth[x];++i)\rf[x][i]=f[f[x][i-1]][i-1];\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\rbuild(ver[i],x);\r}\rinline int lca(int x,int y)\r{\rif(dpth[x]\u0026lt;dpth[y])\rstd::swap(x,y);\rwhile(dpth[x]\u0026gt;dpth[y])\rx=f[x][(int)lg2[dpth[x]-dpth[y]]];\rif(x==y) return x;\rfor(int i=lg2[dpth[x]];i\u0026gt;=0;i--)\rif(f[x][i]!=f[y][i])\rx=f[x][i],y=f[y][i];\rreturn f[x][0];\r}\rinline void dfs(int x,int p)\r{\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\r{\rdfs(ver[i],x);\rval[x]+=val[ver[i]];\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;a[i]);\rint x,y;\rifor(i,1,n-1)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;x,\u0026amp;y),add(x,y);\rifor(i,1,n)\r{double k=log(i)/log(2);lg2[i]=k;}\rbuild(1,0);\rifor(i,1,n-1)\r{\rval[a[i]]++,val[a[i+1]]++,val[lca(a[i],a[i+1])]--;\rval[f[lca(a[i],a[i+1])][0]]--;\r}\rdfs(1,0);\rifor(i,2,n)\rval[a[i]]--;\rifor(i,1,n)\rprintf(\u0026quot;%d\\n\u0026quot;,val[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":12,"section":"posts","summary":"","tags":["差分","LCA"],"title":"Luogu P3258 [JLOI]松鼠的新家","uri":"https://cs-fil.github.io/2020/11/luogu-p3258/","year":"2020"},{"content":"链接 摘要  求序列 $n$ 中, 长度不超过 $m$ 的子序列的和的最大值 $n≤500000$\n解  $i$~$j$ 的序列和即为 $sum[j]-sum[i-1]$\n所以枚举过程中, 只需维护 $m$ 个数内 $sum[i]$ 的最小值\n考虑引入单调队列, 满足队列内 编号.$sum$ 都单调递增\n维护 $head.tail$, 于是便于弹出编号超出范围的, 便于弹出尾部加入新增的 $sum$ 值后不满足单调递增的\n只需 $O(n)$ 枚举, 时刻更新队列, 用 $sum[i]-sum[q[head]]$ 更新答案即可\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=5e5+5;\rint n,m,h=1,t;\rint q[N],sum[N];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rint x;\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x),sum[i]=sum[i-1]+x;\rint ans=-0x3f3f3f3f;\rifor(i,1,n)\r{\rif(h\u0026lt;=t\u0026amp;\u0026amp;q[h]\u0026lt;i-m) h++;\rans=std::max(ans,sum[i]-sum[q[h]]);\rwhile(h\u0026lt;=t\u0026amp;\u0026amp;sum[i]\u0026lt;=sum[q[t]]) t--;\rq[++t]=i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rreturn 0;\r}\r","id":13,"section":"posts","summary":"","tags":["单调队列"],"title":"Luogu P1714 切蛋糕","uri":"https://cs-fil.github.io/2020/11/luogu-p1714/","year":"2020"},{"content":" 1.建树 (同时预处理深度, 子父关系) 2.找祖先: 先到达同一深度, 后同时上跳直至公共祖先的下一层, 输出此时的父亲 预处理 $log_2$ 便于计算\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cmath\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=5e5+5;\rint n,m,s;\rint hd[N],ver[N\u0026lt;\u0026lt;1],nxt[N\u0026lt;\u0026lt;1],dpth[N],f[N][20],cnt;\rdouble lg2[N];\rinline void add(int u,int v)\r{\rver[++cnt]=v,nxt[cnt]=hd[u],hd[u]=cnt;\rver[++cnt]=u,nxt[cnt]=hd[v],hd[v]=cnt;\r}\rinline void build(int x,int p)\r{\rdpth[x]=dpth[p]+1;\rf[x][0]=p;\rfor(int i=1;(1\u0026lt;\u0026lt;i)\u0026lt;=dpth[x];++i)\rf[x][i]=f[f[x][i-1]][i-1];\rfor(int i=hd[x];i;i=nxt[i])\rif(ver[i]!=p)\rdfs(ver[i],x);\r}\rinline int lca(int x,int y)\r{\rif(dpth[x]\u0026lt;dpth[y])\rstd::swap(x,y);\rwhile(dpth[x]\u0026gt;dpth[y])\rx=f[x][(int)lg2[dpth[x]-dpth[y]]];\rif(x==y) return x;\rfor(int i=lg2[dpth[x]];i\u0026gt;=0;i--)\rif(f[x][i]!=f[y][i])\rx=f[x][i],y=f[y][i];\rreturn f[x][0];\r}\rint main()\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;s);\rint a,b;\rifor(i,1,n-1)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a,\u0026amp;b),add(a,b);\rifor(i,1,n)\r{double k=log(i)/log(2);lg2[i]=k;}\rbuild(s,0);\rifor(i,1,m)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a,\u0026amp;b),printf(\u0026quot;%d\\n\u0026quot;,lca(a,b));\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":14,"section":"posts","summary":"","tags":["LCA"],"title":"最近公共祖先(LCA)","uri":"https://cs-fil.github.io/2020/11/least-common-ancestors/","year":"2020"},{"content":"链接 摘要  给定 $n$ 个元素, 每个元素有 $number$, $color$, $value$ 三个数据 定义三元组$:$ $(x,y,z)$ 满足两个条件\n1. $xyz$ 是整数, $x＜y＜z$, $y$$-$$x$$=$$z$$-$$y$\n2. $color_x$ $=$ $color_z$\n其分数为 $(x$$+$$z)$$×$$($$value_x$$+$$value_y$$)$\n求所有满足条件的三元组的分数的和 $mod$ $10007$\n解  值得学习的思想过程:\n考虑枚举 $x,y,z$, 复杂度 $O($$n^3$$)$超时\n由三元组条件得 $2y$$=$$x$$+$$z$, 枚举复杂度 $O($$n^2$$)$超时\n但是我们得到若 $x,z$ 奇偶性相同且颜色一致, 那么此三元组一定满足条件 于是按照颜色和奇偶性分为 $2*m$ 个组, 答案就是所有组的分数之和\n对于每一个组枚举列式计算化简得:\n$ans$ $=$ $x_1$ * $($$y_1$ * $(k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k$$)$$+$$x_2$ * $($$y_2$ * $($$k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k$$)$$+$$\u0026hellip;$$+$$x_k$ * $($$y_k$ * $($$k$$-$$2$$)$$+$$y_1$$+$$y_2$$+$$\u0026hellip;$$+$$y_k)$\n预处理 $k,sum$, $O(n)$ 计算 $ans$\n心得  寻找特征, 根据特征步步优化, 有时化成数学问题得到式子\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int N=1e5+5,mod=1e4+7;\rint m,n;\rint v[N],c[N],cnt[N][2],sum[N][2];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;v[i]);\rifor(i,1,n)\r{ scanf(\u0026quot;%d\u0026quot;,\u0026amp;c[i]);\rcnt[c[i]][i%2]++,sum[c[i]][i%2]=(sum[c[i]][i%2]+v[i])%mod; }\rint ans=0;\rifor(i,1,n)\rans=(ans+i*(sum[c[i]][i%2]+v[i]*(cnt[c[i]][i%2]-2)%mod)%mod)%mod;\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":15,"section":"posts","summary":"","tags":["数学"],"title":"Luogu P2671 求和","uri":"https://cs-fil.github.io/2020/11/luogu-p2671/","year":"2020"},{"content":"链接 摘要  数轴上 $n$ 个不等高的建筑, 从左看到 $A$ 个, 右看 $B$ 个\n两种方案不同, 即高度排列不同, 求方案数\n 1≤n≤50000, 1≤A,B≤100\n解  对每一个可见的建筑及其挡住的建筑建组\n求方案数即枚举分组方式, 后固定下每组最高建筑, 组内其余全排列\n这恰好是第一类斯特林数\n简单阐述正确性:\n斯特林数包括全部分组方式, 对于不同的分组方式, 其序列一定不同\n后在组中选取一个值固定\n定量分析\n在 $n-1$ 个数中分 $A+B-2$ 组, 由于 $A$ $B$ 等价,选取 $A-1$ 放左即是组合数问题\n最终答案 $s(n-1,A+B-2)$*$C^{A+B-2}_{A-1}$\n技巧  将斯特林数及组合数的递推式可视化为二维数组, 容易考虑初始赋值\ndebug  1.预处理的数组范围要与所求的数组范围一致\n2.递推越界问题(实际可用的范围比所开的数组范围少1, 慎用 $N$)\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int inf=5e4+5,mod=1e9+7;\rint T,n,a,b;\rll c[205][105],s[inf][205];\rinline void prework()\r{\rs[0][0]=s[1][1]=1;\rifor(i,2,inf)\rs[i][1]=s[i-1][1]*(i-1);\rifor(i,0,205) c[i][0]=1;\rifor(i,2,inf)\rfor(int j=2;j\u0026lt;=i\u0026amp;\u0026amp;j\u0026lt;=205;++j)\rs[i][j]=(s[i-1][j-1]+s[i-1][j]*(i-1))%mod;\rifor(i,1,205)\rfor(int j=1;j\u0026lt;=i\u0026amp;\u0026amp;j\u0026lt;=105;++j)\rc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rprework();\rwhile(T--)\r{ scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;a,\u0026amp;b);\rprintf(\u0026quot;%lld\\n\u0026quot;,s[n-1][a+b-2]*c[a+b-2][a-1]%mod); }\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":16,"section":"posts","summary":"","tags":["数学","线性递推"],"title":"Luogu P4609 [FJOI]建筑师","uri":"https://cs-fil.github.io/2020/11/luogu-p4609/","year":"2020"},{"content":"链接 摘要  根据递推式求 $F[n][m]$ $mod$ $1e9$$+$$7$\n数据范围见原题\n解  由递推式, 很容易想到构造使用矩阵乘法\n技巧 1.扩展欧拉定理  $a^b$ $≡$ $a^{b\\ mod\\ φ(n)}$ $(mod$ $n)$ $(a$与$n$互质$)$\n对指数、底数取模, 优化复杂度\n2.十进制快速幂  本题中, 为应对高精度指数(未使用扩展欧拉定理)\ninline node qkpw(node bs,char *p)\r{\rnode res;\rres.a[1][1]=res.a[2][2]=1;\rll l=strlen(p+1);\rfor(ll i=l;i\u0026gt;=1;i--)\r{\rnode t=bs;\rif(p[i]=='9')\r{ t=t*t,t=t*t,t=t*t,t=t*bs;\rres=res*t;}\relse if(p[i]=='8')\r{ t=t*t,t=t*t,t=t*t;\rres=res*t;}\relse\r{ ifor(j,1,p[i]-'0')\r{ res=res*bs;}}\rnode k=bs;\rbs=bs*bs,bs=bs*bs,bs=bs*bs,bs=bs*k,bs=bs*k;\r}\rreturn res;\r}\r 3.卡常 循环展开(未测试) struct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rres.a[1][1]=md(a[1][1]*x.a[1][1]%mod+a[1][2]*x.a[2][1]%mod);\rres.a[1][2]=md(a[1][1]*x.a[1][2]%mod+a[1][2]*x.a[2][2]%mod);\rres.a[2][1]=md(a[2][1]*x.a[1][1]%mod+a[2][2]*x.a[2][1]%mod);\rres.a[2][2]=md(a[2][1]*x.a[1][2]%mod+a[2][2]*x.a[2][2]%mod);\rreturn res;\r}\r}ans,bs1,bs2,bs3;\r 4.卡常 加法取模(未测试)  两个小于 $mod$ 的数相加\ninline ll md(ll x)\r{ return x\u0026gt;=mod?x-mod:x;}\r 5.特判  注意特判 $a$$=$$1$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst ll inf=1e6+5,mod=1e9+7;\rll n,m,a,b,c,d,e;\rchar ns[inf],ms[inf];\rinline ll md(ll x)\r{ return x\u0026gt;=mod?x-mod:x;}\rstruct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rres.a[1][1]=md(a[1][1]*x.a[1][1]%mod+a[1][2]*x.a[2][1]%mod);\rres.a[1][2]=md(a[1][1]*x.a[1][2]%mod+a[1][2]*x.a[2][2]%mod);\rres.a[2][1]=md(a[2][1]*x.a[1][1]%mod+a[2][2]*x.a[2][1]%mod);\rres.a[2][2]=md(a[2][1]*x.a[1][2]%mod+a[2][2]*x.a[2][2]%mod);\rreturn res;\r}\r}ans,bs1,bs2,bs3;\rinline node qkpw(node bs,ll p)\r{\rnode res;\rres.a[1][1]=res.a[2][2]=1;\rwhile(p)\r{\rif(p\u0026amp;1)\r{ res=res*bs;}\rbs=bs*bs,p\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main()\r{\rscanf(\u0026quot;%s%s\u0026quot;,ns+1,ms+1);\rscanf(\u0026quot;%lld%lld%lld%lld\u0026quot;,\u0026amp;a,\u0026amp;b,\u0026amp;c,\u0026amp;d);\rif(a!=1) { e=mod-1;}\relse\r{ e=mod;}\rll ln=strlen(ns+1),lm=strlen(ms+1);\rifor(i,1,ln)\r{ n=(n*10+(ns[i]-'0'))%e;}\rifor(i,1,lm)\r{ m=(m*10+(ms[i]-'0'))%e;}\rans.a[1][1]=1,ans.a[1][2]=1;\rbs1.a[1][1]=a,bs1.a[2][1]=b,bs1.a[2][2]=1;\rbs2.a[1][1]=c,bs2.a[2][1]=d,bs2.a[2][2]=1;\rbs1=qkpw(bs1,m-1);\rbs3=bs1*bs2;\rans=ans*qkpw(bs3,n-1);\rans=ans*bs1;\rprintf(\u0026quot;%lld\u0026quot;,ans.a[1][1]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":17,"section":"posts","summary":"","tags":["矩阵乘法"],"title":"Luogu P1397 [NOI2013]矩阵游戏","uri":"https://cs-fil.github.io/2020/11/luogu-p1397/","year":"2020"},{"content":"链接 摘要  $F_n$ $mod$ $10^9$$+$$7$\n $1\\lt n\\leq$ $2^{63}$\n解  限于数据范围, $O(n)$ 的递推会 $TLE$\n于是化递推为矩阵乘法, 相当于将递推式换为一个乘号\n于是可以使用快速幂求解\n技巧  满足结合律的数学运算都可以使用快速幂\ndebug  注意指数 $long$ $long$ 时, 将快速幂函数的定义区也写为 $long$ $long$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst ll mod=1e9+7;\rll n;\rstruct node\r{\rll a[3][3];\rnode()\r{ memset(a,0,sizeof(a));}\rinline node operator*(const node\u0026amp;x)\rconst\r{\rnode res;\rifor(i,1,2)\rifor(j,1,2)\rifor(k,1,2)\rres.a[i][j]=(res.a[i][j]+a[i][k]*x.a[k][j])%mod;\rreturn res;\r}\r}ans,base;\rinline void qkpw(ll p)\r{\rwhile(p)\r{ if(p\u0026amp;1)\r{ ans=ans*base;}\rbase=base*base,p\u0026gt;\u0026gt;=1;\r}\r}\rint main()\r{\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;n);\rif(n\u0026lt;=2)\r{ return puts(\u0026quot;1\u0026quot;),0;}\rbase.a[1][1]=base.a[1][2]=base.a[2][1]=1;\rans.a[1][1]=ans.a[1][2]=1;\rqkpw(n-2);\rprintf(\u0026quot;%lld\u0026quot;,ans.a[1][1]%mod);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":18,"section":"posts","summary":"","tags":["矩阵乘法"],"title":"Luogu P1962 斐波那契数列","uri":"https://cs-fil.github.io/2020/11/luogu-p1962/","year":"2020"},{"content":"链接 摘要  求有多少种 $1$ 到 $n$ 的排列 $a$, 满足序列恰好有 $m$ 个位置 $i$, 使得 $a_i$$=$$i$\n答案对 $10^9$$+$$7$ 取模\n解  首先对题目进行模拟, 枚举满足条件的序列\n先确定下这 $m$ 个位置, 不难发现得到的情况数即为 $C_n^m$\n其次确定其余的位置\n定义 $D[i]$ 为 $i$ 个位置的情况数, 不难得到 $D[1]=0$, $D[2]=1$, $D[3]=2$\n对于 $D[4]$ 首先考虑 $1$ 的位置, 会有位置 $2.3.4$ $3$ 个情况\n进一步考虑除 $1$ 外数字 $2.3.4$ 的位置\n发现 $2$ 放在位置 $1$ 情况时, 其余数字的情况变为 $D[2]$\n若不放在位置 $1$ 则可假想位置 $1$ 为位置 $2$, 情况就变为了 $D[3]$\n于是 大胆推测 $D[i]=(n-1)*(D[i-1]+D[i-2])$\n于是答案即为 $C_n^m$ * $D[i]$\n心得 1.做题方法  线性递推题有两点技巧\n$1)$ 模拟以发现规律\n$2)$ 猜测以得出规律\n2.特判  写完题目还要对特殊情况进行检查, 必要时设置特判\n技巧  对于除法式子取模, 可以先将其转化为被除数与除数的乘法逆元相乘的式子, 再对因数取模\n求乘法逆元用到费马小定理 $a^p$ $≡$ $a$ $(mod$ $p)$ ($p$ 为质数)\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rtypedef long long ll;\rconst int inf=1e6+5,mod=1e9+7;\rint T,n,m;\rll f[inf],inv[inf],d[inf];\rinline ll qkpw(ll x,int p)\r{\rll ans=1;\rwhile(p)\r{\rif(p\u0026amp;1)\rans=ans*x%mod;\rx=x*x%mod,p\u0026gt;\u0026gt;=1;\r}\rreturn ans;\r}\rinline void prwrk()\r{\rf[0]=1;\rifor(i,1,inf)\rf[i]=f[i-1]*i%mod,inv[i]=qkpw(f[i],mod-2);\rd[1]=0,d[2]=1,d[3]=2;\rifor(i,4,inf)\rd[i]=(i-1)*(d[i-1]+d[i-2])%mod;\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rprwrk();\rwhile(T--)\r{ scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rif(n==m) puts(\u0026quot;1\u0026quot;);\relse if(m==0) printf(\u0026quot;%lld\\n\u0026quot;,d[n]);\relse printf(\u0026quot;%lld\\n\u0026quot;,(((f[n]*inv[m])%mod*inv[n-m])%mod)*d[n-m]%mod);}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":19,"section":"posts","summary":"","tags":["线性递推"],"title":"Luogu P4071 [SDOI]排列计数","uri":"https://cs-fil.github.io/2020/11/luogu-p4071/","year":"2020"},{"content":"$n$ 的简化剩余系是 φ(n) 阶 $Abel$ 群  对 $∀$ $a_i$$,$$a_j$, 若 $a$ * $a_i$ $≡$ $a$ * $a_j$ $(mod$ $m)$\n则 $a$ * $($$a_i$ $-$ $a_j$$)$ $≡$ $0$\n即 $a_i$ $≡$ $a_j$\n故当 $a_i$ $≠$ $a_j$时, $a$$a_i$$,$$a$$a_j$ 也表示不同的同余类\n","id":20,"section":"posts","summary":"","tags":["欧拉定理","费马小定理"],"title":"欧拉定理\u0026费马小定理","uri":"https://cs-fil.github.io/2020/11/eulers-theoremfermats-little-theorem/","year":"2020"},{"content":"定义  对一个有向无环图 ( Directed Acyclic Graph 简称 $DAG$ ) $G$ 进行拓扑排序, 是将 $G$ 中所有顶点排成一个线性序列, 使得图中任意一对顶点 $u$ 和 $v$,\n若边 $\u0026lt;$$u$$,$$v$$\u0026gt;$$∈$$E$$(G)$, 则 $u$ 在线性序列中出现在 $v$ 之前.\ncode inline void topsort()\r{\rstd::queue\u0026lt;int\u0026gt;q;\rifor(i,1,n)\rif(!id[i])\rq.push(i),tsrt[++c]=i;\rwhile(!q.empty())\r{\rint u=q.front();q.pop();\rfor(int i=h[u];i;i=nxt[i])\r{\rid[ver[i]]--;\rif(!id[ver[i]])\rq.push(ver[i]),tsrt[++c]=ver[i];\r}\r}\r}\r","id":21,"section":"posts","summary":"","tags":["拓扑排序"],"title":"拓扑排序","uri":"https://cs-fil.github.io/2020/11/topsort/","year":"2020"},{"content":"链接 摘要  $4$ 座汉诺塔\n解  回想 $3$ 座汉诺塔的解法, 对于 $n$ 塔, 先将 $n$$-$$1$ 塔移至 $B$ 座, 后将底塔移至 $C$ 座, 最后将 $n$$-$$1$ 塔移至 $C$ 座. 基于递推的思想.\n$4$ 座汉诺塔类似, 按照 $4$ 座的方式将 $i$ 塔移至 $B$ 座, 因为大塔不可覆盖小塔, 于是对于剩下的 $n$$-$$i$ 塔问题转化为 $3$ 座汉诺塔.\n于是有 $h4[i]=min$ { $h4[j]*2+h3[i-j]|i \\in [2,n],j \\in [1,i)$ } $, h4[1]=1$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint a[13],b[13];\rint main()\r{\rmemset(b,0x3f,sizeof(b));\ra[1]=b[1]=1;\rprintf(\u0026quot;%d\\n\u0026quot;,b[1]);\rifor(i,2,12)\r{\ra[i]=(a[i-1]\u0026lt;\u0026lt;1)+1;\rifor(j,1,i-1)\rb[i]=std::min(b[i],(b[j]\u0026lt;\u0026lt;1)+a[i-j]);\rprintf(\u0026quot;%d\\n\u0026quot;,b[i]);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":22,"section":"posts","summary":"","tags":["递推"],"title":"POJ 1958 Strange Towers of Hanoi","uri":"https://cs-fil.github.io/2020/09/poj-1958/","year":"2020"},{"content":"链接 摘要  给定 $5$ $\\times$ $5$ 的 $01$ 矩阵\n给出一个操作 使 $+$ 型共 $5$ 个数变为其相反的状态\n求使原矩阵归 $1$ 的操作数\n解 1. 怎么做及为什么是对的  通过观察 发现如下三点性质\n$1)$ 每一个数至多进行一次操作 因为两次以上则会自我抵消\n$2)$ 若要求不在第 $n$ 行前再进行操作 则下一行及之后的情况也一并固定只有一种 由于操作的特殊性 若想改变第 $n$ 行第 $i$ 个数且不在本行操作 则只能在下一行的第 $i$ 位操作来改变它\n$3)$ 操作顺序不影响最终结果\n于是只需枚举第一行的操作方式 验证是否可行记录最小值即可\n2. 怎么想到这样做  将无序的操作有序化，是本题的关键。将任意的操作行行分类，结合操作的特殊性，发现本题的突破口，找到其性质。最后将其转化为指数型枚举问题。\ndebug 及技巧  $01$ 矩阵 容易想到用位运算 然而再看操作 发现 $+$ 的横 实现不便(位运算不可移负数位) 于是将其整体向左移一位即可\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint T,a[6],ori[6];\rint mnx=0x7fffffff,k;\rstd::string s;\rinline void wrk(int x)\r{\rifor(i,1,5)\rif(!((a[x-1]\u0026gt;\u0026gt;(5-i+1))\u0026amp;1))\r{\r++k;\ra[x-1]^=(2\u0026lt;\u0026lt;(4-i+1));\ra[x]=(a[x]^(7\u0026lt;\u0026lt;(4-i+1)))\u0026amp;62;\ra[x+1]^=(2\u0026lt;\u0026lt;(4-i+1));\r}\rif(x==5)\r{\rif(a[5]==62)\rmnx=std::min(mnx,k);\rreturn;\r}\rwrk(x+1);\r}\rinline void cnt(int cur)\r{\rif(cur==6)\r{\rint m=k;\rifor(i,1,5) ori[i]=a[i];\rwrk(2);\r/*回归状态*/\rifor(i,1,5) a[i]=ori[i];\rk=m;\rreturn;\r}\r/*点击1行第cur个灯*/\ra[1]=(a[1]^(7\u0026lt;\u0026lt;(4-cur+1)))\u0026amp;62;\ra[2]^=(2\u0026lt;\u0026lt;(4-cur+1));\r++k;\rcnt(cur+1);\ra[1]=(a[1]^(7\u0026lt;\u0026lt;(4-cur+1)))\u0026amp;62;\ra[2]^=(2\u0026lt;\u0026lt;(4-cur+1));\r--k;\rcnt(cur+1);\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rwhile(T--)\r{\rmnx=0x7fffffff,k=0;\rmemset(a,0,sizeof(a));\rifor(i,1,5)\r{\rstd::cin\u0026gt;\u0026gt;s;\rifor(j,1,5)\rif(s[j-1]=='1')\ra[i]|=(1\u0026lt;\u0026lt;(5-j+1));\r}\rcnt(1);\rif(mnx==0x7fffffff||mnx\u0026gt;6)\rputs(\u0026quot;-1\u0026quot;);\relse printf(\u0026quot;%d\\n\u0026quot;,mnx);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":23,"section":"posts","summary":"","tags":["位运算","枚举"],"title":"CH 0201 费解的开关","uri":"https://cs-fil.github.io/2020/09/ch-0201/","year":"2020"},{"content":"链接 摘要  给定 $n$ 个数 求最长下降子序列位数和方案数1\n$1$ $\\leq$ $n$ $\\leq$ $5000$\n解  难点在于如何求方案数\n定义 $f[i]$ 表示以 $arr[i]$ 结尾的最长下降子序列位数\n判断末位大小关系 若可，f[i]=std::max(f[i],f[j]+1)以转移\n重点 定义 $c[i]$ 表示以 $arr[i]$ 结尾的最长下降子序列方案数\n 判重 若两个子序列位数相同且末位相等 那么容易得知构成前一个序列的方案必然可以构成后者 则需清空前者的 $c[]$ 以去重 转移 判断末位大小关系和子序列位数关系 若可，c[i]+=c[j]以转移   $dp$ 过程中存储位数最大值 最后位数符合最大值的子序列的方案数相加即为方案总数\ndebug  memset(arr,1,sizeof(arr))无法达到令 $arr$ 数组每一位为 $1$ 的效果，解决方案是手打循环赋值\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=5e3+9;\rint n,mxn,ans;\rint arr[inf],f[inf],c[inf];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]),f[i]=1;\rifor(i,1,n)\r{\rifor(j,1,i-1)\rif(arr[i]\u0026lt;arr[j])\rf[i]=std::max(f[i],f[j]+1);\rmxn=std::max(mxn,f[i]);\rifor(j,1,i-1)\rif(f[j]==f[i]\u0026amp;\u0026amp;arr[j]==arr[i])\rc[j]=0;\relse if(arr[i]\u0026lt;arr[j]\u0026amp;\u0026amp;f[j]==f[i]-1)\rc[i]+=c[j];\rif(!c[i]) ++c[i];\r}\rifor(i,1,n)\rif(f[i]==mxn)\rans+=c[i];\rprintf(\u0026quot;%d %d\u0026quot;,mxn,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r   若构成的队列相同则认为属于同一个方案 \u0026#x21a9;\u0026#xfe0e;\n  ","id":24,"section":"posts","summary":"","tags":["动态规划","递推"],"title":"Luogu P1108 低价购买","uri":"https://cs-fil.github.io/2020/03/luogu-p1108/","year":"2020"},{"content":"链接 摘要  对于一个整数 $n$ 的正整数次幂，后 $k$ 位是否发生循环\n若是 求循环长度 $k$ $\\leq$ $100$\n解  从尾部递推\n依次保证 后 $1$ 位循环，后 $2$ 位循环……后 $k$ 位循环\n定义fac在保证原数与之相乘 后 $m$ 位不变的前提下，探究保证第 $m+1$ 位不变的条件\n定义fac_maker以计算fac\n若次数 $cnt \u0026gt; 10$ 可判断不循环\n若 $cnt \u0026lt; 10$，将每一位探究的次数相乘可得到循环长度\n值得注意的是 由数据范围知应使用高精度\ndebug  乘法高精度中c[i+j-1]=a[i]*b[j] c[i+j-1]+=a[i]*b[j]  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=1e4+9,times[10]={1,1,4,4,2,1,1,4,4,2};\rint k;\rint ans[102],ori[102],maiN[inf],fac[inf],fac_maker[inf],tmp[inf];\rchar s[102];\rinline void mul_1(int a[],int b[],int c[])\r{\rifor(i,1,k)\rifor(j,1,k)\rc[i+j-1]+=a[i]*b[j],c[i+j]+=c[i+j-1]/10,c[i+j-1]%=10;\r}\rinline void mul_2(int a[],int b,int c[])\r{\rifor(i,1,k)\rc[i]+=a[i]*b,c[i+1]+=c[i]/10,c[i]%=10;\r}\rint main()\r{\rscanf(\u0026quot;%s%d\u0026quot;,s+1,\u0026amp;k);\rint l=strlen(s+1);\rfor(int i=l;i\u0026gt;=l-k+1;--i)\rori[l-i+1]=s[i]-'0';\rifor(i,1,k) maiN[i]=ori[i];\rifor(i,1,times[ori[1]]-1)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,ori,tmp);\rifor(j,1,k)\rmaiN[j]=tmp[j];\r}\rans[1]=times[ori[1]];\rifor(i,1,k)\rfac[i]=fac_maker[i]=maiN[i];\rint cur=1;\rwhile(++cur\u0026lt;k+1)\r{\rifor(i,1,k)\rmaiN[i]=ori[i];\rint cnt=0;\rwhile(cnt\u0026lt;=10)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,fac,tmp);\r++cnt;\rif(tmp[cur]==ori[cur]) break;\rifor(i,1,k)\rmaiN[i]=tmp[i];\rmemset(tmp,0,sizeof(tmp));\rmul_1(fac_maker,fac,tmp);\rifor(i,1,k)\rfac_maker[i]=tmp[i];\r}\rif(cnt\u0026gt;10) return puts(\u0026quot;-1\u0026quot;),0;\rmemset(tmp,0,sizeof(tmp));\rmul_2(ans,cnt,tmp);\rifor(i,1,100) ans[i]=tmp[i];\rifor(i,1,k) fac[i]=fac_maker[i];\r}\rint kk=100;\rwhile(ans[kk]==0\u0026amp;\u0026amp;kk\u0026gt;1) --kk;\rfor(int i=kk;i\u0026gt;=1;--i)\rprintf(\u0026quot;%d\u0026quot;,ans[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":25,"section":"posts","summary":"","tags":["模拟","递推"],"title":"Luogu P1050 循环","uri":"https://cs-fil.github.io/2020/03/luogu-p1050/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的字符串 $S$\n有 $m$ 个操作，保证 $m\\leq n$\n给定字符串 $T$1 初时为空\n共有以下两种操作\n 在字符串 $T$ 的末尾加上一个字符2 在字符串 $T$ 的开头加上一个字符   $n$ $\\leq$ $10^6$，$m$ $\\leq$ $3.3333$ $\\times$ $10^4$，$|\\Sigma|$ $\\leq$ $10^3$，$S_i$ $\\in$ $[1,|\\Sigma|]。$($\\Sigma$ 表示字符集$)$\n 每次操作完成后要求输出有几个 $l\\in [1,T.size]$ 满足对于 $\\forall i\\in [1,l]$ 有 $T_{T.size-l+i}$ $\\neq$ $S_i$\n解 $17$ $pts$  模拟\n时间复杂度 $O(m^3)$\n$50$ $pts$  $f[i]$ 表示当前 $l=i$ 时是否满足条件\n分别考虑两种情况\n$1.$ $op=0$\n操作之后 每一位会得到新的状态\n不难发现 f[i]继承f[i-1]的true状态的条件为ch==T[i]\n则需将 $ch$ 逐位比对更新状态\n$2.$ $op=1$\n操作之后 对于 $f[j]$$,$$j\\in [1,i-1]$ 的状态没有影响\n仅需考虑新增的 $f[i]$\n将字符串 $T$ 与 $S$ 逐位比对方可得出新增状态\n优化\n1. 定义 $l[]$ $r[]$ 分别表示首增和末增\n2. 对于第 $1$ 种情况 可先继承后判断，$coding$ 时会清楚一些\n值得注意的是 应倒序继承避免覆盖\n 时间复杂度 $O(m^2)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,opn,k,kk,res;\rint s[1000002],l[40002],r[40002],f[40002];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;s[i]);\rifor(i,1,m)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;opn,\u0026amp;k);\rif(opn)\r{\rl[++l[0]]=k;\rint flg=1;\rkk=0;\rfor(int j=l[0];j\u0026gt;=1;--j)\rif(l[j]==s[++kk])\r{flg=0; break;}\rifor(j,1,r[0])\rif(r[j]==s[++kk]||!flg)\r{flg=0; break;}\rres+=(f[i]=flg);\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\relse\r{\rr[++r[0]]=k;\rres=0;\rfor(int j=i;j\u0026gt;=2;--j)\rf[j]=f[j-1];\rf[1]=1;\rifor(j,1,i)\rres+=(f[j]\u0026amp;=(k!=s[j]));\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r $100$ $pts$  沿用 $50 pts$ 的思路，使用位运算进行优化\n定义 $01$数组 $id[i]$ 表示字符 $i$ 在字符串 $S$ 中的比对情况\n分别考虑两种情况\n$1.$ $op=0$\nf=f\u0026lt;\u0026lt;1|id[k]即继承状态并考虑 $ch$ 的比对情况\n$2.$ $op=1$\nf|=id[k]\u0026lt;\u0026lt;(i-1)即把比对状态更新至对应的 $l$ 处\n举个例子:\n$213$ 首先读取 $2$ 的比对状态 而归于 $l=3$ 的范畴\n输出时用一个 $01$ 数限制位数，~(f|now)中 $0$ 的个数即为所求\n 使用位运算对未来的状态进行了规划，是一个长远的考虑\n 优化\n引入压位优化的 $01$ 数组 $bitset$\n 时间复杂度 $O(m^2/w)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;bitset\u0026gt;\r#include\u0026lt;cstdlib\u0026gt; #include\u0026lt;cctype\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rconst int inf=1e6+2;\rint n,m,opn,k;\rint it[inf];\rstd::bitset\u0026lt;35000\u0026gt; id[1002],f,now;\rinline int read(){\rint res=0;\rchar ch;\rwhile(isspace(ch=getchar()));\rdo\r{\rres=(res\u0026lt;\u0026lt;1)+(res\u0026lt;\u0026lt;3)+(ch^48);\r}while(isdigit(ch=getchar()));\rreturn res;\r}\rint main()\r{\rn=read(),m=read();\rifor(i,1,n)\rit[i]=read();\rifor(i,1,m)\rid[it[i]].set(i);\rnow.set();\rifor(i,1,m)\r{\ropn=read(),k=read();\rnow.reset(i);\rif(!opn)\rf=f\u0026lt;\u0026lt;1|id[k];\relse f|=id[k]\u0026lt;\u0026lt;(i-1);\rprintf(\u0026quot;%d\\n\u0026quot;,(~(f|now)).count());\r}\rreturn 0;\r}\r   字符串下标从 $1$ 开始 \u0026#x21a9;\u0026#xfe0e;\n 此处字符可能不止一位 \u0026#x21a9;\u0026#xfe0e;\n  ","id":26,"section":"posts","summary":"","tags":["位运算"],"title":"Luogu P5640 【CSGRound2】逐梦者的初心","uri":"https://cs-fil.github.io/2020/03/luogu-p5640/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i$ \u0026amp; $b[i-1]$$\\neq$$0$，其中 $2$ $\\leq$ $i$ $\\leq$ $k$\n$1$ $\\leq$ $n$ $\\leq$ $100000$，$a_i$ $\\leq$ $10^9$\n解  定义 $f[i]$ 表示当前最后一项的第 $i$ 位为 $1$ 的最大子序列长度\n当 $a$ \u0026amp; $b$$\\neq$$0$，即 $ab$ 有相同的一位为 $1$，根据此性质进行转移\n在读入的过程中进行处理\n 若该数第 $i$ 位为 $1$，由于所定义的 $dp$ 数组的性质，转移时即为f[i]+1 取其中的最大值，再对其余数组进行更新，即 $k=max${$f[i]+1$} f[i]=k保证各个数组符合其性质  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,mxn;\rint f[30];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint t;\rwhile(n--)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rint k=1;\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rk=std::max(f[i]+1,k);\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rf[i]=k;\rmxn=std::max(mxn,k);\r}\rprintf(\u0026quot;%d\u0026quot;,mxn);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":27,"section":"posts","summary":"","tags":["位运算","动态规划"],"title":"Luogu P4310 绝世好题","uri":"https://cs-fil.github.io/2020/03/luogu-p4310/","year":"2020"},{"content":"链接 摘要  求数值 $k$$\\in$$[1,m]$ 经过 $n$ 次 $op$ $t$ 操作后的最大值\n $2\\leq n\\leq10^5$ $2\\leq m\\leq10^9$ $0\\leq t\\leq10^9$ $op$ 一定为 $or$ $xor$ $and$ 中的一种\n解  定义k1=0x7fffffff k2=0\n从二进制来看 $k1$ 每一位都是 $1$,$k2$ 每一位都是 $0$\n输入的过程中直接对 $k1$ $k2$ 进行操作\n对于第 $i$ 位 遵循贪心原则 $:$\n 若k2==1则ans+=1\u0026lt;\u0026lt;i 初始值的第 $i$ 位为 $0$ 或若k1==1则需考虑若初始值的第 $i$ 位为 $1$ 是否超出初始值范围 若否再而累加  debug  ans累加ans|=1\u0026lt;\u0026lt;i ans+=1\u0026lt;\u0026lt;i\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,t,ans,k1=0x7fffffff,k2=0;\rchar str[3];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\r{\rscanf(\u0026quot;%s%d\u0026quot;,str,\u0026amp;t);\rif(str[0]=='O') k1|=t,k2|=t;\rif(str[0]=='X') k1^=t,k2^=t;\rif(str[0]=='A') k1\u0026amp;=t,k2\u0026amp;=t;\r}\rfor(int i=29;~i;--i)\r{\rif(k2\u0026gt;\u0026gt;i\u0026amp;1) ans+=1\u0026lt;\u0026lt;i;\relse if(k1\u0026gt;\u0026gt;i\u0026amp;1\u0026amp;\u0026amp;m\u0026gt;=1\u0026lt;\u0026lt;i)\rans+=1\u0026lt;\u0026lt;i,m-=1\u0026lt;\u0026lt;i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":28,"section":"posts","summary":"","tags":["位运算","贪心"],"title":"Luogu P2114 [NOI2014]起床困难综合症","uri":"https://cs-fil.github.io/2020/03/luogu-p2114/","year":"2020"},{"content":"链接 摘要  $n$ 皇后问题\n $0\\lt n\\leq14$\n解  据数据范围 直接搜索会 $tle$\n使用位运算可以达到优化的目的\nmxstt即为列放置最终状态\n 构造函数dfs(cstt,l,r,ln)\n递归边界cstt==mxstt\n k=~(cstt|l|r|ln)\u0026amp;mxstt以获取改行状态\nlowbit(k)以列举可放置列 cstt表示列放置状态 $0$ 可放置 $1$ 不可放置\ncstt|lowbit(k) 以转移 l r分别表示左斜 右斜的状态 $01$ 义同上\n(l|lowbit(k))\u0026gt;\u0026gt;1 (r|lowbit(k))\u0026lt;\u0026lt;1以转移 ln表示当前行数\nln+1以转移   即dfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1)\ndebug  设置一个 $n$ 位二进制数的第 $k$ 位为 $1$ x|=k x|=1\u0026lt;\u0026lt;n-k l r的转移 (l|cstt)\u0026gt;\u0026gt;1 (l|lowbit(k))\u0026gt;\u0026gt;1 尤其注意用maxstate限制二进制位数  $Q$$\u0026amp;$$A$  $Q:$ 为什么不可以用单个状态stt 而是使用 $4$ 个变量推导状态 $？$\n$A:$ 因为左斜 右斜的转移方式与列放置状态的转移方式不同 $。$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint n,ans,mxstt;\rint stt[20];\rchar s[15];\rinline int lowbit(int x)\r{\rreturn x\u0026amp;-x;\r}\rinline void dfs(int cstt,int l,int r,int ln)\r{\rif(cstt==mxstt) {ans++; return;}\rint k=~(cstt|l|r|stt[ln])\u0026amp;mxstt;\rwhile(lowbit(k))\r{\rdfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1);\rk^=lowbit(k);\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rmxstt=(1\u0026lt;\u0026lt;n)-1;\rifor(i,1,n)\r{\rscanf(\u0026quot;%s\u0026quot;,s+1);\rifor(j,1,n)\rif(s[j]=='.')\rstt[i]|=(1\u0026lt;\u0026lt;n-j);\r}\rdfs(0,0,0,1);\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":29,"section":"posts","summary":"","tags":["位运算","搜索"],"title":"Luogu P1562 还是N皇后","uri":"https://cs-fil.github.io/2020/03/luogu-p1562/","year":"2020"},{"content":" $blog$ 建于 $2020.1.30$\n$aim:$ 每日 $4$ $AC$ 至 $2020$ $10$ 月下旬达成 $1000$ $AC\n","id":30,"section":"posts","summary":"","tags":["随笔"],"title":"2020 目标","uri":"https://cs-fil.github.io/2020/01/blog/","year":"2020"}],"tags":[{"title":"Hash","uri":"https://cs-fil.github.io/tags/hash/"},{"title":"LCA","uri":"https://cs-fil.github.io/tags/lca/"},{"title":"manacher","uri":"https://cs-fil.github.io/tags/manacher/"},{"title":"thoughts","uri":"https://cs-fil.github.io/tags/thoughts/"},{"title":"二分","uri":"https://cs-fil.github.io/tags/%E4%BA%8C%E5%88%86/"},{"title":"位运算","uri":"https://cs-fil.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"倍增","uri":"https://cs-fil.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"title":"动态规划","uri":"https://cs-fil.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"单调队列","uri":"https://cs-fil.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"title":"字符串Hash","uri":"https://cs-fil.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2hash/"},{"title":"差分","uri":"https://cs-fil.github.io/tags/%E5%B7%AE%E5%88%86/"},{"title":"拓扑排序","uri":"https://cs-fil.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"搜索","uri":"https://cs-fil.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"title":"数学","uri":"https://cs-fil.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"title":"枚举","uri":"https://cs-fil.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"title":"模拟","uri":"https://cs-fil.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"title":"欧拉定理","uri":"https://cs-fil.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"title":"矩阵乘法","uri":"https://cs-fil.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"title":"离散化","uri":"https://cs-fil.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"title":"线性递推","uri":"https://cs-fil.github.io/tags/%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"},{"title":"贪心","uri":"https://cs-fil.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"title":"费马小定理","uri":"https://cs-fil.github.io/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"title":"递推","uri":"https://cs-fil.github.io/tags/%E9%80%92%E6%8E%A8/"},{"title":"链表","uri":"https://cs-fil.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"title":"随笔","uri":"https://cs-fil.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}