{"categories":[{"title":"文","uri":"https://cs-fil.github.io/categories/%E6%96%87/"},{"title":"题解","uri":"https://cs-fil.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"posts":[{"content":"链接 摘要  对于一个整数 $n$ 的正整数次幂，后 $k$ 位是否发生循环\n若是 求循环长度 $k$ $\\leq$ $100$\n解  从尾部递推\n依次保证 后 $1$ 位循环，后 $2$ 位循环……后 $k$ 位循环\n定义fac在保证原数与之相乘 后 $m$ 位不变的前提下，探究保证第 $m+1$ 位不变的条件\n定义fac_maker以计算fac\n若次数 $cnt \u0026gt; 10$ 可判断不循环\n若 $cnt \u0026lt; 10$，将每一位探究的次数相乘可得到循环长度\n值得注意的是 由数据范围知应使用高精度\ndebug  乘法高精度中c[i+j-1]=a[i]*b[j] c[i+j-1]+=a[i]*b[j]  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=1e4+9,times[10]={1,1,4,4,2,1,1,4,4,2};\rint k;\rint ans[102],ori[102],maiN[inf],fac[inf],fac_maker[inf],tmp[inf];\rchar s[102];\rinline void mul_1(int a[],int b[],int c[])\r{\rifor(i,1,k)\rifor(j,1,k)\rc[i+j-1]+=a[i]*b[j],c[i+j]+=c[i+j-1]/10,c[i+j-1]%=10;\r}\rinline void mul_2(int a[],int b,int c[])\r{\rifor(i,1,k)\rc[i]+=a[i]*b,c[i+1]+=c[i]/10,c[i]%=10;\r}\rint main()\r{\rscanf(\u0026quot;%s%d\u0026quot;,s+1,\u0026amp;k);\rint l=strlen(s+1);\rfor(int i=l;i\u0026gt;=l-k+1;--i)\rori[l-i+1]=s[i]-'0';\rifor(i,1,k) maiN[i]=ori[i];\rifor(i,1,times[ori[1]]-1)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,ori,tmp);\rifor(j,1,k)\rmaiN[j]=tmp[j];\r}\rans[1]=times[ori[1]];\rifor(i,1,k)\rfac[i]=fac_maker[i]=maiN[i];\rint cur=1;\rwhile(++cur\u0026lt;k+1)\r{\rifor(i,1,k)\rmaiN[i]=ori[i];\rint cnt=0;\rwhile(cnt\u0026lt;=10)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,fac,tmp);\r++cnt;\rif(tmp[cur]==ori[cur]) break;\rifor(i,1,k)\rmaiN[i]=tmp[i];\rmemset(tmp,0,sizeof(tmp));\rmul_1(fac_maker,fac,tmp);\rifor(i,1,k)\rfac_maker[i]=tmp[i];\r}\rif(cnt\u0026gt;10) return puts(\u0026quot;-1\u0026quot;),0;\rmemset(tmp,0,sizeof(tmp));\rmul_2(ans,cnt,tmp);\rifor(i,1,100) ans[i]=tmp[i];\rifor(i,1,k) fac[i]=fac_maker[i];\r}\rint kk=100;\rwhile(ans[kk]==0\u0026amp;\u0026amp;kk\u0026gt;1) --kk;\rfor(int i=kk;i\u0026gt;=1;--i)\rprintf(\u0026quot;%d\u0026quot;,ans[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":0,"section":"posts","summary":"","tags":["模拟","递推"],"title":"Luogu P1050 循环","uri":"https://cs-fil.github.io/2020/03/luogu-p1050/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的字符串 $S$\n有 $m$ 个操作，保证 $m\\leq n$\n给定字符串 $T$1 初时为空\n共有以下两种操作\n 在字符串 $T$ 的末尾加上一个字符2 在字符串 $T$ 的开头加上一个字符   $n$ $\\leq$ $10^6$，$m$ $\\leq$ $3.3333$ $\\times$ $10^4$，$|\\Sigma|$ $\\leq$ $10^3$，$S_i$ $\\in$ $[1,|\\Sigma|]。$($\\Sigma$ 表示字符集$)$\n 每次操作完成后要求输出有几个 $l\\in [1,T.size]$ 满足对于 $\\forall i\\in [1,l]$ 有 $T[T.size-l+i]$ $\\neq$ $S_i$\n解 $17$ $pts$  模拟\n时间复杂度 $O(m^3)$\n$50$ $pts$  $f[i]$ 表示当前 $l=i$ 时是否满足条件\n分别考虑两种情况\n$1.$ $op=0$\n操作之后 每一位会得到新的状态\n不难发现 f[i]继承f[i-1]的true状态的条件为ch==T[i]\n则需将 $ch$ 逐位比对更新状态\n$2.$ $op=1$\n操作之后 对于 $f[j]$$,$$j\\in [1,i-1]$ 的状态没有影响\n仅需考虑新增的 $f[i]$\n将字符串 $T$ 与 $S$ 逐位比对方可得出新增状态\n优化\n1. 定义 $l[]$ $r[]$ 分别表示首增和末增\n2. 对于第 $1$ 种情况 可先继承后判断，$coding$ 时会清楚一些\n值得注意的是 应倒序继承避免覆盖\n 时间复杂度 $O(m^2)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,opn,k,kk,res;\rint s[1000002],l[40002],r[40002],f[40002];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;s[i]);\rifor(i,1,m)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;opn,\u0026amp;k);\rif(opn)\r{\rl[++l[0]]=k;\rint flg=1;\rkk=0;\rfor(int j=l[0];j\u0026gt;=1;--j)\rif(l[j]==s[++kk])\r{flg=0; break;}\rifor(j,1,r[0])\rif(r[j]==s[++kk]||!flg)\r{flg=0; break;}\rres+=(f[i]=flg);\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\relse\r{\rr[++r[0]]=k;\rres=0;\rfor(int j=i;j\u0026gt;=2;--j)\rf[j]=f[j-1];\rf[1]=1;\rifor(j,1,i)\rres+=(f[j]\u0026amp;=(k!=s[j]));\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r $100$ $pts$  沿用 $50 pts$ 的思路，使用位运算进行优化\n定义 $01$数组 $id[i]$ 表示字符 $i$ 在字符串 $S$ 中的比对情况\n分别考虑两种情况\n$1.$ $op=0$\nf=f\u0026lt;\u0026lt;1|id[k]即继承状态并考虑 $ch$ 的比对情况\n$2.$ $op=1$\nf|=id[k]\u0026lt;\u0026lt;(i-1)即把比对状态更新至对应的 $l$ 处\n举个例子:\n$213$ 首先读取 $2$ 的比对状态 而归于 $l=3$ 的范畴\n输出时用一个 $01$ 数限制位数，~(f|now)中 $0$ 的个数即为所求\n 使用位运算对未来的状态进行了规划，是一个长远的考虑\n 优化\n引入压位优化的 $01$ 数组 $bitset$\n 时间复杂度 $O(m^2/w)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;bitset\u0026gt;\r#include\u0026lt;cstdlib\u0026gt; #include\u0026lt;cctype\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rconst int inf=1e6+2;\rint n,m,opn,k;\rint it[inf];\rstd::bitset\u0026lt;35000\u0026gt; id[1002],f,now;\rinline int read(){\rint res=0;\rchar ch;\rwhile(isspace(ch=getchar()));\rdo\r{\rres=(res\u0026lt;\u0026lt;1)+(res\u0026lt;\u0026lt;3)+(ch^48);\r}while(isdigit(ch=getchar()));\rreturn res;\r}\rint main()\r{\rn=read(),m=read();\rifor(i,1,n)\rit[i]=read();\rifor(i,1,m)\rid[it[i]].set(i);\rnow.set();\rifor(i,1,m)\r{\ropn=read(),k=read();\rnow.reset(i);\rif(!opn)\rf=f\u0026lt;\u0026lt;1|id[k];\relse f|=id[k]\u0026lt;\u0026lt;(i-1);\rprintf(\u0026quot;%d\\n\u0026quot;,(~(f|now)).count());\r}\rreturn 0;\r}\r   字符串下标从 $1$ 开始 \u0026#x21a9;\u0026#xfe0e;\n 此处字符可能不止一位 \u0026#x21a9;\u0026#xfe0e;\n  ","id":1,"section":"posts","summary":"","tags":["位运算"],"title":"Luogu P5640 【CSGRound2】逐梦者的初心","uri":"https://cs-fil.github.io/2020/03/luogu-p5640/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i$$\u0026amp;$$b[i-1]$$\\neq$$0$，其中 $2$ $\\leq$ $i$ $\\leq$ $k$\n$1$ $\\leq$ $n$ $\\leq$ $100000$，$a_i$ $\\leq$ $10^9$\n解  $f[i]$ 表示当前最后一项的第 $i$ 位为 $1$ 的最大子序列长度\n当 $a$$\u0026amp;$$b$$\\neq$$0$，即 $ab$ 有相同的一位为 $1$，根据此性质进行转移\n在读入的过程中进行处理\n 若该数第 $i$ 位为 $1$，由于所定义的 $dp$ 数组的性质，转移时即为f[i]+1 取其中的最大值，再对其余数组进行更新，即 $k=max{f[i]+1}$ f[i]=k保证各个数组符合其性质  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,mxn;\rint f[30];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint t;\rwhile(n--)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rint k=1;\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rk=std::max(f[i]+1,k);\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rf[i]=k;\rmxn=std::max(mxn,k);\r}\rprintf(\u0026quot;%d\u0026quot;,mxn);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":2,"section":"posts","summary":"","tags":["位运算","动态规划"],"title":"Luogu P4310 绝世好题","uri":"https://cs-fil.github.io/2020/03/luogu-p4310/","year":"2020"},{"content":"链接 摘要  求数值 $k$$\\in$$[1,m]$ 经过 $n$ 次 $op$ $t$ 操作后的最大值\n $2\\leq n\\leq10^5$ $2\\leq m\\leq10^9$ $0\\leq t\\leq10^9$ $op$ 一定为 $or$ $xor$ $and$ 中的一种\n解  定义k1=0x7fffffff k2=0\n从二进制来看 $k1$ 每一位都是 $1$,$k2$ 每一位都是 $0$\n输入的过程中直接对 $k1$ $k2$ 进行操作\n对于第 $i$ 位 遵循贪心原则 $:$\n 若k2==1则ans+=1\u0026lt;\u0026lt;i 初始值的第 $i$ 位为 $0$ 或若k1==1则需考虑若初始值的第 $i$ 位为 $1$ 是否超出初始值范围 若否再而累加  debug  ans累加ans|=1\u0026lt;\u0026lt;i ans+=1\u0026lt;\u0026lt;i\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,t,ans,k1=0x7fffffff,k2=0;\rchar str[3];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\r{\rscanf(\u0026quot;%s%d\u0026quot;,str,\u0026amp;t);\rif(str[0]=='O') k1|=t,k2|=t;\rif(str[0]=='X') k1^=t,k2^=t;\rif(str[0]=='A') k1\u0026amp;=t,k2\u0026amp;=t;\r}\rfor(int i=29;~i;--i)\r{\rif(k2\u0026gt;\u0026gt;i\u0026amp;1) ans+=1\u0026lt;\u0026lt;i;\relse if(k1\u0026gt;\u0026gt;i\u0026amp;1\u0026amp;\u0026amp;m\u0026gt;=1\u0026lt;\u0026lt;i)\rans+=1\u0026lt;\u0026lt;i,m-=1\u0026lt;\u0026lt;i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":3,"section":"posts","summary":"","tags":["位运算","贪心"],"title":"Luogu P2114 [NOI2014]起床困难综合症","uri":"https://cs-fil.github.io/2020/03/luogu-p2114/","year":"2020"},{"content":"链接 摘要  $n$ 皇后问题\n $0\\lt n\\leq14$\n解  据数据范围 直接搜索会 $tle$\n使用位运算可以达到优化的目的\nmxstt即为列放置最终状态\n 构造函数dfs(cstt,l,r,ln)\n递归边界cstt==mxstt\n k=~(cstt|l|r|ln)\u0026amp;mxstt以获取改行状态\nlowbit(k)以列举可放置列 cstt表示列放置状态 $0$ 可放置 $1$ 不可放置\ncstt|lowbit(k) 以转移 l r分别表示左斜 右斜的状态 $01$ 义同上\n(l|lowbit(k))\u0026gt;\u0026gt;1 (r|lowbit(k))\u0026lt;\u0026lt;1以转移 ln表示当前行数\nln+1以转移   即dfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1)\ndebug  设置一个 $n$ 位二进制数的第 $k$ 位为 $1$ x|=k x|=1\u0026lt;\u0026lt;n-k l r的转移 (l|cstt)\u0026gt;\u0026gt;1 (l|lowbit(k))\u0026gt;\u0026gt;1 尤其注意用maxstate限制二进制位数  $Q$\u0026amp;$A$  $Q:$ 为什么不可以用单个状态stt 而是使用 $4$ 个变量推导状态 $？$\n$A:$ 因为左斜 右斜的转移方式与列放置状态的转移方式不同 $。$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint n,ans,mxstt;\rint stt[20];\rchar s[15];\rinline int lowbit(int x)\r{\rreturn x\u0026amp;-x;\r}\rinline void dfs(int cstt,int l,int r,int ln)\r{\rif(cstt==mxstt) {ans++; return;}\rint k=~(cstt|l|r|stt[ln])\u0026amp;mxstt;\rwhile(lowbit(k))\r{\rdfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1);\rk^=lowbit(k);\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rmxstt=(1\u0026lt;\u0026lt;n)-1;\rifor(i,1,n)\r{\rscanf(\u0026quot;%s\u0026quot;,s+1);\rifor(j,1,n)\rif(s[j]=='.')\rstt[i]|=(1\u0026lt;\u0026lt;n-j);\r}\rdfs(0,0,0,1);\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":4,"section":"posts","summary":"","tags":["位运算","搜索"],"title":"Luogu P1562 还是N皇后","uri":"https://cs-fil.github.io/2020/03/luogu-p1562/","year":"2020"},{"content":" $blog$ 建于 $2020.1.30$\n$aim:$ 每日 $4$ $AC$ 至 $2020$ $10$ 月下旬达成 $1000$ $AC\n","id":5,"section":"posts","summary":"","tags":["随笔"],"title":"2020 目标","uri":"https://cs-fil.github.io/2020/01/blog/","year":"2020"}],"tags":[{"title":"位运算","uri":"https://cs-fil.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"动态规划","uri":"https://cs-fil.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"搜索","uri":"https://cs-fil.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"title":"模拟","uri":"https://cs-fil.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"title":"贪心","uri":"https://cs-fil.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"title":"递推","uri":"https://cs-fil.github.io/tags/%E9%80%92%E6%8E%A8/"},{"title":"随笔","uri":"https://cs-fil.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}