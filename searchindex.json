{"categories":[{"title":"文","uri":"https://cs-fil.github.io/categories/%E6%96%87/"},{"title":"题解","uri":"https://cs-fil.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"posts":[{"content":"链接 摘要  求数值 $k$$\\in$$[1,m]$ 经过 $n$ 次 $op$ $t$ 操作后的最大值\n $2\\leq n\\leq10^5$ $2\\leq m\\leq10^9$ $0\\leq t\\leq10^9$ $op$ 一定为 $or$ $xor$ $and$ 中的一种\n解  定义k1=0x7fffffff k2=0\n从二进制来看 $k1$ 每一位都是 $1$,$k2$ 每一位都是 $0$\n输入的过程中直接对 $k1$ $k2$ 进行操作\n对于第 $i$ 位 遵循贪心原则 $:$\n 若k2==1则ans+=1\u0026lt;\u0026lt;i 初始值的第 $i$ 位为 $0$ 或若k1==1则需考虑若初始值的第 $i$ 位为 $1$ 是否超出初始值范围 若否再而累加  debug  ans累加ans|=1\u0026lt;\u0026lt;i ans+=1\u0026lt;\u0026lt;i\ncode #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,t,ans,k1=0x7fffffff,k2=0;\rchar str[3];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\r{\rscanf(\u0026quot;%s%d\u0026quot;,str,\u0026amp;t);\rif(str[0]=='O') k1|=t,k2|=t;\rif(str[0]=='X') k1^=t,k2^=t;\rif(str[0]=='A') k1\u0026amp;=t,k2\u0026amp;=t;\r}\rfor(int i=29;~i;--i)\r{\rif(k2\u0026gt;\u0026gt;i\u0026amp;1) ans+=1\u0026lt;\u0026lt;i;\relse if(k1\u0026gt;\u0026gt;i\u0026amp;1\u0026amp;\u0026amp;m\u0026gt;=1\u0026lt;\u0026lt;i)\rans+=1\u0026lt;\u0026lt;i,m-=1\u0026lt;\u0026lt;i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":0,"section":"posts","summary":"","tags":["位运算","贪心"],"title":"Luogu P2114 [NOI2014]起床困难综合症","uri":"https://cs-fil.github.io/2020/03/luogu-p2114/","year":"2020"},{"content":"链接 摘要  $n$ 皇后问题\n $0\u0026lt;n\\leq14$\n解  据数据范围 直接搜索会 $tle$\n使用位运算可以达到优化的目的\nmxstt即为列放置最终状态\n 构造函数dfs(cstt,l,r,ln)\n递归边界cstt==mxstt\n k=~(cstt|l|r|ln)\u0026amp;mxstt以获取改行状态\nlowbit(k)以列举可放置列 cstt表示列放置状态 $0$ 可放置 $1$ 不可放置\ncstt|lowbit(k) 以转移 l r分别表示左斜 右斜的状态 $01$ 义同上\n(l|lowbit(k))\u0026gt;\u0026gt;1 (r|lowbit(k))\u0026lt;\u0026lt;1以转移 ln表示当前行数\nln+1以转移   即dfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1)\ndebug  设置一个 $n$ 位二进制数的第 $k$ 位为 $1$ x|=k x|=1\u0026lt;\u0026lt;n-k l r的转移 (l|cstt)\u0026gt;\u0026gt;1 (l|lowbit(k))\u0026gt;\u0026gt;1 尤其注意用maxstate限制二进制位数  $Q$\u0026amp;$A$  $Q:$ 为什么不可以用单个状态stt 而是使用 $4$ 个变量推导状态 $？$\n$A:$ 因为左斜 右斜的转移方式与列放置状态的转移方式不同 $。$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint n,ans,mxstt;\rint stt[20];\rchar s[15];\rinline int lowbit(int x)\r{\rreturn x\u0026amp;-x;\r}\rinline void dfs(int cstt,int l,int r,int ln)\r{\rif(cstt==mxstt) {ans++; return;}\rint k=~(cstt|l|r|stt[ln])\u0026amp;mxstt;\rwhile(lowbit(k))\r{\rdfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1);\rk^=lowbit(k);\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rmxstt=(1\u0026lt;\u0026lt;n)-1;\rifor(i,1,n)\r{\rscanf(\u0026quot;%s\u0026quot;,s+1);\rifor(j,1,n)\rif(s[j]=='.')\rstt[i]|=(1\u0026lt;\u0026lt;n-j);\r}\rdfs(0,0,0,1);\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":1,"section":"posts","summary":"","tags":["位运算","搜索"],"title":"Luogu P1562 还是N皇后","uri":"https://cs-fil.github.io/2020/03/luogu-p1562/","year":"2020"},{"content":" $blog$ 建于 $2020.1.30$\n$aim:$ 每日 $4$ $AC$ 至 $2020$ $10$ 月下旬达成 $1000$ $AC\n","id":2,"section":"posts","summary":"","tags":["随笔"],"title":"2020 目标","uri":"https://cs-fil.github.io/2020/01/blog/","year":"2020"}],"tags":[{"title":"位运算","uri":"https://cs-fil.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"搜索","uri":"https://cs-fil.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"title":"贪心","uri":"https://cs-fil.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"title":"随笔","uri":"https://cs-fil.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}