{"categories":[{"title":"文","uri":"https://cs-fil.github.io/categories/%E6%96%87/"},{"title":"知识点","uri":"https://cs-fil.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"题解","uri":"https://cs-fil.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"posts":[{"content":"定义  对一个有向无环图 ( Directed Acyclic Graph 简称 $DAG$ ) $G$ 进行拓扑排序，是将 $G$ 中所有顶点排成一个线性序列，使得图中任意一对顶点 $u$ 和 $v$ ，若边 $\u0026lt;u,v\u0026gt;∈E(G)$ ，则 $u$ 在线性序列中出现在 $v$ 之前。\ncode inline void topsort()\r{\rstd::queue\u0026lt;int\u0026gt;q;\rifor(i,1,n)\rif(!id[i])\rq.push(i),tsrt[++c]=i;\rwhile(!q.empty())\r{\rint u=q.front();q.pop();\rfor(int i=h[u];i;i=nxt[i])\r{\rid[ver[i]]--;\rif(!id[ver[i]])\rq.push(ver[i]),tsrt[++c]=ver[i];\r}\r}\r}\r","id":0,"section":"posts","summary":"","tags":["拓扑排序"],"title":"topsort","uri":"https://cs-fil.github.io/2020/11/topsort/","year":"2020"},{"content":"链接 摘要  $4$ 座汉诺塔\n解  回想 $3$ 座汉诺塔的解法，对于 $n$ 塔，先将 $n-1$ 塔移至 $B$ 座，后将底塔移至 $C$ 座，最后将 $n-1$ 塔移至 $C$ 座。基于递推的思想。\n$4$ 座汉诺塔类似，按照 $4$ 座的方式将 $i$ 塔移至 $B$ 座，因为大塔不可覆盖小塔，于是对于剩下的 $n-i$ 塔问题转化为 $3$ 座汉诺塔。\n于是有 $h4[i]=min$ { $h4[j]*2+h3[i-j]|i \\in [2,n],j \\in [1,i)$ } $ , h4[1]=1$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint a[13],b[13];\rint main()\r{\rmemset(b,0x3f,sizeof(b));\ra[1]=b[1]=1;\rprintf(\u0026quot;%d\\n\u0026quot;,b[1]);\rifor(i,2,12)\r{\ra[i]=(a[i-1]\u0026lt;\u0026lt;1)+1;\rifor(j,1,i-1)\rb[i]=std::min(b[i],(b[j]\u0026lt;\u0026lt;1)+a[i-j]);\rprintf(\u0026quot;%d\\n\u0026quot;,b[i]);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":1,"section":"posts","summary":"","tags":["递推"],"title":"POJ 1958 Strange Towers of Hanoi","uri":"https://cs-fil.github.io/2020/09/poj-1958/","year":"2020"},{"content":"链接 摘要  给定 $5$ $\\times$ $5$ 的 $01$ 矩阵\n给出一个操作 使 $+$ 型共 $5$ 个数变为其相反的状态\n求使原矩阵归 $1$ 的操作数\n解 1. 怎么做及为什么是对的  通过观察 发现如下三点性质\n1) 每一个数至多进行一次操作 因为两次以上则会自我抵消\n2) 若要求不在第 $n$ 行前再进行操作 则下一行及之后的情况也一并固定只有一种 由于操作的特殊性 若想改变第 $n$ 行第 $i$ 个数且不在本行操作 则只能在下一行的第 $i$ 位操作来改变它\n3) 操作顺序不影响最终结果\n于是只需枚举第一行的操作方式 验证是否可行记录最小值即可\n2. 怎么想到这样做  将无序的操作有序化，是本题的关键。将任意的操作行行分类，结合操作的特殊性，发现本题的突破口，找到其性质。最后将其转化为指数型枚举问题。\ndebug 及技巧  $01$ 矩阵 容易想到用位运算 然而再看操作 发现 $+$ 的横 实现不便(位运算不可移负数位) 于是将其整体向左移一位即可\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint T,a[6],ori[6];\rint mnx=0x7fffffff,k;\rstd::string s;\rinline void wrk(int x)\r{\rifor(i,1,5)\rif(!((a[x-1]\u0026gt;\u0026gt;(5-i+1))\u0026amp;1))\r{\r++k;\ra[x-1]^=(2\u0026lt;\u0026lt;(4-i+1));\ra[x]=(a[x]^(7\u0026lt;\u0026lt;(4-i+1)))\u0026amp;62;\ra[x+1]^=(2\u0026lt;\u0026lt;(4-i+1));\r}\rif(x==5)\r{\rif(a[5]==62)\rmnx=std::min(mnx,k);\rreturn;\r}\rwrk(x+1);\r}\rinline void cnt(int cur)\r{\rif(cur==6)\r{\rint m=k;\rifor(i,1,5) ori[i]=a[i];\rwrk(2);\r/*回归状态*/\rifor(i,1,5) a[i]=ori[i];\rk=m;\rreturn;\r}\r/*点击1行第cur个灯*/\ra[1]=(a[1]^(7\u0026lt;\u0026lt;(4-cur+1)))\u0026amp;62;\ra[2]^=(2\u0026lt;\u0026lt;(4-cur+1));\r++k;\rcnt(cur+1);\ra[1]=(a[1]^(7\u0026lt;\u0026lt;(4-cur+1)))\u0026amp;62;\ra[2]^=(2\u0026lt;\u0026lt;(4-cur+1));\r--k;\rcnt(cur+1);\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;T);\rwhile(T--)\r{\rmnx=0x7fffffff,k=0;\rmemset(a,0,sizeof(a));\rifor(i,1,5)\r{\rstd::cin\u0026gt;\u0026gt;s;\rifor(j,1,5)\rif(s[j-1]=='1')\ra[i]|=(1\u0026lt;\u0026lt;(5-j+1));\r}\rcnt(1);\rif(mnx==0x7fffffff||mnx\u0026gt;6)\rputs(\u0026quot;-1\u0026quot;);\relse printf(\u0026quot;%d\\n\u0026quot;,mnx);\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":2,"section":"posts","summary":"","tags":["位运算","枚举"],"title":"CH 0201 费解的开关","uri":"https://cs-fil.github.io/2020/09/ch-0201/","year":"2020"},{"content":"链接 摘要  给定 $n$ 个数 求最长下降子序列位数和方案数1\n$1$ $\\leq$ $n$ $\\leq$ $5000$\n解  难点在于如何求方案数\n定义 $f[i]$ 表示以 $arr[i]$ 结尾的最长下降子序列位数\n判断末位大小关系 若可，f[i]=std::max(f[i],f[j]+1)以转移\n重点 定义 $c[i]$ 表示以 $arr[i]$ 结尾的最长下降子序列方案数\n 判重 若两个子序列位数相同且末位相等 那么容易得知构成前一个序列的方案必然可以构成后者 则需清空前者的 $c[]$ 以去重 转移 判断末位大小关系和子序列位数关系 若可，c[i]+=c[j]以转移   $dp$ 过程中存储位数最大值 最后位数符合最大值的子序列的方案数相加即为方案总数\ndebug  memset(arr,1,sizeof(arr))无法达到令 $arr$ 数组每一位为 $1$ 的效果，解决方案是手打循环赋值\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=5e3+9;\rint n,mxn,ans;\rint arr[inf],f[inf],c[inf];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;arr[i]),f[i]=1;\rifor(i,1,n)\r{\rifor(j,1,i-1)\rif(arr[i]\u0026lt;arr[j])\rf[i]=std::max(f[i],f[j]+1);\rmxn=std::max(mxn,f[i]);\rifor(j,1,i-1)\rif(f[j]==f[i]\u0026amp;\u0026amp;arr[j]==arr[i])\rc[j]=0;\relse if(arr[i]\u0026lt;arr[j]\u0026amp;\u0026amp;f[j]==f[i]-1)\rc[i]+=c[j];\rif(!c[i]) ++c[i];\r}\rifor(i,1,n)\rif(f[i]==mxn)\rans+=c[i];\rprintf(\u0026quot;%d %d\u0026quot;,mxn,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r   若构成的队列相同则认为属于同一个方案 \u0026#x21a9;\u0026#xfe0e;\n  ","id":3,"section":"posts","summary":"","tags":["动态规划","递推"],"title":"Luogu P1108 低价购买","uri":"https://cs-fil.github.io/2020/03/luogu-p1108/","year":"2020"},{"content":"链接 摘要  对于一个整数 $n$ 的正整数次幂，后 $k$ 位是否发生循环\n若是 求循环长度 $k$ $\\leq$ $100$\n解  从尾部递推\n依次保证 后 $1$ 位循环，后 $2$ 位循环……后 $k$ 位循环\n定义fac在保证原数与之相乘 后 $m$ 位不变的前提下，探究保证第 $m+1$ 位不变的条件\n定义fac_maker以计算fac\n若次数 $cnt \u0026gt; 10$ 可判断不循环\n若 $cnt \u0026lt; 10$，将每一位探究的次数相乘可得到循环长度\n值得注意的是 由数据范围知应使用高精度\ndebug  乘法高精度中c[i+j-1]=a[i]*b[j] c[i+j-1]+=a[i]*b[j]  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rconst int inf=1e4+9,times[10]={1,1,4,4,2,1,1,4,4,2};\rint k;\rint ans[102],ori[102],maiN[inf],fac[inf],fac_maker[inf],tmp[inf];\rchar s[102];\rinline void mul_1(int a[],int b[],int c[])\r{\rifor(i,1,k)\rifor(j,1,k)\rc[i+j-1]+=a[i]*b[j],c[i+j]+=c[i+j-1]/10,c[i+j-1]%=10;\r}\rinline void mul_2(int a[],int b,int c[])\r{\rifor(i,1,k)\rc[i]+=a[i]*b,c[i+1]+=c[i]/10,c[i]%=10;\r}\rint main()\r{\rscanf(\u0026quot;%s%d\u0026quot;,s+1,\u0026amp;k);\rint l=strlen(s+1);\rfor(int i=l;i\u0026gt;=l-k+1;--i)\rori[l-i+1]=s[i]-'0';\rifor(i,1,k) maiN[i]=ori[i];\rifor(i,1,times[ori[1]]-1)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,ori,tmp);\rifor(j,1,k)\rmaiN[j]=tmp[j];\r}\rans[1]=times[ori[1]];\rifor(i,1,k)\rfac[i]=fac_maker[i]=maiN[i];\rint cur=1;\rwhile(++cur\u0026lt;k+1)\r{\rifor(i,1,k)\rmaiN[i]=ori[i];\rint cnt=0;\rwhile(cnt\u0026lt;=10)\r{\rmemset(tmp,0,sizeof(tmp));\rmul_1(maiN,fac,tmp);\r++cnt;\rif(tmp[cur]==ori[cur]) break;\rifor(i,1,k)\rmaiN[i]=tmp[i];\rmemset(tmp,0,sizeof(tmp));\rmul_1(fac_maker,fac,tmp);\rifor(i,1,k)\rfac_maker[i]=tmp[i];\r}\rif(cnt\u0026gt;10) return puts(\u0026quot;-1\u0026quot;),0;\rmemset(tmp,0,sizeof(tmp));\rmul_2(ans,cnt,tmp);\rifor(i,1,100) ans[i]=tmp[i];\rifor(i,1,k) fac[i]=fac_maker[i];\r}\rint kk=100;\rwhile(ans[kk]==0\u0026amp;\u0026amp;kk\u0026gt;1) --kk;\rfor(int i=kk;i\u0026gt;=1;--i)\rprintf(\u0026quot;%d\u0026quot;,ans[i]);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":4,"section":"posts","summary":"","tags":["模拟","递推"],"title":"Luogu P1050 循环","uri":"https://cs-fil.github.io/2020/03/luogu-p1050/","year":"2020"},{"content":"证明: $n$ 的简化剩余系是 φ","id":5,"section":"posts","summary":"","tags":["模拟","递推"],"title":"Luogu P1050 循环","uri":"https://cs-fil.github.io/2020/03/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的字符串 $S$\n有 $m$ 个操作，保证 $m\\leq n$\n给定字符串 $T$1 初时为空\n共有以下两种操作\n 在字符串 $T$ 的末尾加上一个字符2 在字符串 $T$ 的开头加上一个字符   $n$ $\\leq$ $10^6$，$m$ $\\leq$ $3.3333$ $\\times$ $10^4$，$|\\Sigma|$ $\\leq$ $10^3$，$S_i$ $\\in$ $[1,|\\Sigma|]。$($\\Sigma$ 表示字符集$)$\n 每次操作完成后要求输出有几个 $l\\in [1,T.size]$ 满足对于 $\\forall i\\in [1,l]$ 有 $T[T.size-l+i]$ $\\neq$ $S_i$\n解 $17$ $pts$  模拟\n时间复杂度 $O(m^3)$\n$50$ $pts$  $f[i]$ 表示当前 $l=i$ 时是否满足条件\n分别考虑两种情况\n$1.$ $op=0$\n操作之后 每一位会得到新的状态\n不难发现 f[i]继承f[i-1]的true状态的条件为ch==T[i]\n则需将 $ch$ 逐位比对更新状态\n$2.$ $op=1$\n操作之后 对于 $f[j]$$,$$j\\in [1,i-1]$ 的状态没有影响\n仅需考虑新增的 $f[i]$\n将字符串 $T$ 与 $S$ 逐位比对方可得出新增状态\n优化\n1. 定义 $l[]$ $r[]$ 分别表示首增和末增\n2. 对于第 $1$ 种情况 可先继承后判断，$coding$ 时会清楚一些\n值得注意的是 应倒序继承避免覆盖\n 时间复杂度 $O(m^2)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,opn,k,kk,res;\rint s[1000002],l[40002],r[40002],f[40002];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;s[i]);\rifor(i,1,m)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;opn,\u0026amp;k);\rif(opn)\r{\rl[++l[0]]=k;\rint flg=1;\rkk=0;\rfor(int j=l[0];j\u0026gt;=1;--j)\rif(l[j]==s[++kk])\r{flg=0; break;}\rifor(j,1,r[0])\rif(r[j]==s[++kk]||!flg)\r{flg=0; break;}\rres+=(f[i]=flg);\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\relse\r{\rr[++r[0]]=k;\rres=0;\rfor(int j=i;j\u0026gt;=2;--j)\rf[j]=f[j-1];\rf[1]=1;\rifor(j,1,i)\rres+=(f[j]\u0026amp;=(k!=s[j]));\rprintf(\u0026quot;%d\\n\u0026quot;,res);\r}\r}\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r $100$ $pts$  沿用 $50 pts$ 的思路，使用位运算进行优化\n定义 $01$数组 $id[i]$ 表示字符 $i$ 在字符串 $S$ 中的比对情况\n分别考虑两种情况\n$1.$ $op=0$\nf=f\u0026lt;\u0026lt;1|id[k]即继承状态并考虑 $ch$ 的比对情况\n$2.$ $op=1$\nf|=id[k]\u0026lt;\u0026lt;(i-1)即把比对状态更新至对应的 $l$ 处\n举个例子:\n$213$ 首先读取 $2$ 的比对状态 而归于 $l=3$ 的范畴\n输出时用一个 $01$ 数限制位数，~(f|now)中 $0$ 的个数即为所求\n 使用位运算对未来的状态进行了规划，是一个长远的考虑\n 优化\n引入压位优化的 $01$ 数组 $bitset$\n 时间复杂度 $O(m^2/w)$\n代码\n#include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;bitset\u0026gt;\r#include\u0026lt;cstdlib\u0026gt; #include\u0026lt;cctype\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rconst int inf=1e6+2;\rint n,m,opn,k;\rint it[inf];\rstd::bitset\u0026lt;35000\u0026gt; id[1002],f,now;\rinline int read(){\rint res=0;\rchar ch;\rwhile(isspace(ch=getchar()));\rdo\r{\rres=(res\u0026lt;\u0026lt;1)+(res\u0026lt;\u0026lt;3)+(ch^48);\r}while(isdigit(ch=getchar()));\rreturn res;\r}\rint main()\r{\rn=read(),m=read();\rifor(i,1,n)\rit[i]=read();\rifor(i,1,m)\rid[it[i]].set(i);\rnow.set();\rifor(i,1,m)\r{\ropn=read(),k=read();\rnow.reset(i);\rif(!opn)\rf=f\u0026lt;\u0026lt;1|id[k];\relse f|=id[k]\u0026lt;\u0026lt;(i-1);\rprintf(\u0026quot;%d\\n\u0026quot;,(~(f|now)).count());\r}\rreturn 0;\r}\r   字符串下标从 $1$ 开始 \u0026#x21a9;\u0026#xfe0e;\n 此处字符可能不止一位 \u0026#x21a9;\u0026#xfe0e;\n  ","id":6,"section":"posts","summary":"","tags":["位运算"],"title":"Luogu P5640 【CSGRound2】逐梦者的初心","uri":"https://cs-fil.github.io/2020/03/luogu-p5640/","year":"2020"},{"content":"链接 摘要  给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i$$\u0026amp;$$b[i-1]$$\\neq$$0$，其中 $2$ $\\leq$ $i$ $\\leq$ $k$\n$1$ $\\leq$ $n$ $\\leq$ $100000$，$a_i$ $\\leq$ $10^9$\n解  定义 $f[i]$ 表示当前最后一项的第 $i$ 位为 $1$ 的最大子序列长度\n当 $a$$\u0026amp;$$b$$\\neq$$0$，即 $ab$ 有相同的一位为 $1$，根据此性质进行转移\n在读入的过程中进行处理\n 若该数第 $i$ 位为 $1$，由于所定义的 $dp$ 数组的性质，转移时即为f[i]+1 取其中的最大值，再对其余数组进行更新，即 $k=max{f[i]+1}$ f[i]=k保证各个数组符合其性质  代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,mxn;\rint f[30];\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint t;\rwhile(n--)\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rint k=1;\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rk=std::max(f[i]+1,k);\rifor(i,0,29)\rif(1\u0026lt;\u0026lt;i\u0026amp;t)\rf[i]=k;\rmxn=std::max(mxn,k);\r}\rprintf(\u0026quot;%d\u0026quot;,mxn);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":7,"section":"posts","summary":"","tags":["位运算","动态规划"],"title":"Luogu P4310 绝世好题","uri":"https://cs-fil.github.io/2020/03/luogu-p4310/","year":"2020"},{"content":"链接 摘要  求数值 $k$$\\in$$[1,m]$ 经过 $n$ 次 $op$ $t$ 操作后的最大值\n $2\\leq n\\leq10^5$ $2\\leq m\\leq10^9$ $0\\leq t\\leq10^9$ $op$ 一定为 $or$ $xor$ $and$ 中的一种\n解  定义k1=0x7fffffff k2=0\n从二进制来看 $k1$ 每一位都是 $1$,$k2$ 每一位都是 $0$\n输入的过程中直接对 $k1$ $k2$ 进行操作\n对于第 $i$ 位 遵循贪心原则 $:$\n 若k2==1则ans+=1\u0026lt;\u0026lt;i 初始值的第 $i$ 位为 $0$ 或若k1==1则需考虑若初始值的第 $i$ 位为 $1$ 是否超出初始值范围 若否再而累加  debug  ans累加ans|=1\u0026lt;\u0026lt;i ans+=1\u0026lt;\u0026lt;i\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);++i)\rint n,m,t,ans,k1=0x7fffffff,k2=0;\rchar str[3];\rint main()\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rifor(i,1,n)\r{\rscanf(\u0026quot;%s%d\u0026quot;,str,\u0026amp;t);\rif(str[0]=='O') k1|=t,k2|=t;\rif(str[0]=='X') k1^=t,k2^=t;\rif(str[0]=='A') k1\u0026amp;=t,k2\u0026amp;=t;\r}\rfor(int i=29;~i;--i)\r{\rif(k2\u0026gt;\u0026gt;i\u0026amp;1) ans+=1\u0026lt;\u0026lt;i;\relse if(k1\u0026gt;\u0026gt;i\u0026amp;1\u0026amp;\u0026amp;m\u0026gt;=1\u0026lt;\u0026lt;i)\rans+=1\u0026lt;\u0026lt;i,m-=1\u0026lt;\u0026lt;i;\r}\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":8,"section":"posts","summary":"","tags":["位运算","贪心"],"title":"Luogu P2114 [NOI2014]起床困难综合症","uri":"https://cs-fil.github.io/2020/03/luogu-p2114/","year":"2020"},{"content":"链接 摘要  $n$ 皇后问题\n $0\\lt n\\leq14$\n解  据数据范围 直接搜索会 $tle$\n使用位运算可以达到优化的目的\nmxstt即为列放置最终状态\n 构造函数dfs(cstt,l,r,ln)\n递归边界cstt==mxstt\n k=~(cstt|l|r|ln)\u0026amp;mxstt以获取改行状态\nlowbit(k)以列举可放置列 cstt表示列放置状态 $0$ 可放置 $1$ 不可放置\ncstt|lowbit(k) 以转移 l r分别表示左斜 右斜的状态 $01$ 义同上\n(l|lowbit(k))\u0026gt;\u0026gt;1 (r|lowbit(k))\u0026lt;\u0026lt;1以转移 ln表示当前行数\nln+1以转移   即dfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1)\ndebug  设置一个 $n$ 位二进制数的第 $k$ 位为 $1$ x|=k x|=1\u0026lt;\u0026lt;n-k l r的转移 (l|cstt)\u0026gt;\u0026gt;1 (l|lowbit(k))\u0026gt;\u0026gt;1 尤其注意用maxstate限制二进制位数  $Q$$\u0026amp;$$A$  $Q:$ 为什么不可以用单个状态stt 而是使用 $4$ 个变量推导状态 $？$\n$A:$ 因为左斜 右斜的转移方式与列放置状态的转移方式不同 $。$\n代码 #include\u0026lt;cstdio\u0026gt;\r#include\u0026lt;cstdlib\u0026gt;\r#define ifor(i,a,b) for(int i=(a);i\u0026lt;=(b);i++)\rint n,ans,mxstt;\rint stt[20];\rchar s[15];\rinline int lowbit(int x)\r{\rreturn x\u0026amp;-x;\r}\rinline void dfs(int cstt,int l,int r,int ln)\r{\rif(cstt==mxstt) {ans++; return;}\rint k=~(cstt|l|r|stt[ln])\u0026amp;mxstt;\rwhile(lowbit(k))\r{\rdfs(cstt|lowbit(k),(l|lowbit(k))\u0026gt;\u0026gt;1,(r|lowbit(k))\u0026lt;\u0026lt;1,ln+1);\rk^=lowbit(k);\r}\r}\rint main()\r{\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rmxstt=(1\u0026lt;\u0026lt;n)-1;\rifor(i,1,n)\r{\rscanf(\u0026quot;%s\u0026quot;,s+1);\rifor(j,1,n)\rif(s[j]=='.')\rstt[i]|=(1\u0026lt;\u0026lt;n-j);\r}\rdfs(0,0,0,1);\rprintf(\u0026quot;%d\u0026quot;,ans);\rsystem(\u0026quot;pause\u0026quot;);\rreturn 0;\r}\r","id":9,"section":"posts","summary":"","tags":["位运算","搜索"],"title":"Luogu P1562 还是N皇后","uri":"https://cs-fil.github.io/2020/03/luogu-p1562/","year":"2020"},{"content":" $blog$ 建于 $2020.1.30$\n$aim:$ 每日 $4$ $AC$ 至 $2020$ $10$ 月下旬达成 $1000$ $AC\n","id":10,"section":"posts","summary":"","tags":["随笔"],"title":"2020 目标","uri":"https://cs-fil.github.io/2020/01/blog/","year":"2020"}],"tags":[{"title":"位运算","uri":"https://cs-fil.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"动态规划","uri":"https://cs-fil.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"拓扑排序","uri":"https://cs-fil.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"搜索","uri":"https://cs-fil.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"title":"枚举","uri":"https://cs-fil.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"title":"模拟","uri":"https://cs-fil.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"title":"贪心","uri":"https://cs-fil.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"title":"递推","uri":"https://cs-fil.github.io/tags/%E9%80%92%E6%8E%A8/"},{"title":"随笔","uri":"https://cs-fil.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}